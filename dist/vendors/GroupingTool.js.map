{"version":3,"sources":["webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.yaml","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.less","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.html?9eb3","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.less?c5e4","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.html","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.js?5ca6","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.js","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.less?c42f","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.vue","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.yaml?3aad","webpack:///./src/components/ReplacePanel/GroupingTool/kmeans.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA,kCAAkC,SAAS,kBAAkB,UAAU,eAAe;AACtF;AACA;;;;;;;;;;;;ACJA,2BAA2B,mBAAO,CAAC,8GAAyD;AAC5F;AACA,cAAc,QAAS,2BAA2B,2BAA2B,GAAG,2BAA2B,2BAA2B,GAAG,0BAA0B,kCAAkC,2BAA2B,iCAAiC,GAAG,2BAA2B,kCAAkC,GAAG,SAAS,oMAAoM,WAAW,KAAK,KAAK,WAAW,KAAK,KAAK,WAAW,WAAW,WAAW,KAAK,KAAK,WAAW,qHAAqH,2BAA2B,GAAG,sBAAsB,qCAAqC,MAAM,YAAY,2BAA2B,GAAG,aAAa,kCAAkC,2BAA2B,iCAAiC,GAAG,UAAU,kCAAkC,GAAG,UAAU,2BAA2B,GAAG,UAAU,2BAA2B,GAAG,SAAS,kCAAkC,2BAA2B,iCAAiC,GAAG,UAAU,kCAAkC,GAAG,KAAK;;;;;;;;;;;;;ACF1vC;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD,eAAe,wBAAwB;AACvC,mBAAmB,SAAS,8BAA8B,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAA6C;AAC7D,mBAAmB,+CAA+C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,mBAAmB,SAAS,iCAAiC,EAAE;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAgD;AAChE,mBAAmB,kDAAkD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,wBAAwB,SAAS,iBAAiB,EAAE;AACpD;AACA;AACA;AACA,wBAAwB,SAAS,kBAAkB,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C,mBAAmB,kDAAkD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC,eAAe;AACf,SAAS;AACT,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9IA;;AAEA;AACA,cAAc,mBAAO,CAAC,uhBAAyQ;AAC/R,4CAA4C,QAAS;AACrD;AACA;AACA,UAAU,mBAAO,CAAC,gIAAmE;AACrF,+CAA+C;AAC/C;AACA,GAAG,KAAU,EAAE,E;;;;;;;;;;;;ACVf;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;ACAA;AAAA;AAAA,wCAA+D,CAAgB,gJAAG,EAAC,C;;;;;;;;;;;;ACAnF;AAAA;AAAgC;;AAEhC;AACA;AACA,W;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;;AAEA,6DAA6D,kBAAkB;AAC/E;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;;AAEA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,YAAY;AACZ,UAAU;AACV;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,mBAAmB,0DAAM;AACzB;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,WAAW,aAAa;;AAExB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,YAAY;AACjC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,WAAW,aAAa;AACxB;AACA;AACA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,2E;;;;;;;;;;;;ACpgBf;AAAA;AAAA;AAAA;AAA6U,CAAgB,2WAAG,EAAC,C;;;;;;;;;;;;ACAjW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwG;AACzC;AACL;AACwC;;;AAGlG;AACgG;AAChG,gBAAgB,2GAAU;AAC1B,EAAE,iFAAM;AACR,EAAE,oGAAM;AACR,EAAE,6GAAe;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AAC+K;AAC/K,WAAW,gMAAM,iBAAiB,wMAAM;;AAExC;AACA,IAAI,KAAU,EAAE,YAiBf;AACD;AACe,gF;;;;;;;;;;;;AC3Cf;AAAA;AAAA;AAAA;AAA8O,CAAgB,gTAAG,EAAC,C;;;;;;;;;;;;ACAlQ;AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA,qBAAqB,SAAS;AAC9B,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEe,qEAAM,E","file":"vendors/GroupingTool.js","sourcesContent":["module.exports = function (Component) {\n  Component.options.__i18n = Component.options.__i18n || []\n  Component.options.__i18n.push('{\"en-US\":{\"Search\":\"Search\"},\"zh-TW\":{\"Search\":\"搜尋\"}}')\n  delete Component.options._Ctor\n}\n","exports = module.exports = require(\"../../../../node_modules/css-loader/dist/runtime/api.js\")(true);\n// Module\nexports.push([module.id, \"input[data-v-1d066bc0] {\\n  width: 5rem !important;\\n}\\nselect[data-v-1d066bc0] {\\n  width: auto !important;\\n}\\nlabel[data-v-1d066bc0] {\\n  margin-right: 1rem !important;\\n  width: 4rem !important;\\n  text-align: right !important;\\n}\\nbutton[data-v-1d066bc0] {\\n  margin-right: 1rem !important;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"/app/src/components/ReplacePanel/GroupingTool/GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\",\"GroupingTool.less\"],\"names\":[],\"mappings\":\"AAAA;EACE,sBAAA;ACCF;ADMA;EACE,sBAAA;ACJF;ADQA;EACE,6BAAA;EACA,sBAAA;EACA,4BAAA;ACNF;ADQA;EACE,6BAAA;ACNF\",\"file\":\"GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\",\"sourcesContent\":[\"input {\\n  width: 5rem !important;\\n}\\n\\n// .GroupingTool {\\n//   margin-top: 0.2rem !important;\\n// }\\n\\nselect {\\n  width: auto !important;\\n}\\n\\n\\nlabel {\\n  margin-right: 1rem !important;\\n  width: 4rem !important;\\n  text-align: right !important;\\n}\\nbutton {\\n  margin-right: 1rem !important;\\n}\",\"input {\\n  width: 5rem !important;\\n}\\nselect {\\n  width: auto !important;\\n}\\nlabel {\\n  margin-right: 1rem !important;\\n  width: 4rem !important;\\n  text-align: right !important;\\n}\\nbutton {\\n  margin-right: 1rem !important;\\n}\\n\"]}]);\n","var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"GroupingTool\" }, [\n    _c(\"div\", { staticClass: \"fields\" }, [\n      _c(\"label\", { attrs: { for: \"GroupingToolSkipRows\" } }, [\n        _vm._v(\"\\n      \" + _vm._s(_vm.$t(\"Skip Rows\")) + \"\\n    \")\n      ]),\n      _vm._v(\" \"),\n      _c(\"input\", {\n        directives: [\n          {\n            name: \"model\",\n            rawName: \"v-model\",\n            value: _vm.localConfig.GroupingTool.skipRows,\n            expression: \"localConfig.GroupingTool.skipRows\"\n          }\n        ],\n        attrs: { type: \"number\", id: \"GroupingToolSkipRows\" },\n        domProps: { value: _vm.localConfig.GroupingTool.skipRows },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig.GroupingTool,\n              \"skipRows\",\n              $event.target.value\n            )\n          }\n        }\n      }),\n      _vm._v(\" \"),\n      _c(\"label\", { attrs: { for: \"GroupingToolSkipColumns\" } }, [\n        _vm._v(\"\\n      \" + _vm._s(_vm.$t(\"Skip Cols\")) + \"\\n    \")\n      ]),\n      _vm._v(\" \"),\n      _c(\"input\", {\n        directives: [\n          {\n            name: \"model\",\n            rawName: \"v-model\",\n            value: _vm.localConfig.GroupingTool.skipColumns,\n            expression: \"localConfig.GroupingTool.skipColumns\"\n          }\n        ],\n        attrs: { type: \"number\", id: \"GroupingToolSkipColumns\" },\n        domProps: { value: _vm.localConfig.GroupingTool.skipColumns },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig.GroupingTool,\n              \"skipColumns\",\n              $event.target.value\n            )\n          }\n        }\n      }),\n      _vm._v(\" \"),\n      _c(\n        \"select\",\n        {\n          directives: [\n            {\n              name: \"model\",\n              rawName: \"v-model\",\n              value: _vm.localConfig.GroupingTool.groupType,\n              expression: \"localConfig.GroupingTool.groupType\"\n            }\n          ],\n          on: {\n            change: function($event) {\n              var $$selectedVal = Array.prototype.filter\n                .call($event.target.options, function(o) {\n                  return o.selected\n                })\n                .map(function(o) {\n                  var val = \"_value\" in o ? o._value : o.value\n                  return val\n                })\n              _vm.$set(\n                _vm.localConfig.GroupingTool,\n                \"groupType\",\n                $event.target.multiple ? $$selectedVal : $$selectedVal[0]\n              )\n            }\n          }\n        },\n        [\n          _c(\"option\", { attrs: { value: \"group\" } }, [\n            _vm._v(_vm._s(_vm.$t(\"Group: \")))\n          ]),\n          _vm._v(\" \"),\n          _c(\"option\", { attrs: { value: \"member\" } }, [\n            _vm._v(_vm._s(_vm.$t(\"Member: \")))\n          ])\n        ]\n      ),\n      _vm._v(\" \"),\n      _c(\"input\", {\n        directives: [\n          {\n            name: \"model\",\n            rawName: \"v-model\",\n            value: _vm.localConfig.GroupingTool.groupLength,\n            expression: \"localConfig.GroupingTool.groupLength\"\n          }\n        ],\n        attrs: { type: \"number\", min: \"0\" },\n        domProps: { value: _vm.localConfig.GroupingTool.groupLength },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig.GroupingTool,\n              \"groupLength\",\n              $event.target.value\n            )\n          }\n        }\n      }),\n      _vm._v(\" \"),\n      _c(\n        \"button\",\n        {\n          staticClass: \"ui icon button basic\",\n          attrs: { type: \"button\" },\n          on: { click: _vm.removeLastColumn }\n        },\n        [_c(\"i\", { staticClass: \"undo icon\" })]\n      )\n    ])\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\nexport { render, staticRenderFns }","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../../node_modules/css-loader/dist/cjs.js?sourceMap!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/less-loader/dist/cjs.js??ref--1-2!./GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../../node_modules/vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"bf3ec7fe\", content, false, {});\n// Hot Module Replacement\nif(module.hot) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../../../node_modules/css-loader/dist/cjs.js?sourceMap!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/less-loader/dist/cjs.js??ref--1-2!./GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\", function() {\n     var newContent = require(\"!!../../../../node_modules/css-loader/dist/cjs.js?sourceMap!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/less-loader/dist/cjs.js??ref--1-2!./GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}","export * from \"-!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\"","import mod from \"-!./GroupingTool.js?vue&type=script&lang=js&\"; export default mod; export * from \"-!./GroupingTool.js?vue&type=script&lang=js&\"","import kmeans from './kmeans.js'\r\n\r\nlet GroupingTool = {\r\n  props: ['config', 'localConfig', 'utils'],\r\n  data () {    \r\n    this.$i18n.locale = this.localConfig.locale\r\n    return {\r\n    }\r\n  },\r\n  watch: {\r\n    'localConfig.locale'() {\r\n      this.$i18n.locale = this.localConfig.locale;\r\n    },\r\n  },\r\n  // computed: {\r\n    \r\n  // },\r\n  // mounted: async function () {\r\n  //   this.test202210301729()\r\n  // },\r\n  methods: {\r\n    test202210300033: async function () {\r\n\r\n      // var vector = [\r\n      //   [1, 10, 2, 30],\r\n      //   ['A', 30, 20, 2],\r\n      //   ['B', 30, 30, 3],\r\n      //   ['C', 30, 31, 3],\r\n      //   ['A', 10, 10, 1],\r\n      //   ['B', 20, 1, 30],\r\n      //   ['C', 1, 25, 30]\r\n      // ]\r\n\r\n      var vector = [\r\n        [10, 2, 30],\r\n        [30, 20, 2],\r\n        [30, 30, 3],\r\n        [30, 31, 3],\r\n        [10, 10, 1],\r\n        [20, 1, 30],\r\n        [1, 25, 30]\r\n      ]\r\n\r\n\r\n      // console.log(await this.toVector(vector))\r\n      // console.log(await this.addKmeans(vector))\r\n      // console.log(await this.addGroupInDifference(vector))\r\n      // console.log(await this.addGroupInSimilarity(vector))\r\n      // console.log(vector)\r\n      console.log(await this.kmeans(vector, 3))\r\n    },\r\n    test202210301729: async function () {\r\n\r\n      var vector = [\r\n        [1, 2, 3, 1],\r\n        [5,2,3,1],\r\n        [1,2,4,0],\r\n        [5,3,4,0]\r\n      ]\r\n\r\n\r\n      // console.log(await this.toVector(vector))\r\n      // console.log(await this.addKmeans(vector))\r\n      // console.log(vector)\r\n      // console.log(await this.kmeans(vector, 2))\r\n      // console.log(await this.groupingBySimilarity(vector, 'member', 2))\r\n      // console.log(await this.groupingByDifference(vector, 'member', 2))\r\n    },\r\n    toVector: async function(data) {\r\n      // console.log(data)\r\n\r\n\r\n      let rows = new Array(data.length)\r\n      let columeLength = data[0].length\r\n\r\n      for (let c = this.localConfig.GroupingTool.skipColumns; c < columeLength; c++) {\r\n        let list = []\r\n        let isColumnNumber = true\r\n\r\n        for (let d = 0; d < data.length; d++) {\r\n          let value = data[d][c]\r\n          let isNumber = (typeof(value) === 'number')\r\n          if (isNumber === false) {\r\n            isColumnNumber = false\r\n            break\r\n          }\r\n          else {\r\n            list.push(value)\r\n          }\r\n        }\r\n\r\n        // console.log(isColumnNumber)\r\n\r\n        if (isColumnNumber === true) {\r\n          let max = Math.max(...list)\r\n          let min = Math.min(...list)\r\n          let range = max - min\r\n          if (range === 0) {\r\n            continue\r\n          }\r\n\r\n          let normalized\r\n          if (max === 1 && min === 0) {\r\n            normalized = list\r\n          }\r\n          else {\r\n            normalized = list.map(value => ((value - min) / range))\r\n          }\r\n\r\n          for (let r = 0; r < rows.length; r++) {\r\n            if (!rows[r]) {\r\n              rows[r] = []\r\n            }\r\n\r\n            rows[r].push(normalized[r])\r\n          }\r\n        }\r\n        else {\r\n          let map = {}\r\n          \r\n          let id = 0\r\n          for (let d = 0; d < data.length; d++) {\r\n            let value = data[d][c]\r\n            value = value + ''\r\n            // console.log(value)\r\n            if (!map[value]) {\r\n              map[value] = id\r\n              id++\r\n            }\r\n            list.push(value)\r\n          }\r\n\r\n          // console.log(map, list)\r\n\r\n          let vectors = []\r\n          let v = []\r\n          let keys = Object.keys(map)\r\n          for (let i = 0; i < keys.length; i++) {\r\n            v[i] = 0\r\n          }\r\n          // console.log(v)\r\n\r\n          for (let d = 0; d < data.length; d++) {\r\n            let value = data[d][c]\r\n            value = value + ''\r\n            let i = keys.indexOf(value)\r\n            // console.log(i)\r\n            let v2 = [].concat(v)\r\n            v2[i] = 1\r\n            vectors.push(v2)\r\n          }\r\n          // console.log(vectors)\r\n\r\n          vectors.forEach((vector, r) => {\r\n            if (!rows[r]) {\r\n              rows[r] = []\r\n            }\r\n            rows[r] = rows[r].concat(vector)\r\n          })\r\n        }\r\n      }\r\n\r\n      // console.log(rows)\r\n\r\n      return rows\r\n    },\r\n    // kmeans: async function (data, cluster = 3) {\r\n    //   let vector = await this.toVector(data)\r\n    //   return new Promise(function (resolve, reject) {\r\n    //     // console.log(cluster)\r\n    //     kmeans(vector, cluster, function(err, clusterVector, clusterIndex, cluster, centroids) {\r\n    //       if (err) {\r\n    //         // throw new Error(err)\r\n    //         return reject(err)\r\n    //       }\r\n      \r\n    //       //do something with the result\r\n    //       // console.log(res)\r\n    //       resolve({\r\n    //         clusterVector,\r\n    //         clusterIndex,\r\n    //         cluster,\r\n    //         centroids\r\n    //       })\r\n    //     })\r\n    //   })\r\n    //   // console.log(vector) \r\n    // },\r\n    kmeans: async function (data, cluster = 3) {\r\n      let vector = await this.toVector(data)\r\n      // return new Promise(function (resolve, reject) {\r\n        // console.log(cluster)\r\n        // resovle(kmeans(vector, cluster))\r\n      // })\r\n      // console.log(vector) \r\n      let result = kmeans(vector, cluster)\r\n      // console.log(result)\r\n      return result\r\n    },\r\n    addKmeans: async function (vector, cluster = 3) {\r\n      let result = await this.kmeans(vector, cluster)\r\n\r\n      return vector.map((item, i) => {\r\n        // console.log(item, i, result.clusterIndex)\r\n        item.push(result.clusterVector[i])\r\n        return item\r\n      })\r\n    },\r\n    groupingByDifference: async function (vector, groupType = 'member', member = 3) {\r\n      member = Number(member)\r\n\r\n      let headerRows = []\r\n      if (this.localConfig.GroupingTool.skipRows > 0) {\r\n        headerRows = vector.slice(0, this.localConfig.GroupingTool.skipRows)\r\n        vector = vector.slice(this.localConfig.GroupingTool.skipRows)\r\n      }\r\n      \r\n      let {clusterIndex} = await this.kmeans(vector, member)\r\n\r\n      // 合併與計算比例\r\n      clusterIndex = this.balanceClusters(clusterIndex, Math.ceil(vector.length / member), Math.floor(vector.length / member))\r\n\r\n      // console.log(clusterIndex)\r\n      // return false\r\n\r\n      let groups = Math.ceil(vector.length / member)\r\n      \r\n      if (groupType === 'group') {\r\n        groups = member\r\n        member = Number(Math.floor(vector.length / groups))\r\n      }\r\n      // console.log(groups, member)\r\n      \r\n      let groupIndexList = []\r\n      let mod = vector.length % groups\r\n      let minMembers = Math.floor(vector.length / groups)\r\n      // return console.log(member, Math.floor(vector.length / groups))\r\n      // let minMembers = member\r\n\r\n      let counter = 0\r\n      // console.log(groups)\r\n      for (let i = 0; i < groups; i++) {\r\n        let group = []\r\n\r\n        let clusterI = 0\r\n        let baseMember = minMembers\r\n        if (i < mod) {\r\n          baseMember++\r\n        }\r\n\r\n        // console.log(baseMember)\r\n        // continue\r\n\r\n        while (true) {\r\n          let v = clusterIndex[(clusterI % clusterIndex.length)]\r\n          \r\n          // console.log(groups, clusterI, v, counter, vector.length) \r\n          if (v.length === 0) {\r\n            clusterI++\r\n            continue\r\n          }\r\n\r\n          let randomId = Math.floor(Math.random() * v.length)\r\n          let item = v[randomId]\r\n          group.push(Number(item))\r\n          // console.log(item)\r\n          \r\n          v.splice(randomId, 1)\r\n          // console.log(vector)\r\n          // clusterVector[(clusterI % member)] = v\r\n          // console.log(result.clusterVector)\r\n          // console.log(v)\r\n\r\n          clusterI++\r\n          counter++\r\n          // console.log(counter, group.length, member)\r\n          if (counter === vector.length) {\r\n            break\r\n          }\r\n\r\n          if (group.length === baseMember) {\r\n            break\r\n          }\r\n        }\r\n        // console.log(group)\r\n        groupIndexList.push(group)\r\n      }\r\n\r\n      // console.log(groupIndexList)\r\n\r\n      // let invertGroup = new Array(groups)\r\n      let output = [].concat(vector)\r\n      groupIndexList.forEach((list, groupId) => {\r\n        list.forEach(index => {\r\n          let o = [].concat(output[index])\r\n          o.push(groupId)\r\n          output[index] = o\r\n        })\r\n      })\r\n\r\n      output = headerRows.concat(output)\r\n\r\n      return output\r\n    },\r\n    balanceClusters (clusterIndex, maxMembers, minMembers) {\r\n      \r\n      // if (maxMembers === minMembers) {\r\n      //   minMembers--\r\n      // }\r\n      // return false\r\n      this.sortClusterIndexBySize(clusterIndex)\r\n      // console.log(JSON.stringify(clusterIndex, null, 2), maxMembers, minMembers)\r\n\r\n      while (clusterIndex[clusterIndex.length - 1].length === 0) {\r\n        let tempCluster = []\r\n        let largestCluster = clusterIndex[0]\r\n        while (tempCluster.length < minMembers) {\r\n          let randomId = Math.floor(Math.random() * largestCluster.length)\r\n          tempCluster.push(largestCluster[randomId])\r\n          largestCluster.splice(randomId, 1)\r\n          // console.log(tempCluster)\r\n        }\r\n        clusterIndex[0] = largestCluster\r\n        clusterIndex[(clusterIndex.length - 1)] = tempCluster\r\n\r\n        this.sortClusterIndexBySize(clusterIndex)\r\n      }\r\n\r\n      // console.log(clusterIndex)\r\n      let isValid = true\r\n      for (let i = 0; i < clusterIndex.length; i++) {\r\n        if (clusterIndex[i].length > maxMembers) {\r\n          isValid = 1\r\n          break\r\n        }\r\n        if (clusterIndex[i].length < minMembers) {\r\n          isValid = 2\r\n          break\r\n        }\r\n      }\r\n\r\n      \r\n      if (isValid === true) {\r\n        return clusterIndex\r\n      }\r\n      else if (isValid === 1) {\r\n        // 最小的，合併\r\n        let len = clusterIndex.length\r\n        let minCluster = clusterIndex[(len - 1)]\r\n        let baseIndex = (len - 2)\r\n        while (clusterIndex[baseIndex].length < maxMembers) {\r\n          let randomId = Math.floor(Math.random() * minCluster.length)\r\n          clusterIndex[baseIndex].push(minCluster[randomId])\r\n          minCluster.splice(randomId, 1)\r\n          // console.log(tempCluster)\r\n\r\n          if (minCluster.length === 0) {\r\n            break\r\n          }\r\n          if (clusterIndex[baseIndex].length === maxMembers && \r\n              minCluster.length > 0) {\r\n            baseIndex--\r\n          }\r\n\r\n          if (baseIndex === -1) {\r\n            break\r\n          }\r\n        }\r\n        \r\n        // clusterIndex[(len - 2)] = clusterIndex[(len - 2)].concat(clusterIndex[(len - 1)])\r\n\r\n        // 最大的，拆一半\r\n        let tempCluster = [].concat(minCluster)\r\n        let largestCluster = clusterIndex[0]\r\n        while (tempCluster.length < minMembers) {\r\n          let randomId = Math.floor(Math.random() * largestCluster.length)\r\n          tempCluster.push(largestCluster[randomId])\r\n          largestCluster.splice(randomId, 1)\r\n          // console.log(tempCluster)\r\n        }\r\n        clusterIndex[0] = largestCluster\r\n        clusterIndex[(len - 1)] = tempCluster\r\n\r\n        // console.log(clusterIndex)\r\n        // return false\r\n        return this.balanceClusters(clusterIndex, maxMembers, minMembers)\r\n      }\r\n      else {\r\n        // 最小的，合併\r\n        let len = clusterIndex.length\r\n        let maxCluster = clusterIndex[0]\r\n        let randomId = Math.floor(Math.random() * maxCluster.length)\r\n        clusterIndex[(len - 1)].push(maxCluster[randomId])\r\n        maxCluster.splice(randomId, 1)\r\n        clusterIndex[0] = maxCluster\r\n        // let baseIndex = (len - 2)\r\n        // while (clusterIndex[baseIndex].length < maxMembers) {\r\n        //   let randomId = Math.floor(Math.random() * minCluster.length)\r\n        //   clusterIndex[baseIndex].push(minCluster[randomId])\r\n        //   minCluster.splice(randomId, 1)\r\n        //   // console.log(tempCluster)\r\n\r\n        //   if (minCluster.length === 0) {\r\n        //     break\r\n        //   }\r\n        //   if (clusterIndex[baseIndex].length === maxMembers && \r\n        //       minCluster.length > 0) {\r\n        //     baseIndex--\r\n        //   }\r\n        // }\r\n        \r\n        // // clusterIndex[(len - 2)] = clusterIndex[(len - 2)].concat(clusterIndex[(len - 1)])\r\n\r\n        // // 最大的，拆一半\r\n        // let tempCluster = []\r\n        // let largestCluster = clusterIndex[0]\r\n        // while (tempCluster.length < minMembers) {\r\n        //   let randomId = Math.floor(Math.random() * largestCluster.length)\r\n        //   tempCluster.push(largestCluster[randomId])\r\n        //   largestCluster.splice(randomId, 1)\r\n        //   // console.log(tempCluster)\r\n        // }\r\n        // clusterIndex[0] = largestCluster\r\n        // clusterIndex[(len - 1)] = tempCluster\r\n\r\n        // // console.log(clusterIndex)\r\n        // return false\r\n        return this.balanceClusters(clusterIndex, maxMembers, minMembers)\r\n      }\r\n    },\r\n    groupingBySimilarity: async function (vector, groupType = 'member', member = 3) {\r\n      member = Number(member)\r\n\r\n      let headerRows = []\r\n      if (this.localConfig.GroupingTool.skipRows > 0) {\r\n        headerRows = vector.slice(0, this.localConfig.GroupingTool.skipRows)\r\n        vector = vector.slice(this.localConfig.GroupingTool.skipRows)\r\n      }\r\n\r\n      let groups = Math.ceil(vector.length / member)\r\n\r\n      if (groupType === 'group') {\r\n        groups = member\r\n        member = Math.ceil(vector.length / groups)\r\n      }\r\n\r\n      // console.log(groups, member)\r\n\r\n      let {clusterIndex} = await this.kmeans(vector, groups)\r\n      // console.log(clusterIndex) \r\n      this.sortClusterIndexBySize(clusterIndex)\r\n      while (true) {\r\n        let isFinish = true\r\n        \r\n        for (let i = 0; i < clusterIndex.length; i++) {\r\n          let list = clusterIndex[i]\r\n          if (list.length <= member && list.length >= member - 1) {\r\n            continue\r\n          }\r\n\r\n          isFinish = false\r\n\r\n          if (list.length > member) {\r\n            let randomId = Math.floor(Math.random() * list.length)\r\n            clusterIndex[(clusterIndex.length - 1)].push(list[randomId])\r\n            list.splice(randomId, 1)\r\n          }\r\n          else {\r\n            let randomId = Math.floor(Math.random() * clusterIndex[0].length)\r\n            clusterIndex[i].push(clusterIndex[0][randomId])\r\n            clusterIndex[0].splice(randomId, 1)\r\n          }\r\n            \r\n\r\n          this.sortClusterIndexBySize(clusterIndex)\r\n          break\r\n        }\r\n\r\n\r\n        if (isFinish) {\r\n          break\r\n        }\r\n        \r\n      }\r\n\r\n      Object.keys(clusterIndex).forEach(groupId => {\r\n        clusterIndex[groupId].forEach(i => {\r\n          vector[i].push(Number(groupId))\r\n        })\r\n      })\r\n\r\n      vector = headerRows.concat(vector)\r\n\r\n      return vector\r\n    },\r\n    sortClusterIndexBySize (clusterIndex) {\r\n      clusterIndex.sort((a, b) => {\r\n        return b.length - a.length\r\n      })\r\n    },\r\n    removeLastColumn () {\r\n      let data = this.$parent.dataMatrix\r\n      let headerRows = []\r\n      if (this.localConfig.GroupingTool.skipRows > 0) {\r\n        headerRows = data.slice(0, this.localConfig.GroupingTool.skipRows)\r\n        data = data.slice(this.localConfig.GroupingTool.skipRows)\r\n      }\r\n      // console.log(data)\r\n      data = data.map(row => row.slice(0, row.length - 1))\r\n      data = headerRows.concat(data)\r\n      // console.log(data)\r\n      this.localConfig.textContent = data.map(line => line.join('\\t')).join('\\n')\r\n    }\r\n  }\r\n}\r\n\r\nexport default GroupingTool","import mod from \"-!../../../../node_modules/vue-style-loader/index.js!../../../../node_modules/css-loader/dist/cjs.js?sourceMap!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/less-loader/dist/cjs.js??ref--1-2!./GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\"; export default mod; export * from \"-!../../../../node_modules/vue-style-loader/index.js!../../../../node_modules/css-loader/dist/cjs.js?sourceMap!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/less-loader/dist/cjs.js??ref--1-2!./GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\"","import { render, staticRenderFns } from \"./GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\"\nimport script from \"./GroupingTool.js?vue&type=script&lang=js&\"\nexport * from \"./GroupingTool.js?vue&type=script&lang=js&\"\nimport style0 from \"./GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"1d066bc0\",\n  null\n  \n)\n\n/* custom blocks */\nimport block0 from \"./GroupingTool.yaml?vue&type=custom&index=0&blockType=i18n&issuerPath=%2Fapp%2Fsrc%2Fcomponents%2FReplacePanel%2FGroupingTool%2FGroupingTool.vue&lang=yaml\"\nif (typeof block0 === 'function') block0(component)\n\n/* hot reload */\nif (module.hot) {\n  var api = require(\"/app/node_modules/vue-hot-reload-api/dist/index.js\")\n  api.install(require('vue'))\n  if (api.compatible) {\n    module.hot.accept()\n    if (!api.isRecorded('1d066bc0')) {\n      api.createRecord('1d066bc0', component.options)\n    } else {\n      api.reload('1d066bc0', component.options)\n    }\n    module.hot.accept(\"./GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\", function () {\n      api.rerender('1d066bc0', {\n        render: render,\n        staticRenderFns: staticRenderFns\n      })\n    })\n  }\n}\ncomponent.options.__file = \"src/components/ReplacePanel/GroupingTool/GroupingTool.vue\"\nexport default component.exports","import mod from \"-!../../../../node_modules/@kazupon/vue-i18n-loader/lib/index.js!./GroupingTool.yaml?vue&type=custom&index=0&blockType=i18n&issuerPath=%2Fapp%2Fsrc%2Fcomponents%2FReplacePanel%2FGroupingTool%2FGroupingTool.vue&lang=yaml\"; export default mod; export * from \"-!../../../../node_modules/@kazupon/vue-i18n-loader/lib/index.js!./GroupingTool.yaml?vue&type=custom&index=0&blockType=i18n&issuerPath=%2Fapp%2Fsrc%2Fcomponents%2FReplacePanel%2FGroupingTool%2FGroupingTool.vue&lang=yaml\"","const MAX_ITERATIONS = 50;\n\nfunction randomBetween(min, max) {\n  return Math.floor(\n    Math.random() * (max - min) + min\n  );\n}\n\nfunction calcMeanCentroid(dataSet, start, end) {\n  const features = dataSet[0].length;\n  const n = end - start;\n  let mean = [];\n  for (let i = 0; i < features; i++) {\n    mean.push(0);\n  }\n  for (let i = start; i < end; i++) {\n    for (let j = 0; j < features; j++) {\n      mean[j] = mean[j] + dataSet[i][j] / n;\n    }\n  }\n  return mean;\n}\n\nfunction getRandomCentroidsNaiveSharding(dataset, k) {\n  // implementation of a variation of naive sharding centroid initialization method\n  // (not using sums or sorting, just dividing into k shards and calc mean)\n  // https://www.kdnuggets.com/2017/03/naive-sharding-centroid-initialization-method.html\n  const numSamples = dataset.length;\n  // Divide dataset into k shards:\n  const step = Math.floor(numSamples / k);\n  // console.log(step);\n  const centroids = [];\n  for (let i = 0; i < k; i++) {\n    const start = step * i;\n    let end = step * (i + 1);\n    if (i + 1 === k) {\n      end = numSamples;\n    }\n    // console.log(start, end);\n    centroids.push(calcMeanCentroid(dataset, start, end));\n  }\n  return centroids;\n}\n\nfunction getRandomCentroids(dataset, k) {\n  // selects random points as centroids from the dataset\n  const numSamples = dataset.length;\n  const centroidsIndex = [];\n  let index;\n  while (centroidsIndex.length < k) {\n    index = randomBetween(0, numSamples);\n    if (centroidsIndex.indexOf(index) === -1) {\n      centroidsIndex.push(index);\n    }\n  }\n  const centroids = [];\n  for (let i = 0; i < centroidsIndex.length; i++) {\n    const centroid = [].concat(dataset[centroidsIndex[i]]);\n    centroids.push(centroid);\n  }\n  return centroids;\n}\n\nfunction compareCentroids(a, b) {\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction shouldStop(oldCentroids, centroids, iterations) {\n  if (iterations > MAX_ITERATIONS) {\n    return true;\n  }\n  if (!oldCentroids || !oldCentroids.length) {\n    return false;\n  }\n  let sameCount = true;\n  for (let i = 0; i < centroids.length; i++) {\n    if (!compareCentroids(centroids[i], oldCentroids[i])) {\n      sameCount = false;\n    }\n  }\n  return sameCount;\n}\n\n// Calculate Squared Euclidean Distance\nfunction getDistanceSQ(a, b) {\n  const diffs = [];\n  for (let i = 0; i < a.length; i++) {\n    diffs.push(a[i] - b[i]);\n  }\n  return diffs.reduce((r, e) => (r + (e * e)), 0);\n}\n\n// Returns a label for each piece of data in the dataset. \nfunction getLabels(dataSet, centroids) {\n  // prep data structure:\n  const labels = {};\n  for (let c = 0; c < centroids.length; c++) {\n    labels[c] = {\n      points: [],\n      centroid: centroids[c],\n      indexes: []\n    };\n  }\n  // For each element in the dataset, choose the closest centroid. \n  // Make that centroid the element's label.\n  for (let i = 0; i < dataSet.length; i++) {\n    const a = dataSet[i];\n    let closestCentroid, closestCentroidIndex, prevDistance;\n    for (let j = 0; j < centroids.length; j++) {\n      let centroid = centroids[j];\n      if (j === 0) {\n        closestCentroid = centroid;\n        closestCentroidIndex = j;\n        prevDistance = getDistanceSQ(a, closestCentroid);\n      } else {\n        // get distance:\n        const distance = getDistanceSQ(a, centroid);\n        if (distance < prevDistance) {\n          prevDistance = distance;\n          closestCentroid = centroid;\n          closestCentroidIndex = j;\n        }\n      }\n    }\n    // add point to centroid labels:\n    labels[closestCentroidIndex].points.push(a);\n    labels[closestCentroidIndex].indexes.push(i);\n  }\n  return labels;\n}\n\nfunction getPointsMean(pointList) {\n  const totalPoints = pointList.length;\n  const means = [];\n  for (let j = 0; j < pointList[0].length; j++) {\n    means.push(0);\n  }\n  for (let i = 0; i < pointList.length; i++) {\n    const point = pointList[i];\n    for (let j = 0; j < point.length; j++) {\n      const val = point[j];\n      means[j] = means[j] + val / totalPoints;\n    }\n  }\n  return means;\n}\n\nfunction recalculateCentroids(dataSet, labels, k) {\n  // Each centroid is the geometric mean of the points that\n  // have that centroid's label. Important: If a centroid is empty (no points have\n  // that centroid's label) you should randomly re-initialize it.\n  let newCentroid;\n  const newCentroidList = [];\n  for (const k in labels) {\n    const centroidGroup = labels[k];\n    if (centroidGroup.points.length > 0) {\n      // find mean:\n      newCentroid = getPointsMean(centroidGroup.points);\n    } else {\n      // get new random centroid\n      newCentroid = getRandomCentroids(dataSet, 1)[0];\n    }\n    newCentroidList.push(newCentroid);\n  }\n  return newCentroidList;\n}\n\nfunction kmeans(dataset, k, useNaiveSharding = 'auto') {\n  if (useNaiveSharding === 'auto') {\n    useNaiveSharding = (dataset.length / k > 4)\n  }\n  useNaiveSharding = false\n    //   console.log(dataset)\n  if (dataset.length && dataset[0].length && dataset.length > k) {\n    // Initialize book keeping variables\n    let iterations = 0;\n    let oldCentroids, labels, centroids;\n\n    // Initialize centroids randomly\n    if (useNaiveSharding) {\n      centroids = getRandomCentroidsNaiveSharding(dataset, k);\n    } else {\n      centroids = getRandomCentroids(dataset, k);\n    }\n    // console.log(centroids)\n\n    // Run the main k-means algorithm\n    while (!shouldStop(oldCentroids, centroids, iterations)) {\n      // Save old centroids for convergence test.\n      oldCentroids = [].concat(centroids);\n      iterations++;\n\n      // Assign labels to each datapoint based on centroids\n      labels = getLabels(dataset, centroids);\n      // console.log(oldCentroids)\n      centroids = recalculateCentroids(dataset, labels, k);\n      // console.log(centroids)\n    }\n\n    const clusters = [];\n    let datasetLabels = new Array(dataset.length)\n    for (let i = 0; i < k; i++) {\n      clusters.push(labels[i].indexes);\n      labels[i].indexes.forEach(datasetIndex => {\n        datasetLabels[datasetIndex] = i\n      })\n    }\n    \n    const results = {\n      datasetLabels,\n      clusterVector: datasetLabels,\n      clusters: clusters,\n      clusterIndex: clusters,\n      centroids: centroids,\n      iterations: iterations,\n      converged: iterations <= MAX_ITERATIONS,\n    };\n    return results;\n  } else {\n    throw new Error('Invalid dataset');\n  }\n}\n\nexport default kmeans;"],"sourceRoot":""}