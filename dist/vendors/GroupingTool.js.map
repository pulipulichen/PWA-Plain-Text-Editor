{"version":3,"sources":["webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.yaml","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.less","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.html?9eb3","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.less?c5e4","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.html","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.js?5ca6","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.js","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.less?c42f","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.vue","webpack:///./src/components/ReplacePanel/GroupingTool/GroupingTool.yaml?3aad","webpack:///./src/components/ReplacePanel/GroupingTool/kmeans.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA,kCAAkC,SAAS,kBAAkB,UAAU,eAAe;AACtF;AACA;;;;;;;;;;;;ACJA,2BAA2B,mBAAO,CAAC,8GAAyD;AAC5F;AACA,cAAc,QAAS,2BAA2B,2BAA2B,GAAG,SAAS,oMAAoM,WAAW,qHAAqH,2BAA2B,GAAG,UAAU,2BAA2B,GAAG,KAAK;;;;;;;;;;;;;ACFxe;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD,eAAe,8BAA8B;AAC7C,mBAAmB,SAAS,6BAA6B,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,mBAAmB,8CAA8C;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtCA;;AAEA;AACA,cAAc,mBAAO,CAAC,uhBAAyQ;AAC/R,4CAA4C,QAAS;AACrD;AACA;AACA,UAAU,mBAAO,CAAC,gIAAmE;AACrF,+CAA+C;AAC/C;AACA,GAAG,KAAU,EAAE,E;;;;;;;;;;;;ACVf;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;ACAA;AAAA;AAAA,wCAA+D,CAAgB,gJAAG,EAAC,C;;;;;;;;;;;;ACAnF;AAAA;AAAgC;;AAEhC;AACA;AACA,W;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ,0DAAM;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,OAAO;AACP,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,YAAY;AACjC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA,KAAK;AACL;;AAEA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;;AAEA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEe,2E;;;;;;;;;;;;ACpRf;AAAA;AAAA;AAAA;AAA6U,CAAgB,2WAAG,EAAC,C;;;;;;;;;;;;ACAjW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwG;AACzC;AACL;AACwC;;;AAGlG;AACgG;AAChG,gBAAgB,2GAAU;AAC1B,EAAE,iFAAM;AACR,EAAE,oGAAM;AACR,EAAE,6GAAe;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AAC+K;AAC/K,WAAW,gMAAM,iBAAiB,wMAAM;;AAExC;AACA,IAAI,KAAU,EAAE,YAiBf;AACD;AACe,gF;;;;;;;;;;;;AC3Cf;AAAA;AAAA;AAAA;AAA8O,CAAgB,gTAAG,EAAC,C;;;;;;;;;;;;;;ACClQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,UAAU;;AAE3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACe,8F;AACf;AACA;;AAEA;AACA,CAAC","file":"vendors/GroupingTool.js","sourcesContent":["module.exports = function (Component) {\n  Component.options.__i18n = Component.options.__i18n || []\n  Component.options.__i18n.push('{\"en-US\":{\"Search\":\"Search\"},\"zh-TW\":{\"Search\":\"搜尋\"}}')\n  delete Component.options._Ctor\n}\n","exports = module.exports = require(\"../../../../node_modules/css-loader/dist/runtime/api.js\")(true);\n// Module\nexports.push([module.id, \"input[data-v-1d066bc0] {\\n  width: 4rem !important;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"/app/src/components/ReplacePanel/GroupingTool/GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\",\"GroupingTool.less\"],\"names\":[],\"mappings\":\"AAAA;EACE,sBAAA;ACCF\",\"file\":\"GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\",\"sourcesContent\":[\"input {\\n  width: 4rem !important;\\n}\",\"input {\\n  width: 4rem !important;\\n}\\n\"]}]);\n","var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", { staticClass: \"GroupingTool\" }, [\n    _c(\"div\", { staticClass: \"inline field\" }, [\n      _c(\"label\", { attrs: { for: \"GroupingToolMembers\" } }, [\n        _vm._v(\"\\n      \" + _vm._s(_vm.$t(\"Members:\")) + \"\\n    \")\n      ]),\n      _vm._v(\" \"),\n      _c(\"input\", {\n        directives: [\n          {\n            name: \"model\",\n            rawName: \"v-model\",\n            value: _vm.localConfig.GroupingTool.members,\n            expression: \"localConfig.GroupingTool.members\"\n          }\n        ],\n        attrs: { type: \"number\" },\n        domProps: { value: _vm.localConfig.GroupingTool.members },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig.GroupingTool,\n              \"members\",\n              $event.target.value\n            )\n          }\n        }\n      })\n    ])\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\nexport { render, staticRenderFns }","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../../node_modules/css-loader/dist/cjs.js?sourceMap!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/less-loader/dist/cjs.js??ref--1-2!./GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar add = require(\"!../../../../node_modules/vue-style-loader/lib/addStylesClient.js\").default\nvar update = add(\"bf3ec7fe\", content, false, {});\n// Hot Module Replacement\nif(module.hot) {\n // When the styles change, update the <style> tags\n if(!content.locals) {\n   module.hot.accept(\"!!../../../../node_modules/css-loader/dist/cjs.js?sourceMap!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/less-loader/dist/cjs.js??ref--1-2!./GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\", function() {\n     var newContent = require(\"!!../../../../node_modules/css-loader/dist/cjs.js?sourceMap!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/less-loader/dist/cjs.js??ref--1-2!./GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\");\n     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n     update(newContent);\n   });\n }\n // When the module is disposed, remove the <style> tags\n module.hot.dispose(function() { update(); });\n}","export * from \"-!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\"","import mod from \"-!./GroupingTool.js?vue&type=script&lang=js&\"; export default mod; export * from \"-!./GroupingTool.js?vue&type=script&lang=js&\"","import kmeans from './kmeans.js'\r\n\r\nlet GroupingTool = {\r\n  props: ['config', 'localConfig', 'utils'],\r\n  data () {    \r\n    this.$i18n.locale = this.localConfig.locale\r\n    return {\r\n    }\r\n  },\r\n  watch: {\r\n    'localConfig.locale'() {\r\n      this.$i18n.locale = this.localConfig.locale;\r\n    },\r\n  },\r\n  // computed: {\r\n    \r\n  // },\r\n  // mounted: async function () {\r\n  // },\r\n  methods: {\r\n    test202210300033: async function () {\r\n\r\n      var vector = [\r\n        [1, 10, 2, 30],\r\n        ['A', 30, 20, 2],\r\n        ['B', 30, 30, 3],\r\n        ['C', 30, 31, 3],\r\n        ['A', 10, 10, 1],\r\n        ['B', 20, 1, 30],\r\n        ['C', 1, 25, 30]\r\n      ]\r\n      // console.log(await this.toVector(vector))\r\n      console.log(await this.addKmeans(vector))\r\n      console.log(await this.addGroupInDifference(vector))\r\n      console.log(await this.addGroupInSimilarity(vector))\r\n\r\n    },\r\n    toVector: async function(data) {\r\n      let rows = new Array(data.length)\r\n      let columeLength = data[0].length\r\n\r\n      for (let c = 0; c < columeLength; c++) {\r\n        let list = []\r\n        let isColumnNumber = true\r\n\r\n        for (let d = 0; d < data.length; d++) {\r\n          let value = data[d][c]\r\n          let isNumber = (typeof(value) === 'number')\r\n          if (isNumber === false) {\r\n            isColumnNumber = false\r\n            break\r\n          }\r\n          else {\r\n            list.push(value)\r\n          }\r\n        }\r\n\r\n        // console.log(isColumnNumber)\r\n\r\n        if (isColumnNumber === true) {\r\n          let max = Math.max(...list)\r\n          let min = Math.min(...list)\r\n          let range = max - min\r\n          if (range === 0) {\r\n            continue\r\n          }\r\n\r\n          let normalized\r\n          if (max === 1 && min === 0) {\r\n            normalized = list.map(value => ((value - min) / range))\r\n          }\r\n          else {\r\n            normalized = list\r\n          }\r\n\r\n          for (let r = 0; r < rows.length; r++) {\r\n            if (!rows[r]) {\r\n              rows[r] = []\r\n            }\r\n\r\n            rows[r].push(normalized[r])\r\n          }\r\n        }\r\n        else {\r\n          let map = {}\r\n          \r\n          let id = 0\r\n          for (let d = 0; d < data.length; d++) {\r\n            let value = data[d][c]\r\n            value = value + ''\r\n            // console.log(value)\r\n            if (!map[value]) {\r\n              map[value] = id\r\n              id++\r\n            }\r\n            list.push(value)\r\n          }\r\n\r\n          // console.log(map, list)\r\n\r\n          let vectors = []\r\n          let v = []\r\n          for (let i = 0; i < Object.keys(map).length; i++) {\r\n            v[i] = 0\r\n          }\r\n          // console.log(v)\r\n          for (let d = 0; d < data.length; d++) {\r\n            let value = data[d][c]\r\n            value = value + ''\r\n            let i = map[value]\r\n            // console.log(i)\r\n            let v2 = [].concat(v)\r\n            v2[i] = 1\r\n            vectors.push(v2)\r\n          }\r\n          // console.log(vectors)\r\n\r\n          vectors.forEach((vector, r) => {\r\n            if (!rows[r]) {\r\n              rows[r] = []\r\n            }\r\n            rows[r] = rows[r].concat(vector)\r\n          })\r\n        }\r\n      }\r\n\r\n      return rows\r\n    },\r\n    kmeans: async function (data, cluster = 3) {\r\n      let vector = await this.toVector(data)\r\n      return new Promise(function (resolve, reject) {\r\n        kmeans(vector, cluster, function(err, clusterVector, clusterIndex, cluster, centroids) {\r\n          if (err) {\r\n            // throw new Error(err)\r\n            return reject(err)\r\n          }\r\n      \r\n          //do something with the result\r\n          // console.log(res)\r\n          resolve({\r\n            clusterVector,\r\n            clusterIndex,\r\n            cluster,\r\n            centroids\r\n          })\r\n      })\r\n      })\r\n      // console.log(vector) \r\n    },\r\n    addKmeans: async function (vector, cluster = 3) {\r\n      let result = await this.kmeans(vector, cluster)\r\n\r\n      return vector.map((item, i) => {\r\n        // console.log(item, i, result.clusterIndex)\r\n        item.push(result.clusterVector[i])\r\n        return item\r\n      })\r\n    },\r\n    groupingByDifference: async function (vector, member = 3) {\r\n      let result = await this.kmeans(vector, member)\r\n      // console.log(result)\r\n\r\n      let groups = Math.ceil(vector.length / member)\r\n      let minMembers = Math.floor(vector.length / member)\r\n      let mod = vector.length % member\r\n      let groupIndexList = []\r\n\r\n      let counter = 0\r\n      // console.log(groups)\r\n      for (let i = 0; i < groups; i++) {\r\n        let group = []\r\n\r\n        let clusterI = 0\r\n        let baseMember = minMembers\r\n        if (i < mod) {\r\n          baseMember++\r\n        }\r\n\r\n        while (true) {\r\n          let v = result.clusterIndex[(clusterI % member)]\r\n          \r\n          // console.log(v, counter, vector.length) \r\n          if (v.length === 0) {\r\n            clusterI++\r\n            continue\r\n          }\r\n\r\n          let randomId = Math.floor(Math.random() * v.length)\r\n          let item = v[randomId]\r\n          group.push(Number(item))\r\n          // console.log(item)\r\n          \r\n          v.splice(randomId, 1)\r\n          // console.log(vector)\r\n          // clusterVector[(clusterI % member)] = v\r\n          // console.log(result.clusterVector)\r\n          // console.log(v)\r\n\r\n          clusterI++\r\n          counter++\r\n          // console.log(counter, group.length, member)\r\n          if (counter === vector.length) {\r\n            break\r\n          }\r\n\r\n          if (group.length === baseMember) {\r\n            break\r\n          }\r\n        }\r\n        // console.log(group)\r\n        groupIndexList.push(group)\r\n      }\r\n\r\n      // console.log(groupIndexList)\r\n\r\n      // let invertGroup = new Array(groups)\r\n      let output = [].concat(vector)\r\n      groupIndexList.forEach((list, groupId) => {\r\n        list.forEach(index => {\r\n          let o = [].concat(output[index])\r\n          o.push(groupId)\r\n          output[index] = o\r\n        })\r\n      })\r\n\r\n      return output\r\n    },\r\n    groupingBySimilarity: async function (vector, member = 3) {\r\n      \r\n      let groups = Math.ceil(vector.length / member)\r\n      let {clusterIndex} = await this.kmeans(vector, groups)\r\n      console.log(clusterIndex)\r\n      this.sortClusterIndexBySize(clusterIndex)\r\n      while (true) {\r\n        let isFinish = true\r\n        \r\n        for (let i = 0; i < clusterIndex.length; i++) {\r\n          let list = clusterIndex[i]\r\n          if (list.length <= member) {\r\n            continue\r\n          }\r\n\r\n          isFinish = false\r\n\r\n          \r\n          let randomId = Math.floor(Math.random() * list.length)\r\n          clusterIndex[(clusterIndex.length - 1)].push(list[randomId])\r\n          list.splice(randomId, 1)\r\n\r\n          this.sortClusterIndexBySize(clusterIndex)\r\n          break\r\n        }\r\n\r\n\r\n        if (isFinish) {\r\n          break\r\n        }\r\n        \r\n      }\r\n\r\n      Object.keys(clusterIndex).forEach(groupId => {\r\n        clusterIndex[groupId].forEach(i => {\r\n          vector[i].push(Number(groupId))\r\n        })\r\n      })\r\n\r\n      return vector\r\n    },\r\n    sortClusterIndexBySize (clusterIndex) {\r\n      clusterIndex.sort((a, b) => {\r\n        return b.length - a.length\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nexport default GroupingTool","import mod from \"-!../../../../node_modules/vue-style-loader/index.js!../../../../node_modules/css-loader/dist/cjs.js?sourceMap!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/less-loader/dist/cjs.js??ref--1-2!./GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\"; export default mod; export * from \"-!../../../../node_modules/vue-style-loader/index.js!../../../../node_modules/css-loader/dist/cjs.js?sourceMap!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/less-loader/dist/cjs.js??ref--1-2!./GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\"","import { render, staticRenderFns } from \"./GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\"\nimport script from \"./GroupingTool.js?vue&type=script&lang=js&\"\nexport * from \"./GroupingTool.js?vue&type=script&lang=js&\"\nimport style0 from \"./GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"1d066bc0\",\n  null\n  \n)\n\n/* custom blocks */\nimport block0 from \"./GroupingTool.yaml?vue&type=custom&index=0&blockType=i18n&issuerPath=%2Fapp%2Fsrc%2Fcomponents%2FReplacePanel%2FGroupingTool%2FGroupingTool.vue&lang=yaml\"\nif (typeof block0 === 'function') block0(component)\n\n/* hot reload */\nif (module.hot) {\n  var api = require(\"/app/node_modules/vue-hot-reload-api/dist/index.js\")\n  api.install(require('vue'))\n  if (api.compatible) {\n    module.hot.accept()\n    if (!api.isRecorded('1d066bc0')) {\n      api.createRecord('1d066bc0', component.options)\n    } else {\n      api.reload('1d066bc0', component.options)\n    }\n    module.hot.accept(\"./GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\", function () {\n      api.rerender('1d066bc0', {\n        render: render,\n        staticRenderFns: staticRenderFns\n      })\n    })\n  }\n}\ncomponent.options.__file = \"src/components/ReplacePanel/GroupingTool/GroupingTool.vue\"\nexport default component.exports","import mod from \"-!../../../../node_modules/@kazupon/vue-i18n-loader/lib/index.js!./GroupingTool.yaml?vue&type=custom&index=0&blockType=i18n&issuerPath=%2Fapp%2Fsrc%2Fcomponents%2FReplacePanel%2FGroupingTool%2FGroupingTool.vue&lang=yaml\"; export default mod; export * from \"-!../../../../node_modules/@kazupon/vue-i18n-loader/lib/index.js!./GroupingTool.yaml?vue&type=custom&index=0&blockType=i18n&issuerPath=%2Fapp%2Fsrc%2Fcomponents%2FReplacePanel%2FGroupingTool%2FGroupingTool.vue&lang=yaml\"","\n// Initialize\n// ----------\nfunction Kmeans (vector, k, callback) {\n    //**Vector:** array of arrays. Inner array\n    //represents a multidimensional data point (vector)  \n    //*These should be normalized*\n    this.callback = callback\n    this.vector = vector \n    //**K:** represents the number of groups/clusters into \n    //which the vectors will be grouped\n    this.k = k\n    //Initialize the centroids and clusters     \n    //**Centroids:** represent the center of each cluster. \n    //They are taken by averaging each dimension of the vectors\n    this.centroids = new Array(k)\n    this.cluster = new Array(k) \n    this.clusterIndex = new Array(this.vector.length) \n    // console.log(this.cluster)\n    //Create centroids and place them randomly because \n    //we don't yet know where the vectors are most concentrated\n    this.createCentroids()\n    var count = 0\n        , notFinished = true\n    \n    this.iterate(this.centroids.slice(0))\n}\n\n// Assign vector to each centroid\n// ----------\n// Randomly choose **k** vectors from the vector \n// array **vector**. These represent our guess \n// at where clusters may exist. \nKmeans.prototype.createCentroids = function () {\n    var randomArray = this.vector.slice(0)\n    var self = this\n    randomArray.sort(function() {\n        return (Math.floor(Math.random() * self.vector.length))\n    });\n    this.centroids = randomArray.slice(0, this.k);\n}\n\n// Recursively cluster and move the centroids\n// ----------\n//This method groups vectors into clusters and then determine the \n//the new location for each centroid based upon the mean\n//location of the vectors in the cooresponding cluster\nKmeans.prototype.iterate = function (vecArray) {\n   \n    this.cluster = new Array(this.k)\n    this.clusterIndex = new Array(this.k)\n    this.clusterVector = new Array(vecArray.length)\n    // console.log(this.cluster)\n    var tempArray = []    \n    for (var a=0; a<this.vector[0].length; a++) {\n        tempArray.push(0)\n    }\n    var vecArray = []\n    for (var a=0; a<this.k; a++) {\n        vecArray[a] = (tempArray.slice(0))\n    }\n    //Group each vector to a cluster based upon the \n    //cooresponding centroid\n    // console.log(vecArray)\n    for (let i in this.vector) {\n        var v = this.vector[i].slice(0)\n        // console.log(v)\n        var index = this.assignCentroid(v)\n        // console.log(index)\n        if (!this.cluster[index]) {\n            this.cluster[index]=[]\n            this.clusterIndex[index]=[]\n        }\n\n        this.cluster[index].push(v)\n        this.clusterIndex[index].push(i)\n        this.clusterVector[i] = Number(index)\n\n        for (var a=0; a<v.length; a++){\n            vecArray[index][a]+=v[a] //keep a sum for cluster\n        }\n    }\n    // console.log(vecArray)\n    //Calculate the mean values for each cluster.\n    var distance, max = 0 \n   \n    for (var a=0; a<this.k; a++) {\n        \n        var clusterSize = 0 //cluster is empty\n        if (this.cluster[a]) clusterSize = this.cluster[a].length\n        \n        for (let b in vecArray[a]) {\n            vecArray[a][b] = vecArray[a][b]/clusterSize\n        }\n        distance = this.distance(vecArray[a], this.centroids[a])\n        if (distance>max) \n            max=distance\n    }\n    // console.log(this.cluster)\n    if (max<=0.5) {\n        // console.log(this.cluster)\n        return this.callback(null, this.clusterVector, this.clusterIndex, this.cluster, this.centroids)\n    }\n\n    //For each centroid use the mean calculated for the \n    //corresponding cluster (effectively \"moving\" the centroid\n    //to its new \"location\")\n    for (let z in vecArray) {\n        this.centroids[z] = vecArray[z].slice(0)\n    }\n    this.iterate(vecArray)\n\n}\n\n\n// Determine the closest centroid to a vector\n// ----------\nKmeans.prototype.assignCentroid = function (point) {\n    var min = Infinity, res = 0\n\n    //For each vector we determine the distance to the \n    //nearest centroid. The vector is assigned to the \n    //cluster that corresponds to the nearest centroid.\n    for (let i in this.centroids) {\n        let dist = this.distance(point, this.centroids[i])\n        if (dist < min) {\n            min = dist\n            res = i       \n        }\n    }\n    return Number(res)\n}\n\n// Calculate euclidian distance between vectors\n// ----------\nKmeans.prototype.distance = function(v1, v2) {\n    var total = 0\n    for (let c in v1) {\n        if (c!=0)\n        total += Math.pow(v2[c]-v1[c], 2)\n    }\n    return Math.sqrt(total)\n}\n\n// kmeans.js 0.0.1\n\n//The kmeans clustering algorithm relies upon knowing in advance\n//the number of clusters in which to place vectors. \n\n\n// Expose \n// ----------\n\n//Expose our library to be called externally\nexport default function(vector, k, callback) { \n    if (!vector || !k || !callback) throw new Error(\n            \"Provide 3 arguments: callback, vector, clusters\")\n    \n    return new Kmeans(vector, k, callback)\n}\n"],"sourceRoot":""}