(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{114:function(module,exports,__webpack_require__){eval("var content = __webpack_require__(386);\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(7)(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz85MGFmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0zIS4vR3JvdXBpbmdUb29sLmxlc3M/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xZDA2NmJjMCZsYW5nPWxlc3Mmc2NvcGVkPXRydWUmXCIpO1xuXG5pZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbn1cblxudmFyIG9wdGlvbnMgPSB7fVxuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZiAoY29udGVudC5sb2NhbHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///114\n")},115:function(module,exports){eval('module.exports = function (Component) {\n  Component.options.__i18n = Component.options.__i18n || []\n  Component.options.__i18n.push(\'{"en-US":{"Search":"Search"},"zh-TW":{"Search":"搜尋"}}\')\n  delete Component.options._Ctor\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wueWFtbD8xOGVhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICBDb21wb25lbnQub3B0aW9ucy5fX2kxOG4gPSBDb21wb25lbnQub3B0aW9ucy5fX2kxOG4gfHwgW11cbiAgQ29tcG9uZW50Lm9wdGlvbnMuX19pMThuLnB1c2goJ3tcImVuLVVTXCI6e1wiU2VhcmNoXCI6XCJTZWFyY2hcIn0sXCJ6aC1UV1wiOntcIlNlYXJjaFwiOlwi5pCc5bCLXCJ9fScpXG4gIGRlbGV0ZSBDb21wb25lbnQub3B0aW9ucy5fQ3RvclxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///115\n')},385:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(114);\n/* harmony import */ var _node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz82YzliIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMyEuL0dyb3VwaW5nVG9vbC5sZXNzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MWQwNjZiYzAmbGFuZz1sZXNzJnNjb3BlZD10cnVlJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTMhLi9Hcm91cGluZ1Rvb2wubGVzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFkMDY2YmMwJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///385\n")},386:function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(6)(true);\n// Module\nexports.push([module.i, "input[data-v-1d066bc0]{width:5rem!important}select[data-v-1d066bc0]{width:auto!important}label[data-v-1d066bc0]{width:4rem!important;text-align:right!important}button[data-v-1d066bc0],label[data-v-1d066bc0]{margin-right:1rem!important}", "",{"version":3,"sources":["/app/src/components/ReplacePanel/GroupingTool/GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&","/app/src/components/ReplacePanel/GroupingTool/GroupingTool.less"],"names":[],"mappings":"AAAA,uBACE,oBCCF,CDMA,wBACE,oBCJF,CDQA,uBAEE,oBAAA,CACA,0BCNF,CDQA,+CAJE,2BCDF","file":"GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&","sourcesContent":["input {\\n  width: 5rem !important;\\n}\\n\\n// .GroupingTool {\\n//   margin-top: 0.2rem !important;\\n// }\\n\\nselect {\\n  width: auto !important;\\n}\\n\\n\\nlabel {\\n  margin-right: 1rem !important;\\n  width: 4rem !important;\\n  text-align: right !important;\\n}\\nbutton {\\n  margin-right: 1rem !important;\\n}","input {\\n  width: 5rem !important;\\n}\\nselect {\\n  width: auto !important;\\n}\\nlabel {\\n  margin-right: 1rem !important;\\n  width: 4rem !important;\\n  text-align: right !important;\\n}\\nbutton {\\n  margin-right: 1rem !important;\\n}\\n"]}]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz81MWRiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKHRydWUpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJpbnB1dFtkYXRhLXYtMWQwNjZiYzBde3dpZHRoOjVyZW0haW1wb3J0YW50fXNlbGVjdFtkYXRhLXYtMWQwNjZiYzBde3dpZHRoOmF1dG8haW1wb3J0YW50fWxhYmVsW2RhdGEtdi0xZDA2NmJjMF17d2lkdGg6NHJlbSFpbXBvcnRhbnQ7dGV4dC1hbGlnbjpyaWdodCFpbXBvcnRhbnR9YnV0dG9uW2RhdGEtdi0xZDA2NmJjMF0sbGFiZWxbZGF0YS12LTFkMDY2YmMwXXttYXJnaW4tcmlnaHQ6MXJlbSFpbXBvcnRhbnR9XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcC9zcmMvY29tcG9uZW50cy9SZXBsYWNlUGFuZWwvR3JvdXBpbmdUb29sL0dyb3VwaW5nVG9vbC5sZXNzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MWQwNjZiYzAmbGFuZz1sZXNzJnNjb3BlZD10cnVlJlwiLFwiL2FwcC9zcmMvY29tcG9uZW50cy9SZXBsYWNlUGFuZWwvR3JvdXBpbmdUb29sL0dyb3VwaW5nVG9vbC5sZXNzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLHVCQUNFLG9CQ0NGLENETUEsd0JBQ0Usb0JDSkYsQ0RRQSx1QkFFRSxvQkFBQSxDQUNBLDBCQ05GLENEUUEsK0NBSkUsMkJDREZcIixcImZpbGVcIjpcIkdyb3VwaW5nVG9vbC5sZXNzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MWQwNjZiYzAmbGFuZz1sZXNzJnNjb3BlZD10cnVlJlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJpbnB1dCB7XFxuICB3aWR0aDogNXJlbSAhaW1wb3J0YW50O1xcbn1cXG5cXG4vLyAuR3JvdXBpbmdUb29sIHtcXG4vLyAgIG1hcmdpbi10b3A6IDAuMnJlbSAhaW1wb3J0YW50O1xcbi8vIH1cXG5cXG5zZWxlY3Qge1xcbiAgd2lkdGg6IGF1dG8gIWltcG9ydGFudDtcXG59XFxuXFxuXFxubGFiZWwge1xcbiAgbWFyZ2luLXJpZ2h0OiAxcmVtICFpbXBvcnRhbnQ7XFxuICB3aWR0aDogNHJlbSAhaW1wb3J0YW50O1xcbiAgdGV4dC1hbGlnbjogcmlnaHQgIWltcG9ydGFudDtcXG59XFxuYnV0dG9uIHtcXG4gIG1hcmdpbi1yaWdodDogMXJlbSAhaW1wb3J0YW50O1xcbn1cIixcImlucHV0IHtcXG4gIHdpZHRoOiA1cmVtICFpbXBvcnRhbnQ7XFxufVxcbnNlbGVjdCB7XFxuICB3aWR0aDogYXV0byAhaW1wb3J0YW50O1xcbn1cXG5sYWJlbCB7XFxuICBtYXJnaW4tcmlnaHQ6IDFyZW0gIWltcG9ydGFudDtcXG4gIHdpZHRoOiA0cmVtICFpbXBvcnRhbnQ7XFxuICB0ZXh0LWFsaWduOiByaWdodCAhaW1wb3J0YW50O1xcbn1cXG5idXR0b24ge1xcbiAgbWFyZ2luLXJpZ2h0OiAxcmVtICFpbXBvcnRhbnQ7XFxufVxcblwiXX1dKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///386\n')},387:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(115);\n/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__);\n /* harmony default export */ __webpack_exports__["default"] = (_node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wueWFtbD8zYWFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BrYXp1cG9uL3Z1ZS1pMThuLWxvYWRlci9saWIvaW5kZXguanMhLi9Hcm91cGluZ1Rvb2wueWFtbD92dWUmdHlwZT1jdXN0b20maW5kZXg9MCZibG9ja1R5cGU9aTE4biZpc3N1ZXJQYXRoPSUyRmFwcCUyRnNyYyUyRmNvbXBvbmVudHMlMkZSZXBsYWNlUGFuZWwlMkZHcm91cGluZ1Rvb2wlMkZHcm91cGluZ1Rvb2wudnVlJmxhbmc9eWFtbFwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2F6dXBvbi92dWUtaTE4bi1sb2FkZXIvbGliL2luZGV4LmpzIS4vR3JvdXBpbmdUb29sLnlhbWw/dnVlJnR5cGU9Y3VzdG9tJmluZGV4PTAmYmxvY2tUeXBlPWkxOG4maXNzdWVyUGF0aD0lMkZhcHAlMkZzcmMlMkZjb21wb25lbnRzJTJGUmVwbGFjZVBhbmVsJTJGR3JvdXBpbmdUb29sJTJGR3JvdXBpbmdUb29sLnZ1ZSZsYW5nPXlhbWxcIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///387\n')},424:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./src/components/ReplacePanel/GroupingTool/GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c("div", { staticClass: "GroupingTool" }, [\n    _c("div", { staticClass: "fields" }, [\n      _c("label", { attrs: { for: "GroupingToolSkipRows" } }, [\n        _vm._v("\\n      " + _vm._s(_vm.$t("Skip Rows")) + "\\n    ")\n      ]),\n      _vm._v(" "),\n      _c("input", {\n        directives: [\n          {\n            name: "model",\n            rawName: "v-model",\n            value: _vm.localConfig.GroupingTool.skipRows,\n            expression: "localConfig.GroupingTool.skipRows"\n          }\n        ],\n        attrs: { type: "number", id: "GroupingToolSkipRows" },\n        domProps: { value: _vm.localConfig.GroupingTool.skipRows },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig.GroupingTool,\n              "skipRows",\n              $event.target.value\n            )\n          }\n        }\n      }),\n      _vm._v(" "),\n      _c("label", { attrs: { for: "GroupingToolSkipColumns" } }, [\n        _vm._v("\\n      " + _vm._s(_vm.$t("Skip Cols")) + "\\n    ")\n      ]),\n      _vm._v(" "),\n      _c("input", {\n        directives: [\n          {\n            name: "model",\n            rawName: "v-model",\n            value: _vm.localConfig.GroupingTool.skipColumns,\n            expression: "localConfig.GroupingTool.skipColumns"\n          }\n        ],\n        attrs: { type: "number", id: "GroupingToolSkipColumns" },\n        domProps: { value: _vm.localConfig.GroupingTool.skipColumns },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig.GroupingTool,\n              "skipColumns",\n              $event.target.value\n            )\n          }\n        }\n      }),\n      _vm._v(" "),\n      _c(\n        "select",\n        {\n          directives: [\n            {\n              name: "model",\n              rawName: "v-model",\n              value: _vm.localConfig.GroupingTool.groupType,\n              expression: "localConfig.GroupingTool.groupType"\n            }\n          ],\n          on: {\n            change: function($event) {\n              var $$selectedVal = Array.prototype.filter\n                .call($event.target.options, function(o) {\n                  return o.selected\n                })\n                .map(function(o) {\n                  var val = "_value" in o ? o._value : o.value\n                  return val\n                })\n              _vm.$set(\n                _vm.localConfig.GroupingTool,\n                "groupType",\n                $event.target.multiple ? $$selectedVal : $$selectedVal[0]\n              )\n            }\n          }\n        },\n        [\n          _c("option", { attrs: { value: "group" } }, [\n            _vm._v(_vm._s(_vm.$t("Group: ")))\n          ]),\n          _vm._v(" "),\n          _c("option", { attrs: { value: "member" } }, [\n            _vm._v(_vm._s(_vm.$t("Member: ")))\n          ])\n        ]\n      ),\n      _vm._v(" "),\n      _c("input", {\n        directives: [\n          {\n            name: "model",\n            rawName: "v-model",\n            value: _vm.localConfig.GroupingTool.groupLength,\n            expression: "localConfig.GroupingTool.groupLength"\n          }\n        ],\n        attrs: { type: "number", min: "0" },\n        domProps: { value: _vm.localConfig.GroupingTool.groupLength },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig.GroupingTool,\n              "groupLength",\n              $event.target.value\n            )\n          }\n        }\n      }),\n      _vm._v(" "),\n      _c(\n        "button",\n        {\n          staticClass: "ui icon button basic",\n          attrs: { type: "button" },\n          on: { click: _vm.removeLastColumn }\n        },\n        [_c("i", { staticClass: "undo icon" })]\n      )\n    ])\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js\nvar helpers_typeof = __webpack_require__(1);\nvar typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__(2);\nvar asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);\n\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/kmeans.js\n\nvar MAX_ITERATIONS = 50;\nfunction randomBetween(min, max) {\n  return Math.floor(Math.random() * (max - min) + min);\n}\nfunction calcMeanCentroid(dataSet, start, end) {\n  var features = dataSet[0].length;\n  var n = end - start;\n  var mean = [];\n  for (var i = 0; i < features; i++) {\n    mean.push(0);\n  }\n  for (var _i = start; _i < end; _i++) {\n    for (var j = 0; j < features; j++) {\n      mean[j] = mean[j] + dataSet[_i][j] / n;\n    }\n  }\n  return mean;\n}\nfunction getRandomCentroidsNaiveSharding(dataset, k) {\n  // implementation of a variation of naive sharding centroid initialization method\n  // (not using sums or sorting, just dividing into k shards and calc mean)\n  // https://www.kdnuggets.com/2017/03/naive-sharding-centroid-initialization-method.html\n  var numSamples = dataset.length;\n  // Divide dataset into k shards:\n  var step = Math.floor(numSamples / k);\n  // console.log(step);\n  var centroids = [];\n  for (var i = 0; i < k; i++) {\n    var start = step * i;\n    var end = step * (i + 1);\n    if (i + 1 === k) {\n      end = numSamples;\n    }\n    // console.log(start, end);\n    centroids.push(calcMeanCentroid(dataset, start, end));\n  }\n  return centroids;\n}\nfunction getRandomCentroids(dataset, k) {\n  // selects random points as centroids from the dataset\n  var numSamples = dataset.length;\n  var centroidsIndex = [];\n  var index;\n  while (centroidsIndex.length < k) {\n    index = randomBetween(0, numSamples);\n    if (centroidsIndex.indexOf(index) === -1) {\n      centroidsIndex.push(index);\n    }\n  }\n  var centroids = [];\n  for (var i = 0; i < centroidsIndex.length; i++) {\n    var centroid = [].concat(dataset[centroidsIndex[i]]);\n    centroids.push(centroid);\n  }\n  return centroids;\n}\nfunction compareCentroids(a, b) {\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shouldStop(oldCentroids, centroids, iterations) {\n  if (iterations > MAX_ITERATIONS) {\n    return true;\n  }\n  if (!oldCentroids || !oldCentroids.length) {\n    return false;\n  }\n  var sameCount = true;\n  for (var i = 0; i < centroids.length; i++) {\n    if (!compareCentroids(centroids[i], oldCentroids[i])) {\n      sameCount = false;\n    }\n  }\n  return sameCount;\n}\n\n// Calculate Squared Euclidean Distance\nfunction getDistanceSQ(a, b) {\n  var diffs = [];\n  for (var i = 0; i < a.length; i++) {\n    diffs.push(a[i] - b[i]);\n  }\n  return diffs.reduce(function (r, e) {\n    return r + e * e;\n  }, 0);\n}\n\n// Returns a label for each piece of data in the dataset. \nfunction getLabels(dataSet, centroids) {\n  // prep data structure:\n  var labels = {};\n  for (var c = 0; c < centroids.length; c++) {\n    labels[c] = {\n      points: [],\n      centroid: centroids[c],\n      indexes: []\n    };\n  }\n  // For each element in the dataset, choose the closest centroid. \n  // Make that centroid the element\'s label.\n  for (var i = 0; i < dataSet.length; i++) {\n    var a = dataSet[i];\n    var closestCentroid = void 0,\n      closestCentroidIndex = void 0,\n      prevDistance = void 0;\n    for (var j = 0; j < centroids.length; j++) {\n      var centroid = centroids[j];\n      if (j === 0) {\n        closestCentroid = centroid;\n        closestCentroidIndex = j;\n        prevDistance = getDistanceSQ(a, closestCentroid);\n      } else {\n        // get distance:\n        var distance = getDistanceSQ(a, centroid);\n        if (distance < prevDistance) {\n          prevDistance = distance;\n          closestCentroid = centroid;\n          closestCentroidIndex = j;\n        }\n      }\n    }\n    // add point to centroid labels:\n    labels[closestCentroidIndex].points.push(a);\n    labels[closestCentroidIndex].indexes.push(i);\n  }\n  return labels;\n}\nfunction getPointsMean(pointList) {\n  var totalPoints = pointList.length;\n  var means = [];\n  for (var j = 0; j < pointList[0].length; j++) {\n    means.push(0);\n  }\n  for (var i = 0; i < pointList.length; i++) {\n    var point = pointList[i];\n    for (var _j = 0; _j < point.length; _j++) {\n      var val = point[_j];\n      means[_j] = means[_j] + val / totalPoints;\n    }\n  }\n  return means;\n}\nfunction recalculateCentroids(dataSet, labels, k) {\n  // Each centroid is the geometric mean of the points that\n  // have that centroid\'s label. Important: If a centroid is empty (no points have\n  // that centroid\'s label) you should randomly re-initialize it.\n  var newCentroid;\n  var newCentroidList = [];\n  for (var _k in labels) {\n    var centroidGroup = labels[_k];\n    if (centroidGroup.points.length > 0) {\n      // find mean:\n      newCentroid = getPointsMean(centroidGroup.points);\n    } else {\n      // get new random centroid\n      newCentroid = getRandomCentroids(dataSet, 1)[0];\n    }\n    newCentroidList.push(newCentroid);\n  }\n  return newCentroidList;\n}\nfunction kmeans_kmeans(dataset, k) {\n  var useNaiveSharding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'auto\';\n  if (useNaiveSharding === \'auto\') {\n    useNaiveSharding = dataset.length / k > 4;\n  }\n  useNaiveSharding = false;\n  //   console.log(dataset)\n  if (dataset.length && dataset[0].length && dataset.length > k) {\n    var _ret = function () {\n      // Initialize book keeping variables\n      var iterations = 0;\n      var oldCentroids, labels, centroids;\n\n      // Initialize centroids randomly\n      if (useNaiveSharding) {\n        centroids = getRandomCentroidsNaiveSharding(dataset, k);\n      } else {\n        centroids = getRandomCentroids(dataset, k);\n      }\n      // console.log(centroids)\n\n      // Run the main k-means algorithm\n      while (!shouldStop(oldCentroids, centroids, iterations)) {\n        // Save old centroids for convergence test.\n        oldCentroids = [].concat(centroids);\n        iterations++;\n\n        // Assign labels to each datapoint based on centroids\n        labels = getLabels(dataset, centroids);\n        // console.log(oldCentroids)\n        centroids = recalculateCentroids(dataset, labels, k);\n        // console.log(centroids)\n      }\n\n      var clusters = [];\n      var datasetLabels = new Array(dataset.length);\n      var _loop = function _loop(i) {\n        clusters.push(labels[i].indexes);\n        labels[i].indexes.forEach(function (datasetIndex) {\n          datasetLabels[datasetIndex] = i;\n        });\n      };\n      for (var i = 0; i < k; i++) {\n        _loop(i);\n      }\n      var results = {\n        datasetLabels: datasetLabels,\n        clusterVector: datasetLabels,\n        clusters: clusters,\n        clusterIndex: clusters,\n        centroids: centroids,\n        iterations: iterations,\n        converged: iterations <= MAX_ITERATIONS\n      };\n      return {\n        v: results\n      };\n    }();\n    if (typeof_default()(_ret) === "object") return _ret.v;\n  } else {\n    throw new Error(\'Invalid dataset\');\n  }\n}\n/* harmony default export */ var GroupingTool_kmeans = (kmeans_kmeans);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--6!./src/components/ReplacePanel/GroupingTool/GroupingTool.js?vue&type=script&lang=js&\n\n\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof_default()(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nvar GroupingTool = {\n  props: [\'config\', \'localConfig\', \'utils\'],\n  data: function data() {\n    this.$i18n.locale = this.localConfig.locale;\n    return {};\n  },\n  watch: {\n    \'localConfig.locale\': function localConfigLocale() {\n      this.$i18n.locale = this.localConfig.locale;\n    }\n  },\n  // computed: {\n\n  // },\n  // mounted: async function () {\n  //   this.test202210301729()\n  // },\n  methods: {\n    test202210300033: function () {\n      var _test = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var vector;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // var vector = [\n                //   [1, 10, 2, 30],\n                //   [\'A\', 30, 20, 2],\n                //   [\'B\', 30, 30, 3],\n                //   [\'C\', 30, 31, 3],\n                //   [\'A\', 10, 10, 1],\n                //   [\'B\', 20, 1, 30],\n                //   [\'C\', 1, 25, 30]\n                // ]\n                vector = [[10, 2, 30], [30, 20, 2], [30, 30, 3], [30, 31, 3], [10, 10, 1], [20, 1, 30], [1, 25, 30]]; // console.log(await this.toVector(vector))\n                // console.log(await this.addKmeans(vector))\n                // console.log(await this.addGroupInDifference(vector))\n                // console.log(await this.addGroupInSimilarity(vector))\n                // console.log(vector)\n                _context.t0 = console;\n                _context.next = 4;\n                return this.kmeans(vector, 3);\n              case 4:\n                _context.t1 = _context.sent;\n                _context.t0.log.call(_context.t0, _context.t1);\n              case 6:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function test202210300033() {\n        return _test.apply(this, arguments);\n      }\n      return test202210300033;\n    }(),\n    test202210301729: function () {\n      var _test2 = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var vector;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                vector = [[1, 2, 3, 1], [5, 2, 3, 1], [1, 2, 4, 0], [5, 3, 4, 0]]; // console.log(await this.toVector(vector))\n                // console.log(await this.addKmeans(vector))\n                // console.log(vector)\n                // console.log(await this.kmeans(vector, 2))\n                // console.log(await this.groupingBySimilarity(vector, \'member\', 2))\n                // console.log(await this.groupingByDifference(vector, \'member\', 2))\n              case 1:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      function test202210301729() {\n        return _test2.apply(this, arguments);\n      }\n      return test202210301729;\n    }(),\n    toVector: function () {\n      var _toVector = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(data) {\n        var rows, columeLength, c, list, isColumnNumber, d, value, isNumber, _ret, map, id, _d, _value, vectors, v, keys, i, _d2, _value2, _i, v2;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // console.log(data)\n                rows = new Array(data.length);\n                columeLength = data[0].length;\n                c = this.localConfig.GroupingTool.skipColumns;\n              case 3:\n                if (!(c < columeLength)) {\n                  _context3.next = 37;\n                  break;\n                }\n                list = [];\n                isColumnNumber = true;\n                d = 0;\n              case 7:\n                if (!(d < data.length)) {\n                  _context3.next = 19;\n                  break;\n                }\n                value = data[d][c];\n                isNumber = typeof value === \'number\';\n                if (!(isNumber === false)) {\n                  _context3.next = 15;\n                  break;\n                }\n                isColumnNumber = false;\n                return _context3.abrupt("break", 19);\n              case 15:\n                list.push(value);\n              case 16:\n                d++;\n                _context3.next = 7;\n                break;\n              case 19:\n                if (!(isColumnNumber === true)) {\n                  _context3.next = 25;\n                  break;\n                }\n                _ret = function () {\n                  var max = Math.max.apply(Math, list);\n                  var min = Math.min.apply(Math, list);\n                  var range = max - min;\n                  if (range === 0) {\n                    return "continue";\n                  }\n                  var normalized = void 0;\n                  if (max === 1 && min === 0) {\n                    normalized = list;\n                  } else {\n                    normalized = list.map(function (value) {\n                      return (value - min) / range;\n                    });\n                  }\n                  for (var r = 0; r < rows.length; r++) {\n                    if (!rows[r]) {\n                      rows[r] = [];\n                    }\n                    rows[r].push(normalized[r]);\n                  }\n                }();\n                if (!(_ret === "continue")) {\n                  _context3.next = 23;\n                  break;\n                }\n                return _context3.abrupt("continue", 34);\n              case 23:\n                _context3.next = 34;\n                break;\n              case 25:\n                map = {};\n                id = 0;\n                for (_d = 0; _d < data.length; _d++) {\n                  _value = data[_d][c];\n                  _value = _value + \'\';\n                  // console.log(value)\n                  if (!map[_value]) {\n                    map[_value] = id;\n                    id++;\n                  }\n                  list.push(_value);\n                }\n\n                // console.log(map, list)\n                vectors = [];\n                v = [];\n                keys = Object.keys(map);\n                for (i = 0; i < keys.length; i++) {\n                  v[i] = 0;\n                }\n                // console.log(v)\n\n                for (_d2 = 0; _d2 < data.length; _d2++) {\n                  _value2 = data[_d2][c];\n                  _value2 = _value2 + \'\';\n                  _i = keys.indexOf(_value2); // console.log(i)\n                  v2 = [].concat(v);\n                  v2[_i] = 1;\n                  vectors.push(v2);\n                }\n                // console.log(vectors)\n\n                vectors.forEach(function (vector, r) {\n                  if (!rows[r]) {\n                    rows[r] = [];\n                  }\n                  rows[r] = rows[r].concat(vector);\n                });\n              case 34:\n                c++;\n                _context3.next = 3;\n                break;\n              case 37:\n                return _context3.abrupt("return", rows);\n              case 38:\n              case "end":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function toVector(_x) {\n        return _toVector.apply(this, arguments);\n      }\n      return toVector;\n    }(),\n    // kmeans: async function (data, cluster = 3) {\n    //   let vector = await this.toVector(data)\n    //   return new Promise(function (resolve, reject) {\n    //     // console.log(cluster)\n    //     kmeans(vector, cluster, function(err, clusterVector, clusterIndex, cluster, centroids) {\n    //       if (err) {\n    //         // throw new Error(err)\n    //         return reject(err)\n    //       }\n\n    //       //do something with the result\n    //       // console.log(res)\n    //       resolve({\n    //         clusterVector,\n    //         clusterIndex,\n    //         cluster,\n    //         centroids\n    //       })\n    //     })\n    //   })\n    //   // console.log(vector) \n    // },\n    kmeans: function () {\n      var _kmeans2 = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(data) {\n        var cluster,\n          vector,\n          result,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                cluster = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : 3;\n                _context4.next = 3;\n                return this.toVector(data);\n              case 3:\n                vector = _context4.sent;\n                // return new Promise(function (resolve, reject) {\n                // console.log(cluster)\n                // resovle(kmeans(vector, cluster))\n                // })\n                // console.log(vector) \n                result = GroupingTool_kmeans(vector, cluster); // console.log(result)\n                return _context4.abrupt("return", result);\n              case 6:\n              case "end":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function kmeans(_x2) {\n        return _kmeans2.apply(this, arguments);\n      }\n      return kmeans;\n    }(),\n    addKmeans: function () {\n      var _addKmeans = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(vector) {\n        var cluster,\n          result,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                cluster = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : 3;\n                _context5.next = 3;\n                return this.kmeans(vector, cluster);\n              case 3:\n                result = _context5.sent;\n                return _context5.abrupt("return", vector.map(function (item, i) {\n                  // console.log(item, i, result.clusterIndex)\n                  item.push(result.clusterVector[i]);\n                  return item;\n                }));\n              case 5:\n              case "end":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function addKmeans(_x3) {\n        return _addKmeans.apply(this, arguments);\n      }\n      return addKmeans;\n    }(),\n    groupingByDifference: function () {\n      var _groupingByDifference = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(vector) {\n        var groupType,\n          member,\n          headerRows,\n          _yield$this$kmeans,\n          clusterIndex,\n          groups,\n          groupIndexList,\n          mod,\n          minMembers,\n          counter,\n          i,\n          group,\n          clusterI,\n          baseMember,\n          v,\n          randomId,\n          item,\n          output,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                groupType = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : \'member\';\n                member = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : 3;\n                member = Number(member);\n                headerRows = [];\n                if (this.localConfig.GroupingTool.skipRows > 0) {\n                  headerRows = vector.slice(0, this.localConfig.GroupingTool.skipRows);\n                  vector = vector.slice(this.localConfig.GroupingTool.skipRows);\n                }\n                _context6.next = 7;\n                return this.kmeans(vector, member);\n              case 7:\n                _yield$this$kmeans = _context6.sent;\n                clusterIndex = _yield$this$kmeans.clusterIndex;\n                // 合併與計算比例\n                clusterIndex = this.balanceClusters(clusterIndex, Math.ceil(vector.length / member), Math.floor(vector.length / member));\n\n                // console.log(clusterIndex)\n                // return false\n                groups = Math.ceil(vector.length / member);\n                if (groupType === \'group\') {\n                  groups = member;\n                  member = Number(Math.floor(vector.length / groups));\n                }\n                // console.log(groups, member)\n                groupIndexList = [];\n                mod = vector.length % groups;\n                minMembers = Math.floor(vector.length / groups); // return console.log(member, Math.floor(vector.length / groups))\n                // let minMembers = member\n                counter = 0; // console.log(groups)\n                i = 0;\n              case 17:\n                if (!(i < groups)) {\n                  _context6.next = 43;\n                  break;\n                }\n                group = [];\n                clusterI = 0;\n                baseMember = minMembers;\n                if (i < mod) {\n                  baseMember++;\n                }\n\n                // console.log(baseMember)\n                // continue\n              case 22:\n                if (false) {}\n                v = clusterIndex[clusterI % clusterIndex.length]; // console.log(groups, clusterI, v, counter, vector.length) \n                if (!(v.length === 0)) {\n                  _context6.next = 27;\n                  break;\n                }\n                clusterI++;\n                return _context6.abrupt("continue", 22);\n              case 27:\n                randomId = Math.floor(Math.random() * v.length);\n                item = v[randomId];\n                group.push(Number(item));\n                // console.log(item)\n\n                v.splice(randomId, 1);\n                // console.log(vector)\n                // clusterVector[(clusterI % member)] = v\n                // console.log(result.clusterVector)\n                // console.log(v)\n\n                clusterI++;\n                counter++;\n                // console.log(counter, group.length, member)\n                if (!(counter === vector.length)) {\n                  _context6.next = 35;\n                  break;\n                }\n                return _context6.abrupt("break", 39);\n              case 35:\n                if (!(group.length === baseMember)) {\n                  _context6.next = 37;\n                  break;\n                }\n                return _context6.abrupt("break", 39);\n              case 37:\n                _context6.next = 22;\n                break;\n              case 39:\n                // console.log(group)\n                groupIndexList.push(group);\n              case 40:\n                i++;\n                _context6.next = 17;\n                break;\n              case 43:\n                // console.log(groupIndexList)\n                // let invertGroup = new Array(groups)\n                output = [].concat(vector);\n                groupIndexList.forEach(function (list, groupId) {\n                  list.forEach(function (index) {\n                    var o = [].concat(output[index]);\n                    o.push(groupId);\n                    output[index] = o;\n                  });\n                });\n                output = headerRows.concat(output);\n                return _context6.abrupt("return", output);\n              case 47:\n              case "end":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function groupingByDifference(_x4) {\n        return _groupingByDifference.apply(this, arguments);\n      }\n      return groupingByDifference;\n    }(),\n    balanceClusters: function balanceClusters(clusterIndex, maxMembers, minMembers) {\n      // if (maxMembers === minMembers) {\n      //   minMembers--\n      // }\n      // return false\n      this.sortClusterIndexBySize(clusterIndex);\n      // console.log(JSON.stringify(clusterIndex, null, 2), maxMembers, minMembers)\n\n      while (clusterIndex[clusterIndex.length - 1].length === 0) {\n        var tempCluster = [];\n        var largestCluster = clusterIndex[0];\n        while (tempCluster.length < minMembers) {\n          var randomId = Math.floor(Math.random() * largestCluster.length);\n          tempCluster.push(largestCluster[randomId]);\n          largestCluster.splice(randomId, 1);\n          // console.log(tempCluster)\n        }\n\n        clusterIndex[0] = largestCluster;\n        clusterIndex[clusterIndex.length - 1] = tempCluster;\n        this.sortClusterIndexBySize(clusterIndex);\n      }\n\n      // console.log(clusterIndex)\n      var isValid = true;\n      for (var i = 0; i < clusterIndex.length; i++) {\n        if (clusterIndex[i].length > maxMembers) {\n          isValid = 1;\n          break;\n        }\n        if (clusterIndex[i].length < minMembers) {\n          isValid = 2;\n          break;\n        }\n      }\n      if (isValid === true) {\n        return clusterIndex;\n      } else if (isValid === 1) {\n        // 最小的，合併\n        var len = clusterIndex.length;\n        var minCluster = clusterIndex[len - 1];\n        var baseIndex = len - 2;\n        while (clusterIndex[baseIndex].length < maxMembers) {\n          var _randomId = Math.floor(Math.random() * minCluster.length);\n          clusterIndex[baseIndex].push(minCluster[_randomId]);\n          minCluster.splice(_randomId, 1);\n          // console.log(tempCluster)\n\n          if (minCluster.length === 0) {\n            break;\n          }\n          if (clusterIndex[baseIndex].length === maxMembers && minCluster.length > 0) {\n            baseIndex--;\n          }\n          if (baseIndex === -1) {\n            break;\n          }\n        }\n\n        // clusterIndex[(len - 2)] = clusterIndex[(len - 2)].concat(clusterIndex[(len - 1)])\n\n        // 最大的，拆一半\n        var _tempCluster = [].concat(minCluster);\n        var _largestCluster = clusterIndex[0];\n        while (_tempCluster.length < minMembers) {\n          var _randomId2 = Math.floor(Math.random() * _largestCluster.length);\n          _tempCluster.push(_largestCluster[_randomId2]);\n          _largestCluster.splice(_randomId2, 1);\n          // console.log(tempCluster)\n        }\n\n        clusterIndex[0] = _largestCluster;\n        clusterIndex[len - 1] = _tempCluster;\n\n        // console.log(clusterIndex)\n        // return false\n        return this.balanceClusters(clusterIndex, maxMembers, minMembers);\n      } else {\n        // 最小的，合併\n        var _len = clusterIndex.length;\n        var maxCluster = clusterIndex[0];\n        var _randomId3 = Math.floor(Math.random() * maxCluster.length);\n        clusterIndex[_len - 1].push(maxCluster[_randomId3]);\n        maxCluster.splice(_randomId3, 1);\n        clusterIndex[0] = maxCluster;\n        // let baseIndex = (len - 2)\n        // while (clusterIndex[baseIndex].length < maxMembers) {\n        //   let randomId = Math.floor(Math.random() * minCluster.length)\n        //   clusterIndex[baseIndex].push(minCluster[randomId])\n        //   minCluster.splice(randomId, 1)\n        //   // console.log(tempCluster)\n\n        //   if (minCluster.length === 0) {\n        //     break\n        //   }\n        //   if (clusterIndex[baseIndex].length === maxMembers && \n        //       minCluster.length > 0) {\n        //     baseIndex--\n        //   }\n        // }\n\n        // // clusterIndex[(len - 2)] = clusterIndex[(len - 2)].concat(clusterIndex[(len - 1)])\n\n        // // 最大的，拆一半\n        // let tempCluster = []\n        // let largestCluster = clusterIndex[0]\n        // while (tempCluster.length < minMembers) {\n        //   let randomId = Math.floor(Math.random() * largestCluster.length)\n        //   tempCluster.push(largestCluster[randomId])\n        //   largestCluster.splice(randomId, 1)\n        //   // console.log(tempCluster)\n        // }\n        // clusterIndex[0] = largestCluster\n        // clusterIndex[(len - 1)] = tempCluster\n\n        // // console.log(clusterIndex)\n        // return false\n        return this.balanceClusters(clusterIndex, maxMembers, minMembers);\n      }\n    },\n    groupingBySimilarity: function () {\n      var _groupingBySimilarity = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(vector) {\n        var groupType,\n          member,\n          headerRows,\n          groups,\n          _yield$this$kmeans2,\n          clusterIndex,\n          isFinish,\n          i,\n          list,\n          randomId,\n          _randomId4,\n          _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                groupType = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : \'member\';\n                member = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : 3;\n                member = Number(member);\n                headerRows = [];\n                if (this.localConfig.GroupingTool.skipRows > 0) {\n                  headerRows = vector.slice(0, this.localConfig.GroupingTool.skipRows);\n                  vector = vector.slice(this.localConfig.GroupingTool.skipRows);\n                }\n                groups = Math.ceil(vector.length / member);\n                if (groupType === \'group\') {\n                  groups = member;\n                  member = Math.ceil(vector.length / groups);\n                }\n\n                // console.log(groups, member)\n                _context7.next = 9;\n                return this.kmeans(vector, groups);\n              case 9:\n                _yield$this$kmeans2 = _context7.sent;\n                clusterIndex = _yield$this$kmeans2.clusterIndex;\n                // console.log(clusterIndex) \n                this.sortClusterIndexBySize(clusterIndex);\n              case 12:\n                if (false) {}\n                isFinish = true;\n                i = 0;\n              case 15:\n                if (!(i < clusterIndex.length)) {\n                  _context7.next = 26;\n                  break;\n                }\n                list = clusterIndex[i];\n                if (!(list.length <= member && list.length >= member - 1)) {\n                  _context7.next = 19;\n                  break;\n                }\n                return _context7.abrupt("continue", 23);\n              case 19:\n                isFinish = false;\n                if (list.length > member) {\n                  randomId = Math.floor(Math.random() * list.length);\n                  clusterIndex[clusterIndex.length - 1].push(list[randomId]);\n                  list.splice(randomId, 1);\n                } else {\n                  _randomId4 = Math.floor(Math.random() * clusterIndex[0].length);\n                  clusterIndex[i].push(clusterIndex[0][_randomId4]);\n                  clusterIndex[0].splice(_randomId4, 1);\n                }\n                this.sortClusterIndexBySize(clusterIndex);\n                return _context7.abrupt("break", 26);\n              case 23:\n                i++;\n                _context7.next = 15;\n                break;\n              case 26:\n                if (!isFinish) {\n                  _context7.next = 28;\n                  break;\n                }\n                return _context7.abrupt("break", 30);\n              case 28:\n                _context7.next = 12;\n                break;\n              case 30:\n                Object.keys(clusterIndex).forEach(function (groupId) {\n                  clusterIndex[groupId].forEach(function (i) {\n                    vector[i].push(Number(groupId));\n                  });\n                });\n                vector = headerRows.concat(vector);\n                return _context7.abrupt("return", vector);\n              case 33:\n              case "end":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function groupingBySimilarity(_x5) {\n        return _groupingBySimilarity.apply(this, arguments);\n      }\n      return groupingBySimilarity;\n    }(),\n    sortClusterIndexBySize: function sortClusterIndexBySize(clusterIndex) {\n      clusterIndex.sort(function (a, b) {\n        return b.length - a.length;\n      });\n    },\n    removeLastColumn: function removeLastColumn() {\n      var data = this.$parent.dataMatrix;\n      var headerRows = [];\n      if (this.localConfig.GroupingTool.skipRows > 0) {\n        headerRows = data.slice(0, this.localConfig.GroupingTool.skipRows);\n        data = data.slice(this.localConfig.GroupingTool.skipRows);\n      }\n      // console.log(data)\n      data = data.map(function (row) {\n        return row.slice(0, row.length - 1);\n      });\n      data = headerRows.concat(data);\n      // console.log(data)\n      this.localConfig.textContent = data.map(function (line) {\n        return line.join(\'\\t\');\n      }).join(\'\\n\');\n    }\n  }\n};\n/* harmony default export */ var GroupingToolvue_type_script_lang_js_ = (GroupingTool);\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.js?vue&type=script&lang=js&\n /* harmony default export */ var GroupingTool_GroupingToolvue_type_script_lang_js_ = (GroupingToolvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\nvar GroupingToolvue_type_style_index_0_id_1d066bc0_lang_less_scoped_true_ = __webpack_require__(385);\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(8);\n\n// EXTERNAL MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.yaml?vue&type=custom&index=0&blockType=i18n&issuerPath=%2Fapp%2Fsrc%2Fcomponents%2FReplacePanel%2FGroupingTool%2FGroupingTool.vue&lang=yaml\nvar GroupingToolvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml = __webpack_require__(387);\n\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  GroupingTool_GroupingToolvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "1d066bc0",\n  null\n  \n)\n\n/* custom blocks */\n\nif (typeof GroupingToolvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml["default"] === \'function\') Object(GroupingToolvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml["default"])(component)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "src/components/ReplacePanel/GroupingTool/GroupingTool.vue"\n/* harmony default export */ var GroupingTool_GroupingTool = __webpack_exports__["default"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wuaHRtbD85ZWIzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1JlcGxhY2VQYW5lbC9Hcm91cGluZ1Rvb2wva21lYW5zLmpzPzFhODIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wuanM/ZDZhYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9SZXBsYWNlUGFuZWwvR3JvdXBpbmdUb29sL0dyb3VwaW5nVG9vbC5qcz85NTAxIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1JlcGxhY2VQYW5lbC9Hcm91cGluZ1Rvb2wvR3JvdXBpbmdUb29sLnZ1ZT85NWQ4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJHcm91cGluZ1Rvb2xcIiB9LCBbXG4gICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJmaWVsZHNcIiB9LCBbXG4gICAgICBfYyhcImxhYmVsXCIsIHsgYXR0cnM6IHsgZm9yOiBcIkdyb3VwaW5nVG9vbFNraXBSb3dzXCIgfSB9LCBbXG4gICAgICAgIF92bS5fdihcIlxcbiAgICAgIFwiICsgX3ZtLl9zKF92bS4kdChcIlNraXAgUm93c1wiKSkgKyBcIlxcbiAgICBcIilcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICB2YWx1ZTogX3ZtLmxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5za2lwUm93cyxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IFwibG9jYWxDb25maWcuR3JvdXBpbmdUb29sLnNraXBSb3dzXCJcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGF0dHJzOiB7IHR5cGU6IFwibnVtYmVyXCIsIGlkOiBcIkdyb3VwaW5nVG9vbFNraXBSb3dzXCIgfSxcbiAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuc2tpcFJvd3MgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBpbnB1dDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdm0uJHNldChcbiAgICAgICAgICAgICAgX3ZtLmxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbCxcbiAgICAgICAgICAgICAgXCJza2lwUm93c1wiLFxuICAgICAgICAgICAgICAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImxhYmVsXCIsIHsgYXR0cnM6IHsgZm9yOiBcIkdyb3VwaW5nVG9vbFNraXBDb2x1bW5zXCIgfSB9LCBbXG4gICAgICAgIF92bS5fdihcIlxcbiAgICAgIFwiICsgX3ZtLl9zKF92bS4kdChcIlNraXAgQ29sc1wiKSkgKyBcIlxcbiAgICBcIilcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICB2YWx1ZTogX3ZtLmxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5za2lwQ29sdW1ucyxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IFwibG9jYWxDb25maWcuR3JvdXBpbmdUb29sLnNraXBDb2x1bW5zXCJcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGF0dHJzOiB7IHR5cGU6IFwibnVtYmVyXCIsIGlkOiBcIkdyb3VwaW5nVG9vbFNraXBDb2x1bW5zXCIgfSxcbiAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuc2tpcENvbHVtbnMgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBpbnB1dDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdm0uJHNldChcbiAgICAgICAgICAgICAgX3ZtLmxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbCxcbiAgICAgICAgICAgICAgXCJza2lwQ29sdW1uc1wiLFxuICAgICAgICAgICAgICAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJzZWxlY3RcIixcbiAgICAgICAge1xuICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuZ3JvdXBUeXBlLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5ncm91cFR5cGVcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNoYW5nZTogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhciAkJHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxuICAgICAgICAgICAgICAgIC5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucywgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IFwiX3ZhbHVlXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIF92bS4kc2V0KFxuICAgICAgICAgICAgICAgIF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wsXG4gICAgICAgICAgICAgICAgXCJncm91cFR5cGVcIixcbiAgICAgICAgICAgICAgICAkZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwib3B0aW9uXCIsIHsgYXR0cnM6IHsgdmFsdWU6IFwiZ3JvdXBcIiB9IH0sIFtcbiAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLiR0KFwiR3JvdXA6IFwiKSkpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcIm9wdGlvblwiLCB7IGF0dHJzOiB7IHZhbHVlOiBcIm1lbWJlclwiIH0gfSwgW1xuICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0uJHQoXCJNZW1iZXI6IFwiKSkpXG4gICAgICAgICAgXSlcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgdmFsdWU6IF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuZ3JvdXBMZW5ndGgsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBcImxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5ncm91cExlbmd0aFwiXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhdHRyczogeyB0eXBlOiBcIm51bWJlclwiLCBtaW46IFwiMFwiIH0sXG4gICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0ubG9jYWxDb25maWcuR3JvdXBpbmdUb29sLmdyb3VwTGVuZ3RoIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3ZtLiRzZXQoXG4gICAgICAgICAgICAgIF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wsXG4gICAgICAgICAgICAgIFwiZ3JvdXBMZW5ndGhcIixcbiAgICAgICAgICAgICAgJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJ1aSBpY29uIGJ1dHRvbiBiYXNpY1wiLFxuICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnJlbW92ZUxhc3RDb2x1bW4gfVxuICAgICAgICB9LFxuICAgICAgICBbX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwidW5kbyBpY29uXCIgfSldXG4gICAgICApXG4gICAgXSlcbiAgXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJjb25zdCBNQVhfSVRFUkFUSU9OUyA9IDUwO1xuXG5mdW5jdGlvbiByYW5kb21CZXR3ZWVuKG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKFxuICAgIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pblxuICApO1xufVxuXG5mdW5jdGlvbiBjYWxjTWVhbkNlbnRyb2lkKGRhdGFTZXQsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgZmVhdHVyZXMgPSBkYXRhU2V0WzBdLmxlbmd0aDtcbiAgY29uc3QgbiA9IGVuZCAtIHN0YXJ0O1xuICBsZXQgbWVhbiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZlYXR1cmVzOyBpKyspIHtcbiAgICBtZWFuLnB1c2goMCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZlYXR1cmVzOyBqKyspIHtcbiAgICAgIG1lYW5bal0gPSBtZWFuW2pdICsgZGF0YVNldFtpXVtqXSAvIG47XG4gICAgfVxuICB9XG4gIHJldHVybiBtZWFuO1xufVxuXG5mdW5jdGlvbiBnZXRSYW5kb21DZW50cm9pZHNOYWl2ZVNoYXJkaW5nKGRhdGFzZXQsIGspIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gb2YgYSB2YXJpYXRpb24gb2YgbmFpdmUgc2hhcmRpbmcgY2VudHJvaWQgaW5pdGlhbGl6YXRpb24gbWV0aG9kXG4gIC8vIChub3QgdXNpbmcgc3VtcyBvciBzb3J0aW5nLCBqdXN0IGRpdmlkaW5nIGludG8gayBzaGFyZHMgYW5kIGNhbGMgbWVhbilcbiAgLy8gaHR0cHM6Ly93d3cua2RudWdnZXRzLmNvbS8yMDE3LzAzL25haXZlLXNoYXJkaW5nLWNlbnRyb2lkLWluaXRpYWxpemF0aW9uLW1ldGhvZC5odG1sXG4gIGNvbnN0IG51bVNhbXBsZXMgPSBkYXRhc2V0Lmxlbmd0aDtcbiAgLy8gRGl2aWRlIGRhdGFzZXQgaW50byBrIHNoYXJkczpcbiAgY29uc3Qgc3RlcCA9IE1hdGguZmxvb3IobnVtU2FtcGxlcyAvIGspO1xuICAvLyBjb25zb2xlLmxvZyhzdGVwKTtcbiAgY29uc3QgY2VudHJvaWRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBzdGVwICogaTtcbiAgICBsZXQgZW5kID0gc3RlcCAqIChpICsgMSk7XG4gICAgaWYgKGkgKyAxID09PSBrKSB7XG4gICAgICBlbmQgPSBudW1TYW1wbGVzO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhzdGFydCwgZW5kKTtcbiAgICBjZW50cm9pZHMucHVzaChjYWxjTWVhbkNlbnRyb2lkKGRhdGFzZXQsIHN0YXJ0LCBlbmQpKTtcbiAgfVxuICByZXR1cm4gY2VudHJvaWRzO1xufVxuXG5mdW5jdGlvbiBnZXRSYW5kb21DZW50cm9pZHMoZGF0YXNldCwgaykge1xuICAvLyBzZWxlY3RzIHJhbmRvbSBwb2ludHMgYXMgY2VudHJvaWRzIGZyb20gdGhlIGRhdGFzZXRcbiAgY29uc3QgbnVtU2FtcGxlcyA9IGRhdGFzZXQubGVuZ3RoO1xuICBjb25zdCBjZW50cm9pZHNJbmRleCA9IFtdO1xuICBsZXQgaW5kZXg7XG4gIHdoaWxlIChjZW50cm9pZHNJbmRleC5sZW5ndGggPCBrKSB7XG4gICAgaW5kZXggPSByYW5kb21CZXR3ZWVuKDAsIG51bVNhbXBsZXMpO1xuICAgIGlmIChjZW50cm9pZHNJbmRleC5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgIGNlbnRyb2lkc0luZGV4LnB1c2goaW5kZXgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjZW50cm9pZHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZW50cm9pZHNJbmRleC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNlbnRyb2lkID0gW10uY29uY2F0KGRhdGFzZXRbY2VudHJvaWRzSW5kZXhbaV1dKTtcbiAgICBjZW50cm9pZHMucHVzaChjZW50cm9pZCk7XG4gIH1cbiAgcmV0dXJuIGNlbnRyb2lkcztcbn1cblxuZnVuY3Rpb24gY29tcGFyZUNlbnRyb2lkcyhhLCBiKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRTdG9wKG9sZENlbnRyb2lkcywgY2VudHJvaWRzLCBpdGVyYXRpb25zKSB7XG4gIGlmIChpdGVyYXRpb25zID4gTUFYX0lURVJBVElPTlMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIW9sZENlbnRyb2lkcyB8fCAhb2xkQ2VudHJvaWRzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgc2FtZUNvdW50ID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZW50cm9pZHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWNvbXBhcmVDZW50cm9pZHMoY2VudHJvaWRzW2ldLCBvbGRDZW50cm9pZHNbaV0pKSB7XG4gICAgICBzYW1lQ291bnQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNhbWVDb3VudDtcbn1cblxuLy8gQ2FsY3VsYXRlIFNxdWFyZWQgRXVjbGlkZWFuIERpc3RhbmNlXG5mdW5jdGlvbiBnZXREaXN0YW5jZVNRKGEsIGIpIHtcbiAgY29uc3QgZGlmZnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlmZnMucHVzaChhW2ldIC0gYltpXSk7XG4gIH1cbiAgcmV0dXJuIGRpZmZzLnJlZHVjZSgociwgZSkgPT4gKHIgKyAoZSAqIGUpKSwgMCk7XG59XG5cbi8vIFJldHVybnMgYSBsYWJlbCBmb3IgZWFjaCBwaWVjZSBvZiBkYXRhIGluIHRoZSBkYXRhc2V0LiBcbmZ1bmN0aW9uIGdldExhYmVscyhkYXRhU2V0LCBjZW50cm9pZHMpIHtcbiAgLy8gcHJlcCBkYXRhIHN0cnVjdHVyZTpcbiAgY29uc3QgbGFiZWxzID0ge307XG4gIGZvciAobGV0IGMgPSAwOyBjIDwgY2VudHJvaWRzLmxlbmd0aDsgYysrKSB7XG4gICAgbGFiZWxzW2NdID0ge1xuICAgICAgcG9pbnRzOiBbXSxcbiAgICAgIGNlbnRyb2lkOiBjZW50cm9pZHNbY10sXG4gICAgICBpbmRleGVzOiBbXVxuICAgIH07XG4gIH1cbiAgLy8gRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgZGF0YXNldCwgY2hvb3NlIHRoZSBjbG9zZXN0IGNlbnRyb2lkLiBcbiAgLy8gTWFrZSB0aGF0IGNlbnRyb2lkIHRoZSBlbGVtZW50J3MgbGFiZWwuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YVNldC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGEgPSBkYXRhU2V0W2ldO1xuICAgIGxldCBjbG9zZXN0Q2VudHJvaWQsIGNsb3Nlc3RDZW50cm9pZEluZGV4LCBwcmV2RGlzdGFuY2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjZW50cm9pZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBjZW50cm9pZCA9IGNlbnRyb2lkc1tqXTtcbiAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgIGNsb3Nlc3RDZW50cm9pZCA9IGNlbnRyb2lkO1xuICAgICAgICBjbG9zZXN0Q2VudHJvaWRJbmRleCA9IGo7XG4gICAgICAgIHByZXZEaXN0YW5jZSA9IGdldERpc3RhbmNlU1EoYSwgY2xvc2VzdENlbnRyb2lkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldCBkaXN0YW5jZTpcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBnZXREaXN0YW5jZVNRKGEsIGNlbnRyb2lkKTtcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgcHJldkRpc3RhbmNlKSB7XG4gICAgICAgICAgcHJldkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgY2xvc2VzdENlbnRyb2lkID0gY2VudHJvaWQ7XG4gICAgICAgICAgY2xvc2VzdENlbnRyb2lkSW5kZXggPSBqO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBwb2ludCB0byBjZW50cm9pZCBsYWJlbHM6XG4gICAgbGFiZWxzW2Nsb3Nlc3RDZW50cm9pZEluZGV4XS5wb2ludHMucHVzaChhKTtcbiAgICBsYWJlbHNbY2xvc2VzdENlbnRyb2lkSW5kZXhdLmluZGV4ZXMucHVzaChpKTtcbiAgfVxuICByZXR1cm4gbGFiZWxzO1xufVxuXG5mdW5jdGlvbiBnZXRQb2ludHNNZWFuKHBvaW50TGlzdCkge1xuICBjb25zdCB0b3RhbFBvaW50cyA9IHBvaW50TGlzdC5sZW5ndGg7XG4gIGNvbnN0IG1lYW5zID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgcG9pbnRMaXN0WzBdLmxlbmd0aDsgaisrKSB7XG4gICAgbWVhbnMucHVzaCgwKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBvaW50ID0gcG9pbnRMaXN0W2ldO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcG9pbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHZhbCA9IHBvaW50W2pdO1xuICAgICAgbWVhbnNbal0gPSBtZWFuc1tqXSArIHZhbCAvIHRvdGFsUG9pbnRzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVhbnM7XG59XG5cbmZ1bmN0aW9uIHJlY2FsY3VsYXRlQ2VudHJvaWRzKGRhdGFTZXQsIGxhYmVscywgaykge1xuICAvLyBFYWNoIGNlbnRyb2lkIGlzIHRoZSBnZW9tZXRyaWMgbWVhbiBvZiB0aGUgcG9pbnRzIHRoYXRcbiAgLy8gaGF2ZSB0aGF0IGNlbnRyb2lkJ3MgbGFiZWwuIEltcG9ydGFudDogSWYgYSBjZW50cm9pZCBpcyBlbXB0eSAobm8gcG9pbnRzIGhhdmVcbiAgLy8gdGhhdCBjZW50cm9pZCdzIGxhYmVsKSB5b3Ugc2hvdWxkIHJhbmRvbWx5IHJlLWluaXRpYWxpemUgaXQuXG4gIGxldCBuZXdDZW50cm9pZDtcbiAgY29uc3QgbmV3Q2VudHJvaWRMaXN0ID0gW107XG4gIGZvciAoY29uc3QgayBpbiBsYWJlbHMpIHtcbiAgICBjb25zdCBjZW50cm9pZEdyb3VwID0gbGFiZWxzW2tdO1xuICAgIGlmIChjZW50cm9pZEdyb3VwLnBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBmaW5kIG1lYW46XG4gICAgICBuZXdDZW50cm9pZCA9IGdldFBvaW50c01lYW4oY2VudHJvaWRHcm91cC5wb2ludHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZXQgbmV3IHJhbmRvbSBjZW50cm9pZFxuICAgICAgbmV3Q2VudHJvaWQgPSBnZXRSYW5kb21DZW50cm9pZHMoZGF0YVNldCwgMSlbMF07XG4gICAgfVxuICAgIG5ld0NlbnRyb2lkTGlzdC5wdXNoKG5ld0NlbnRyb2lkKTtcbiAgfVxuICByZXR1cm4gbmV3Q2VudHJvaWRMaXN0O1xufVxuXG5mdW5jdGlvbiBrbWVhbnMoZGF0YXNldCwgaywgdXNlTmFpdmVTaGFyZGluZyA9ICdhdXRvJykge1xuICBpZiAodXNlTmFpdmVTaGFyZGluZyA9PT0gJ2F1dG8nKSB7XG4gICAgdXNlTmFpdmVTaGFyZGluZyA9IChkYXRhc2V0Lmxlbmd0aCAvIGsgPiA0KVxuICB9XG4gIHVzZU5haXZlU2hhcmRpbmcgPSBmYWxzZVxuICAgIC8vICAgY29uc29sZS5sb2coZGF0YXNldClcbiAgaWYgKGRhdGFzZXQubGVuZ3RoICYmIGRhdGFzZXRbMF0ubGVuZ3RoICYmIGRhdGFzZXQubGVuZ3RoID4gaykge1xuICAgIC8vIEluaXRpYWxpemUgYm9vayBrZWVwaW5nIHZhcmlhYmxlc1xuICAgIGxldCBpdGVyYXRpb25zID0gMDtcbiAgICBsZXQgb2xkQ2VudHJvaWRzLCBsYWJlbHMsIGNlbnRyb2lkcztcblxuICAgIC8vIEluaXRpYWxpemUgY2VudHJvaWRzIHJhbmRvbWx5XG4gICAgaWYgKHVzZU5haXZlU2hhcmRpbmcpIHtcbiAgICAgIGNlbnRyb2lkcyA9IGdldFJhbmRvbUNlbnRyb2lkc05haXZlU2hhcmRpbmcoZGF0YXNldCwgayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbnRyb2lkcyA9IGdldFJhbmRvbUNlbnRyb2lkcyhkYXRhc2V0LCBrKTtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coY2VudHJvaWRzKVxuXG4gICAgLy8gUnVuIHRoZSBtYWluIGstbWVhbnMgYWxnb3JpdGhtXG4gICAgd2hpbGUgKCFzaG91bGRTdG9wKG9sZENlbnRyb2lkcywgY2VudHJvaWRzLCBpdGVyYXRpb25zKSkge1xuICAgICAgLy8gU2F2ZSBvbGQgY2VudHJvaWRzIGZvciBjb252ZXJnZW5jZSB0ZXN0LlxuICAgICAgb2xkQ2VudHJvaWRzID0gW10uY29uY2F0KGNlbnRyb2lkcyk7XG4gICAgICBpdGVyYXRpb25zKys7XG5cbiAgICAgIC8vIEFzc2lnbiBsYWJlbHMgdG8gZWFjaCBkYXRhcG9pbnQgYmFzZWQgb24gY2VudHJvaWRzXG4gICAgICBsYWJlbHMgPSBnZXRMYWJlbHMoZGF0YXNldCwgY2VudHJvaWRzKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKG9sZENlbnRyb2lkcylcbiAgICAgIGNlbnRyb2lkcyA9IHJlY2FsY3VsYXRlQ2VudHJvaWRzKGRhdGFzZXQsIGxhYmVscywgayk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhjZW50cm9pZHMpXG4gICAgfVxuXG4gICAgY29uc3QgY2x1c3RlcnMgPSBbXTtcbiAgICBsZXQgZGF0YXNldExhYmVscyA9IG5ldyBBcnJheShkYXRhc2V0Lmxlbmd0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgY2x1c3RlcnMucHVzaChsYWJlbHNbaV0uaW5kZXhlcyk7XG4gICAgICBsYWJlbHNbaV0uaW5kZXhlcy5mb3JFYWNoKGRhdGFzZXRJbmRleCA9PiB7XG4gICAgICAgIGRhdGFzZXRMYWJlbHNbZGF0YXNldEluZGV4XSA9IGlcbiAgICAgIH0pXG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJlc3VsdHMgPSB7XG4gICAgICBkYXRhc2V0TGFiZWxzLFxuICAgICAgY2x1c3RlclZlY3RvcjogZGF0YXNldExhYmVscyxcbiAgICAgIGNsdXN0ZXJzOiBjbHVzdGVycyxcbiAgICAgIGNsdXN0ZXJJbmRleDogY2x1c3RlcnMsXG4gICAgICBjZW50cm9pZHM6IGNlbnRyb2lkcyxcbiAgICAgIGl0ZXJhdGlvbnM6IGl0ZXJhdGlvbnMsXG4gICAgICBjb252ZXJnZWQ6IGl0ZXJhdGlvbnMgPD0gTUFYX0lURVJBVElPTlMsXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGF0YXNldCcpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGttZWFuczsiLCJpbXBvcnQga21lYW5zIGZyb20gJy4va21lYW5zLmpzJ1xyXG5cclxubGV0IEdyb3VwaW5nVG9vbCA9IHtcclxuICBwcm9wczogWydjb25maWcnLCAnbG9jYWxDb25maWcnLCAndXRpbHMnXSxcclxuICBkYXRhICgpIHsgICAgXHJcbiAgICB0aGlzLiRpMThuLmxvY2FsZSA9IHRoaXMubG9jYWxDb25maWcubG9jYWxlXHJcbiAgICByZXR1cm4ge1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgd2F0Y2g6IHtcclxuICAgICdsb2NhbENvbmZpZy5sb2NhbGUnKCkge1xyXG4gICAgICB0aGlzLiRpMThuLmxvY2FsZSA9IHRoaXMubG9jYWxDb25maWcubG9jYWxlO1xyXG4gICAgfSxcclxuICB9LFxyXG4gIC8vIGNvbXB1dGVkOiB7XHJcbiAgICBcclxuICAvLyB9LFxyXG4gIC8vIG1vdW50ZWQ6IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAvLyAgIHRoaXMudGVzdDIwMjIxMDMwMTcyOSgpXHJcbiAgLy8gfSxcclxuICBtZXRob2RzOiB7XHJcbiAgICB0ZXN0MjAyMjEwMzAwMDMzOiBhc3luYyBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAvLyB2YXIgdmVjdG9yID0gW1xyXG4gICAgICAvLyAgIFsxLCAxMCwgMiwgMzBdLFxyXG4gICAgICAvLyAgIFsnQScsIDMwLCAyMCwgMl0sXHJcbiAgICAgIC8vICAgWydCJywgMzAsIDMwLCAzXSxcclxuICAgICAgLy8gICBbJ0MnLCAzMCwgMzEsIDNdLFxyXG4gICAgICAvLyAgIFsnQScsIDEwLCAxMCwgMV0sXHJcbiAgICAgIC8vICAgWydCJywgMjAsIDEsIDMwXSxcclxuICAgICAgLy8gICBbJ0MnLCAxLCAyNSwgMzBdXHJcbiAgICAgIC8vIF1cclxuXHJcbiAgICAgIHZhciB2ZWN0b3IgPSBbXHJcbiAgICAgICAgWzEwLCAyLCAzMF0sXHJcbiAgICAgICAgWzMwLCAyMCwgMl0sXHJcbiAgICAgICAgWzMwLCAzMCwgM10sXHJcbiAgICAgICAgWzMwLCAzMSwgM10sXHJcbiAgICAgICAgWzEwLCAxMCwgMV0sXHJcbiAgICAgICAgWzIwLCAxLCAzMF0sXHJcbiAgICAgICAgWzEsIDI1LCAzMF1cclxuICAgICAgXVxyXG5cclxuXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMudG9WZWN0b3IodmVjdG9yKSlcclxuICAgICAgLy8gY29uc29sZS5sb2coYXdhaXQgdGhpcy5hZGRLbWVhbnModmVjdG9yKSlcclxuICAgICAgLy8gY29uc29sZS5sb2coYXdhaXQgdGhpcy5hZGRHcm91cEluRGlmZmVyZW5jZSh2ZWN0b3IpKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLmFkZEdyb3VwSW5TaW1pbGFyaXR5KHZlY3RvcikpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHZlY3RvcilcclxuICAgICAgY29uc29sZS5sb2coYXdhaXQgdGhpcy5rbWVhbnModmVjdG9yLCAzKSlcclxuICAgIH0sXHJcbiAgICB0ZXN0MjAyMjEwMzAxNzI5OiBhc3luYyBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICB2YXIgdmVjdG9yID0gW1xyXG4gICAgICAgIFsxLCAyLCAzLCAxXSxcclxuICAgICAgICBbNSwyLDMsMV0sXHJcbiAgICAgICAgWzEsMiw0LDBdLFxyXG4gICAgICAgIFs1LDMsNCwwXVxyXG4gICAgICBdXHJcblxyXG5cclxuICAgICAgLy8gY29uc29sZS5sb2coYXdhaXQgdGhpcy50b1ZlY3Rvcih2ZWN0b3IpKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLmFkZEttZWFucyh2ZWN0b3IpKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyh2ZWN0b3IpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMua21lYW5zKHZlY3RvciwgMikpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMuZ3JvdXBpbmdCeVNpbWlsYXJpdHkodmVjdG9yLCAnbWVtYmVyJywgMikpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMuZ3JvdXBpbmdCeURpZmZlcmVuY2UodmVjdG9yLCAnbWVtYmVyJywgMikpXHJcbiAgICB9LFxyXG4gICAgdG9WZWN0b3I6IGFzeW5jIGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgLy8gY29uc29sZS5sb2coZGF0YSlcclxuXHJcblxyXG4gICAgICBsZXQgcm93cyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aClcclxuICAgICAgbGV0IGNvbHVtZUxlbmd0aCA9IGRhdGFbMF0ubGVuZ3RoXHJcblxyXG4gICAgICBmb3IgKGxldCBjID0gdGhpcy5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuc2tpcENvbHVtbnM7IGMgPCBjb2x1bWVMZW5ndGg7IGMrKykge1xyXG4gICAgICAgIGxldCBsaXN0ID0gW11cclxuICAgICAgICBsZXQgaXNDb2x1bW5OdW1iZXIgPSB0cnVlXHJcblxyXG4gICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGF0YS5sZW5ndGg7IGQrKykge1xyXG4gICAgICAgICAgbGV0IHZhbHVlID0gZGF0YVtkXVtjXVxyXG4gICAgICAgICAgbGV0IGlzTnVtYmVyID0gKHR5cGVvZih2YWx1ZSkgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgaWYgKGlzTnVtYmVyID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBpc0NvbHVtbk51bWJlciA9IGZhbHNlXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGlzdC5wdXNoKHZhbHVlKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coaXNDb2x1bW5OdW1iZXIpXHJcblxyXG4gICAgICAgIGlmIChpc0NvbHVtbk51bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgbGV0IG1heCA9IE1hdGgubWF4KC4uLmxpc3QpXHJcbiAgICAgICAgICBsZXQgbWluID0gTWF0aC5taW4oLi4ubGlzdClcclxuICAgICAgICAgIGxldCByYW5nZSA9IG1heCAtIG1pblxyXG4gICAgICAgICAgaWYgKHJhbmdlID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbGV0IG5vcm1hbGl6ZWRcclxuICAgICAgICAgIGlmIChtYXggPT09IDEgJiYgbWluID09PSAwKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBsaXN0XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZCA9IGxpc3QubWFwKHZhbHVlID0+ICgodmFsdWUgLSBtaW4pIC8gcmFuZ2UpKVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgcm93cy5sZW5ndGg7IHIrKykge1xyXG4gICAgICAgICAgICBpZiAoIXJvd3Nbcl0pIHtcclxuICAgICAgICAgICAgICByb3dzW3JdID0gW11cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcm93c1tyXS5wdXNoKG5vcm1hbGl6ZWRbcl0pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgbGV0IG1hcCA9IHt9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGxldCBpZCA9IDBcclxuICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGF0YS5sZW5ndGg7IGQrKykge1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBkYXRhW2RdW2NdXHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAnJ1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh2YWx1ZSlcclxuICAgICAgICAgICAgaWYgKCFtYXBbdmFsdWVdKSB7XHJcbiAgICAgICAgICAgICAgbWFwW3ZhbHVlXSA9IGlkXHJcbiAgICAgICAgICAgICAgaWQrK1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxpc3QucHVzaCh2YWx1ZSlcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhtYXAsIGxpc3QpXHJcblxyXG4gICAgICAgICAgbGV0IHZlY3RvcnMgPSBbXVxyXG4gICAgICAgICAgbGV0IHYgPSBbXVxyXG4gICAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhtYXApXHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdltpXSA9IDBcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHYpXHJcblxyXG4gICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkYXRhLmxlbmd0aDsgZCsrKSB7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFbZF1bY11cclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArICcnXHJcbiAgICAgICAgICAgIGxldCBpID0ga2V5cy5pbmRleE9mKHZhbHVlKVxyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhpKVxyXG4gICAgICAgICAgICBsZXQgdjIgPSBbXS5jb25jYXQodilcclxuICAgICAgICAgICAgdjJbaV0gPSAxXHJcbiAgICAgICAgICAgIHZlY3RvcnMucHVzaCh2MilcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZlY3RvcnMpXHJcblxyXG4gICAgICAgICAgdmVjdG9ycy5mb3JFYWNoKCh2ZWN0b3IsIHIpID0+IHtcclxuICAgICAgICAgICAgaWYgKCFyb3dzW3JdKSB7XHJcbiAgICAgICAgICAgICAgcm93c1tyXSA9IFtdXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm93c1tyXSA9IHJvd3Nbcl0uY29uY2F0KHZlY3RvcilcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhyb3dzKVxyXG5cclxuICAgICAgcmV0dXJuIHJvd3NcclxuICAgIH0sXHJcbiAgICAvLyBrbWVhbnM6IGFzeW5jIGZ1bmN0aW9uIChkYXRhLCBjbHVzdGVyID0gMykge1xyXG4gICAgLy8gICBsZXQgdmVjdG9yID0gYXdhaXQgdGhpcy50b1ZlY3RvcihkYXRhKVxyXG4gICAgLy8gICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgLy8gICAgIC8vIGNvbnNvbGUubG9nKGNsdXN0ZXIpXHJcbiAgICAvLyAgICAga21lYW5zKHZlY3RvciwgY2x1c3RlciwgZnVuY3Rpb24oZXJyLCBjbHVzdGVyVmVjdG9yLCBjbHVzdGVySW5kZXgsIGNsdXN0ZXIsIGNlbnRyb2lkcykge1xyXG4gICAgLy8gICAgICAgaWYgKGVycikge1xyXG4gICAgLy8gICAgICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoZXJyKVxyXG4gICAgLy8gICAgICAgICByZXR1cm4gcmVqZWN0KGVycilcclxuICAgIC8vICAgICAgIH1cclxuICAgICAgXHJcbiAgICAvLyAgICAgICAvL2RvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHRcclxuICAgIC8vICAgICAgIC8vIGNvbnNvbGUubG9nKHJlcylcclxuICAgIC8vICAgICAgIHJlc29sdmUoe1xyXG4gICAgLy8gICAgICAgICBjbHVzdGVyVmVjdG9yLFxyXG4gICAgLy8gICAgICAgICBjbHVzdGVySW5kZXgsXHJcbiAgICAvLyAgICAgICAgIGNsdXN0ZXIsXHJcbiAgICAvLyAgICAgICAgIGNlbnRyb2lkc1xyXG4gICAgLy8gICAgICAgfSlcclxuICAgIC8vICAgICB9KVxyXG4gICAgLy8gICB9KVxyXG4gICAgLy8gICAvLyBjb25zb2xlLmxvZyh2ZWN0b3IpIFxyXG4gICAgLy8gfSxcclxuICAgIGttZWFuczogYXN5bmMgZnVuY3Rpb24gKGRhdGEsIGNsdXN0ZXIgPSAzKSB7XHJcbiAgICAgIGxldCB2ZWN0b3IgPSBhd2FpdCB0aGlzLnRvVmVjdG9yKGRhdGEpXHJcbiAgICAgIC8vIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coY2x1c3RlcilcclxuICAgICAgICAvLyByZXNvdmxlKGttZWFucyh2ZWN0b3IsIGNsdXN0ZXIpKVxyXG4gICAgICAvLyB9KVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyh2ZWN0b3IpIFxyXG4gICAgICBsZXQgcmVzdWx0ID0ga21lYW5zKHZlY3RvciwgY2x1c3RlcilcclxuICAgICAgLy8gY29uc29sZS5sb2cocmVzdWx0KVxyXG4gICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICB9LFxyXG4gICAgYWRkS21lYW5zOiBhc3luYyBmdW5jdGlvbiAodmVjdG9yLCBjbHVzdGVyID0gMykge1xyXG4gICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5rbWVhbnModmVjdG9yLCBjbHVzdGVyKVxyXG5cclxuICAgICAgcmV0dXJuIHZlY3Rvci5tYXAoKGl0ZW0sIGkpID0+IHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhpdGVtLCBpLCByZXN1bHQuY2x1c3RlckluZGV4KVxyXG4gICAgICAgIGl0ZW0ucHVzaChyZXN1bHQuY2x1c3RlclZlY3RvcltpXSlcclxuICAgICAgICByZXR1cm4gaXRlbVxyXG4gICAgICB9KVxyXG4gICAgfSxcclxuICAgIGdyb3VwaW5nQnlEaWZmZXJlbmNlOiBhc3luYyBmdW5jdGlvbiAodmVjdG9yLCBncm91cFR5cGUgPSAnbWVtYmVyJywgbWVtYmVyID0gMykge1xyXG4gICAgICBtZW1iZXIgPSBOdW1iZXIobWVtYmVyKVxyXG5cclxuICAgICAgbGV0IGhlYWRlclJvd3MgPSBbXVxyXG4gICAgICBpZiAodGhpcy5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuc2tpcFJvd3MgPiAwKSB7XHJcbiAgICAgICAgaGVhZGVyUm93cyA9IHZlY3Rvci5zbGljZSgwLCB0aGlzLmxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5za2lwUm93cylcclxuICAgICAgICB2ZWN0b3IgPSB2ZWN0b3Iuc2xpY2UodGhpcy5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuc2tpcFJvd3MpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGxldCB7Y2x1c3RlckluZGV4fSA9IGF3YWl0IHRoaXMua21lYW5zKHZlY3RvciwgbWVtYmVyKVxyXG5cclxuICAgICAgLy8g5ZCI5L216IiH6KiI566X5q+U5L6LXHJcbiAgICAgIGNsdXN0ZXJJbmRleCA9IHRoaXMuYmFsYW5jZUNsdXN0ZXJzKGNsdXN0ZXJJbmRleCwgTWF0aC5jZWlsKHZlY3Rvci5sZW5ndGggLyBtZW1iZXIpLCBNYXRoLmZsb29yKHZlY3Rvci5sZW5ndGggLyBtZW1iZXIpKVxyXG5cclxuICAgICAgLy8gY29uc29sZS5sb2coY2x1c3RlckluZGV4KVxyXG4gICAgICAvLyByZXR1cm4gZmFsc2VcclxuXHJcbiAgICAgIGxldCBncm91cHMgPSBNYXRoLmNlaWwodmVjdG9yLmxlbmd0aCAvIG1lbWJlcilcclxuICAgICAgXHJcbiAgICAgIGlmIChncm91cFR5cGUgPT09ICdncm91cCcpIHtcclxuICAgICAgICBncm91cHMgPSBtZW1iZXJcclxuICAgICAgICBtZW1iZXIgPSBOdW1iZXIoTWF0aC5mbG9vcih2ZWN0b3IubGVuZ3RoIC8gZ3JvdXBzKSlcclxuICAgICAgfVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhncm91cHMsIG1lbWJlcilcclxuICAgICAgXHJcbiAgICAgIGxldCBncm91cEluZGV4TGlzdCA9IFtdXHJcbiAgICAgIGxldCBtb2QgPSB2ZWN0b3IubGVuZ3RoICUgZ3JvdXBzXHJcbiAgICAgIGxldCBtaW5NZW1iZXJzID0gTWF0aC5mbG9vcih2ZWN0b3IubGVuZ3RoIC8gZ3JvdXBzKVxyXG4gICAgICAvLyByZXR1cm4gY29uc29sZS5sb2cobWVtYmVyLCBNYXRoLmZsb29yKHZlY3Rvci5sZW5ndGggLyBncm91cHMpKVxyXG4gICAgICAvLyBsZXQgbWluTWVtYmVycyA9IG1lbWJlclxyXG5cclxuICAgICAgbGV0IGNvdW50ZXIgPSAwXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGdyb3VwcylcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHM7IGkrKykge1xyXG4gICAgICAgIGxldCBncm91cCA9IFtdXHJcblxyXG4gICAgICAgIGxldCBjbHVzdGVySSA9IDBcclxuICAgICAgICBsZXQgYmFzZU1lbWJlciA9IG1pbk1lbWJlcnNcclxuICAgICAgICBpZiAoaSA8IG1vZCkge1xyXG4gICAgICAgICAgYmFzZU1lbWJlcisrXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhiYXNlTWVtYmVyKVxyXG4gICAgICAgIC8vIGNvbnRpbnVlXHJcblxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICBsZXQgdiA9IGNsdXN0ZXJJbmRleFsoY2x1c3RlckkgJSBjbHVzdGVySW5kZXgubGVuZ3RoKV1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coZ3JvdXBzLCBjbHVzdGVySSwgdiwgY291bnRlciwgdmVjdG9yLmxlbmd0aCkgXHJcbiAgICAgICAgICBpZiAodi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY2x1c3RlckkrK1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGxldCByYW5kb21JZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHYubGVuZ3RoKVxyXG4gICAgICAgICAgbGV0IGl0ZW0gPSB2W3JhbmRvbUlkXVxyXG4gICAgICAgICAgZ3JvdXAucHVzaChOdW1iZXIoaXRlbSkpXHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhpdGVtKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICB2LnNwbGljZShyYW5kb21JZCwgMSlcclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZlY3RvcilcclxuICAgICAgICAgIC8vIGNsdXN0ZXJWZWN0b3JbKGNsdXN0ZXJJICUgbWVtYmVyKV0gPSB2XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZXN1bHQuY2x1c3RlclZlY3RvcilcclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHYpXHJcblxyXG4gICAgICAgICAgY2x1c3RlckkrK1xyXG4gICAgICAgICAgY291bnRlcisrXHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjb3VudGVyLCBncm91cC5sZW5ndGgsIG1lbWJlcilcclxuICAgICAgICAgIGlmIChjb3VudGVyID09PSB2ZWN0b3IubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGdyb3VwLmxlbmd0aCA9PT0gYmFzZU1lbWJlcikge1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhncm91cClcclxuICAgICAgICBncm91cEluZGV4TGlzdC5wdXNoKGdyb3VwKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhncm91cEluZGV4TGlzdClcclxuXHJcbiAgICAgIC8vIGxldCBpbnZlcnRHcm91cCA9IG5ldyBBcnJheShncm91cHMpXHJcbiAgICAgIGxldCBvdXRwdXQgPSBbXS5jb25jYXQodmVjdG9yKVxyXG4gICAgICBncm91cEluZGV4TGlzdC5mb3JFYWNoKChsaXN0LCBncm91cElkKSA9PiB7XHJcbiAgICAgICAgbGlzdC5mb3JFYWNoKGluZGV4ID0+IHtcclxuICAgICAgICAgIGxldCBvID0gW10uY29uY2F0KG91dHB1dFtpbmRleF0pXHJcbiAgICAgICAgICBvLnB1c2goZ3JvdXBJZClcclxuICAgICAgICAgIG91dHB1dFtpbmRleF0gPSBvXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuXHJcbiAgICAgIG91dHB1dCA9IGhlYWRlclJvd3MuY29uY2F0KG91dHB1dClcclxuXHJcbiAgICAgIHJldHVybiBvdXRwdXRcclxuICAgIH0sXHJcbiAgICBiYWxhbmNlQ2x1c3RlcnMgKGNsdXN0ZXJJbmRleCwgbWF4TWVtYmVycywgbWluTWVtYmVycykge1xyXG4gICAgICBcclxuICAgICAgLy8gaWYgKG1heE1lbWJlcnMgPT09IG1pbk1lbWJlcnMpIHtcclxuICAgICAgLy8gICBtaW5NZW1iZXJzLS1cclxuICAgICAgLy8gfVxyXG4gICAgICAvLyByZXR1cm4gZmFsc2VcclxuICAgICAgdGhpcy5zb3J0Q2x1c3RlckluZGV4QnlTaXplKGNsdXN0ZXJJbmRleClcclxuICAgICAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoY2x1c3RlckluZGV4LCBudWxsLCAyKSwgbWF4TWVtYmVycywgbWluTWVtYmVycylcclxuXHJcbiAgICAgIHdoaWxlIChjbHVzdGVySW5kZXhbY2x1c3RlckluZGV4Lmxlbmd0aCAtIDFdLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGxldCB0ZW1wQ2x1c3RlciA9IFtdXHJcbiAgICAgICAgbGV0IGxhcmdlc3RDbHVzdGVyID0gY2x1c3RlckluZGV4WzBdXHJcbiAgICAgICAgd2hpbGUgKHRlbXBDbHVzdGVyLmxlbmd0aCA8IG1pbk1lbWJlcnMpIHtcclxuICAgICAgICAgIGxldCByYW5kb21JZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxhcmdlc3RDbHVzdGVyLmxlbmd0aClcclxuICAgICAgICAgIHRlbXBDbHVzdGVyLnB1c2gobGFyZ2VzdENsdXN0ZXJbcmFuZG9tSWRdKVxyXG4gICAgICAgICAgbGFyZ2VzdENsdXN0ZXIuc3BsaWNlKHJhbmRvbUlkLCAxKVxyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2codGVtcENsdXN0ZXIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsdXN0ZXJJbmRleFswXSA9IGxhcmdlc3RDbHVzdGVyXHJcbiAgICAgICAgY2x1c3RlckluZGV4WyhjbHVzdGVySW5kZXgubGVuZ3RoIC0gMSldID0gdGVtcENsdXN0ZXJcclxuXHJcbiAgICAgICAgdGhpcy5zb3J0Q2x1c3RlckluZGV4QnlTaXplKGNsdXN0ZXJJbmRleClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY29uc29sZS5sb2coY2x1c3RlckluZGV4KVxyXG4gICAgICBsZXQgaXNWYWxpZCA9IHRydWVcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbHVzdGVySW5kZXgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoY2x1c3RlckluZGV4W2ldLmxlbmd0aCA+IG1heE1lbWJlcnMpIHtcclxuICAgICAgICAgIGlzVmFsaWQgPSAxXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2x1c3RlckluZGV4W2ldLmxlbmd0aCA8IG1pbk1lbWJlcnMpIHtcclxuICAgICAgICAgIGlzVmFsaWQgPSAyXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgXHJcbiAgICAgIGlmIChpc1ZhbGlkID09PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNsdXN0ZXJJbmRleFxyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGlzVmFsaWQgPT09IDEpIHtcclxuICAgICAgICAvLyDmnIDlsI/nmoTvvIzlkIjkvbVcclxuICAgICAgICBsZXQgbGVuID0gY2x1c3RlckluZGV4Lmxlbmd0aFxyXG4gICAgICAgIGxldCBtaW5DbHVzdGVyID0gY2x1c3RlckluZGV4WyhsZW4gLSAxKV1cclxuICAgICAgICBsZXQgYmFzZUluZGV4ID0gKGxlbiAtIDIpXHJcbiAgICAgICAgd2hpbGUgKGNsdXN0ZXJJbmRleFtiYXNlSW5kZXhdLmxlbmd0aCA8IG1heE1lbWJlcnMpIHtcclxuICAgICAgICAgIGxldCByYW5kb21JZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1pbkNsdXN0ZXIubGVuZ3RoKVxyXG4gICAgICAgICAgY2x1c3RlckluZGV4W2Jhc2VJbmRleF0ucHVzaChtaW5DbHVzdGVyW3JhbmRvbUlkXSlcclxuICAgICAgICAgIG1pbkNsdXN0ZXIuc3BsaWNlKHJhbmRvbUlkLCAxKVxyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2codGVtcENsdXN0ZXIpXHJcblxyXG4gICAgICAgICAgaWYgKG1pbkNsdXN0ZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoY2x1c3RlckluZGV4W2Jhc2VJbmRleF0ubGVuZ3RoID09PSBtYXhNZW1iZXJzICYmIFxyXG4gICAgICAgICAgICAgIG1pbkNsdXN0ZXIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBiYXNlSW5kZXgtLVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChiYXNlSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGNsdXN0ZXJJbmRleFsobGVuIC0gMildID0gY2x1c3RlckluZGV4WyhsZW4gLSAyKV0uY29uY2F0KGNsdXN0ZXJJbmRleFsobGVuIC0gMSldKVxyXG5cclxuICAgICAgICAvLyDmnIDlpKfnmoTvvIzmi4bkuIDljYpcclxuICAgICAgICBsZXQgdGVtcENsdXN0ZXIgPSBbXS5jb25jYXQobWluQ2x1c3RlcilcclxuICAgICAgICBsZXQgbGFyZ2VzdENsdXN0ZXIgPSBjbHVzdGVySW5kZXhbMF1cclxuICAgICAgICB3aGlsZSAodGVtcENsdXN0ZXIubGVuZ3RoIDwgbWluTWVtYmVycykge1xyXG4gICAgICAgICAgbGV0IHJhbmRvbUlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGFyZ2VzdENsdXN0ZXIubGVuZ3RoKVxyXG4gICAgICAgICAgdGVtcENsdXN0ZXIucHVzaChsYXJnZXN0Q2x1c3RlcltyYW5kb21JZF0pXHJcbiAgICAgICAgICBsYXJnZXN0Q2x1c3Rlci5zcGxpY2UocmFuZG9tSWQsIDEpXHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0ZW1wQ2x1c3RlcilcclxuICAgICAgICB9XHJcbiAgICAgICAgY2x1c3RlckluZGV4WzBdID0gbGFyZ2VzdENsdXN0ZXJcclxuICAgICAgICBjbHVzdGVySW5kZXhbKGxlbiAtIDEpXSA9IHRlbXBDbHVzdGVyXHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGNsdXN0ZXJJbmRleClcclxuICAgICAgICAvLyByZXR1cm4gZmFsc2VcclxuICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlQ2x1c3RlcnMoY2x1c3RlckluZGV4LCBtYXhNZW1iZXJzLCBtaW5NZW1iZXJzKVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIOacgOWwj+eahO+8jOWQiOS9tVxyXG4gICAgICAgIGxldCBsZW4gPSBjbHVzdGVySW5kZXgubGVuZ3RoXHJcbiAgICAgICAgbGV0IG1heENsdXN0ZXIgPSBjbHVzdGVySW5kZXhbMF1cclxuICAgICAgICBsZXQgcmFuZG9tSWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXhDbHVzdGVyLmxlbmd0aClcclxuICAgICAgICBjbHVzdGVySW5kZXhbKGxlbiAtIDEpXS5wdXNoKG1heENsdXN0ZXJbcmFuZG9tSWRdKVxyXG4gICAgICAgIG1heENsdXN0ZXIuc3BsaWNlKHJhbmRvbUlkLCAxKVxyXG4gICAgICAgIGNsdXN0ZXJJbmRleFswXSA9IG1heENsdXN0ZXJcclxuICAgICAgICAvLyBsZXQgYmFzZUluZGV4ID0gKGxlbiAtIDIpXHJcbiAgICAgICAgLy8gd2hpbGUgKGNsdXN0ZXJJbmRleFtiYXNlSW5kZXhdLmxlbmd0aCA8IG1heE1lbWJlcnMpIHtcclxuICAgICAgICAvLyAgIGxldCByYW5kb21JZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1pbkNsdXN0ZXIubGVuZ3RoKVxyXG4gICAgICAgIC8vICAgY2x1c3RlckluZGV4W2Jhc2VJbmRleF0ucHVzaChtaW5DbHVzdGVyW3JhbmRvbUlkXSlcclxuICAgICAgICAvLyAgIG1pbkNsdXN0ZXIuc3BsaWNlKHJhbmRvbUlkLCAxKVxyXG4gICAgICAgIC8vICAgLy8gY29uc29sZS5sb2codGVtcENsdXN0ZXIpXHJcblxyXG4gICAgICAgIC8vICAgaWYgKG1pbkNsdXN0ZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgLy8gICAgIGJyZWFrXHJcbiAgICAgICAgLy8gICB9XHJcbiAgICAgICAgLy8gICBpZiAoY2x1c3RlckluZGV4W2Jhc2VJbmRleF0ubGVuZ3RoID09PSBtYXhNZW1iZXJzICYmIFxyXG4gICAgICAgIC8vICAgICAgIG1pbkNsdXN0ZXIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vICAgICBiYXNlSW5kZXgtLVxyXG4gICAgICAgIC8vICAgfVxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyAvLyBjbHVzdGVySW5kZXhbKGxlbiAtIDIpXSA9IGNsdXN0ZXJJbmRleFsobGVuIC0gMildLmNvbmNhdChjbHVzdGVySW5kZXhbKGxlbiAtIDEpXSlcclxuXHJcbiAgICAgICAgLy8gLy8g5pyA5aSn55qE77yM5ouG5LiA5Y2KXHJcbiAgICAgICAgLy8gbGV0IHRlbXBDbHVzdGVyID0gW11cclxuICAgICAgICAvLyBsZXQgbGFyZ2VzdENsdXN0ZXIgPSBjbHVzdGVySW5kZXhbMF1cclxuICAgICAgICAvLyB3aGlsZSAodGVtcENsdXN0ZXIubGVuZ3RoIDwgbWluTWVtYmVycykge1xyXG4gICAgICAgIC8vICAgbGV0IHJhbmRvbUlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGFyZ2VzdENsdXN0ZXIubGVuZ3RoKVxyXG4gICAgICAgIC8vICAgdGVtcENsdXN0ZXIucHVzaChsYXJnZXN0Q2x1c3RlcltyYW5kb21JZF0pXHJcbiAgICAgICAgLy8gICBsYXJnZXN0Q2x1c3Rlci5zcGxpY2UocmFuZG9tSWQsIDEpXHJcbiAgICAgICAgLy8gICAvLyBjb25zb2xlLmxvZyh0ZW1wQ2x1c3RlcilcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gY2x1c3RlckluZGV4WzBdID0gbGFyZ2VzdENsdXN0ZXJcclxuICAgICAgICAvLyBjbHVzdGVySW5kZXhbKGxlbiAtIDEpXSA9IHRlbXBDbHVzdGVyXHJcblxyXG4gICAgICAgIC8vIC8vIGNvbnNvbGUubG9nKGNsdXN0ZXJJbmRleClcclxuICAgICAgICAvLyByZXR1cm4gZmFsc2VcclxuICAgICAgICByZXR1cm4gdGhpcy5iYWxhbmNlQ2x1c3RlcnMoY2x1c3RlckluZGV4LCBtYXhNZW1iZXJzLCBtaW5NZW1iZXJzKVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgZ3JvdXBpbmdCeVNpbWlsYXJpdHk6IGFzeW5jIGZ1bmN0aW9uICh2ZWN0b3IsIGdyb3VwVHlwZSA9ICdtZW1iZXInLCBtZW1iZXIgPSAzKSB7XHJcbiAgICAgIG1lbWJlciA9IE51bWJlcihtZW1iZXIpXHJcblxyXG4gICAgICBsZXQgaGVhZGVyUm93cyA9IFtdXHJcbiAgICAgIGlmICh0aGlzLmxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5za2lwUm93cyA+IDApIHtcclxuICAgICAgICBoZWFkZXJSb3dzID0gdmVjdG9yLnNsaWNlKDAsIHRoaXMubG9jYWxDb25maWcuR3JvdXBpbmdUb29sLnNraXBSb3dzKVxyXG4gICAgICAgIHZlY3RvciA9IHZlY3Rvci5zbGljZSh0aGlzLmxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5za2lwUm93cylcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IGdyb3VwcyA9IE1hdGguY2VpbCh2ZWN0b3IubGVuZ3RoIC8gbWVtYmVyKVxyXG5cclxuICAgICAgaWYgKGdyb3VwVHlwZSA9PT0gJ2dyb3VwJykge1xyXG4gICAgICAgIGdyb3VwcyA9IG1lbWJlclxyXG4gICAgICAgIG1lbWJlciA9IE1hdGguY2VpbCh2ZWN0b3IubGVuZ3RoIC8gZ3JvdXBzKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhncm91cHMsIG1lbWJlcilcclxuXHJcbiAgICAgIGxldCB7Y2x1c3RlckluZGV4fSA9IGF3YWl0IHRoaXMua21lYW5zKHZlY3RvciwgZ3JvdXBzKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhjbHVzdGVySW5kZXgpIFxyXG4gICAgICB0aGlzLnNvcnRDbHVzdGVySW5kZXhCeVNpemUoY2x1c3RlckluZGV4KVxyXG4gICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGxldCBpc0ZpbmlzaCA9IHRydWVcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsdXN0ZXJJbmRleC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IGxpc3QgPSBjbHVzdGVySW5kZXhbaV1cclxuICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA8PSBtZW1iZXIgJiYgbGlzdC5sZW5ndGggPj0gbWVtYmVyIC0gMSkge1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlzRmluaXNoID0gZmFsc2VcclxuXHJcbiAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPiBtZW1iZXIpIHtcclxuICAgICAgICAgICAgbGV0IHJhbmRvbUlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGlzdC5sZW5ndGgpXHJcbiAgICAgICAgICAgIGNsdXN0ZXJJbmRleFsoY2x1c3RlckluZGV4Lmxlbmd0aCAtIDEpXS5wdXNoKGxpc3RbcmFuZG9tSWRdKVxyXG4gICAgICAgICAgICBsaXN0LnNwbGljZShyYW5kb21JZCwgMSlcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgcmFuZG9tSWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjbHVzdGVySW5kZXhbMF0ubGVuZ3RoKVxyXG4gICAgICAgICAgICBjbHVzdGVySW5kZXhbaV0ucHVzaChjbHVzdGVySW5kZXhbMF1bcmFuZG9tSWRdKVxyXG4gICAgICAgICAgICBjbHVzdGVySW5kZXhbMF0uc3BsaWNlKHJhbmRvbUlkLCAxKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICB0aGlzLnNvcnRDbHVzdGVySW5kZXhCeVNpemUoY2x1c3RlckluZGV4KVxyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBpZiAoaXNGaW5pc2gpIHtcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICB9XHJcblxyXG4gICAgICBPYmplY3Qua2V5cyhjbHVzdGVySW5kZXgpLmZvckVhY2goZ3JvdXBJZCA9PiB7XHJcbiAgICAgICAgY2x1c3RlckluZGV4W2dyb3VwSWRdLmZvckVhY2goaSA9PiB7XHJcbiAgICAgICAgICB2ZWN0b3JbaV0ucHVzaChOdW1iZXIoZ3JvdXBJZCkpXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHZlY3RvciA9IGhlYWRlclJvd3MuY29uY2F0KHZlY3RvcilcclxuXHJcbiAgICAgIHJldHVybiB2ZWN0b3JcclxuICAgIH0sXHJcbiAgICBzb3J0Q2x1c3RlckluZGV4QnlTaXplIChjbHVzdGVySW5kZXgpIHtcclxuICAgICAgY2x1c3RlckluZGV4LnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aFxyXG4gICAgICB9KVxyXG4gICAgfSxcclxuICAgIHJlbW92ZUxhc3RDb2x1bW4gKCkge1xyXG4gICAgICBsZXQgZGF0YSA9IHRoaXMuJHBhcmVudC5kYXRhTWF0cml4XHJcbiAgICAgIGxldCBoZWFkZXJSb3dzID0gW11cclxuICAgICAgaWYgKHRoaXMubG9jYWxDb25maWcuR3JvdXBpbmdUb29sLnNraXBSb3dzID4gMCkge1xyXG4gICAgICAgIGhlYWRlclJvd3MgPSBkYXRhLnNsaWNlKDAsIHRoaXMubG9jYWxDb25maWcuR3JvdXBpbmdUb29sLnNraXBSb3dzKVxyXG4gICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKHRoaXMubG9jYWxDb25maWcuR3JvdXBpbmdUb29sLnNraXBSb3dzKVxyXG4gICAgICB9XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEpXHJcbiAgICAgIGRhdGEgPSBkYXRhLm1hcChyb3cgPT4gcm93LnNsaWNlKDAsIHJvdy5sZW5ndGggLSAxKSlcclxuICAgICAgZGF0YSA9IGhlYWRlclJvd3MuY29uY2F0KGRhdGEpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEpXHJcbiAgICAgIHRoaXMubG9jYWxDb25maWcudGV4dENvbnRlbnQgPSBkYXRhLm1hcChsaW5lID0+IGxpbmUuam9pbignXFx0JykpLmpvaW4oJ1xcbicpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHcm91cGluZ1Rvb2wiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTYhLi9Hcm91cGluZ1Rvb2wuanM/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tNiEuL0dyb3VwaW5nVG9vbC5qcz92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vR3JvdXBpbmdUb29sLmh0bWw/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWQwNjZiYzAmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vR3JvdXBpbmdUb29sLmpzP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9Hcm91cGluZ1Rvb2wuanM/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vR3JvdXBpbmdUb29sLmxlc3M/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xZDA2NmJjMCZsYW5nPWxlc3Mmc2NvcGVkPXRydWUmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjFkMDY2YmMwXCIsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGN1c3RvbSBibG9ja3MgKi9cbmltcG9ydCBibG9jazAgZnJvbSBcIi4vR3JvdXBpbmdUb29sLnlhbWw/dnVlJnR5cGU9Y3VzdG9tJmluZGV4PTAmYmxvY2tUeXBlPWkxOG4maXNzdWVyUGF0aD0lMkZhcHAlMkZzcmMlMkZjb21wb25lbnRzJTJGUmVwbGFjZVBhbmVsJTJGR3JvdXBpbmdUb29sJTJGR3JvdXBpbmdUb29sLnZ1ZSZsYW5nPXlhbWxcIlxuaWYgKHR5cGVvZiBibG9jazAgPT09ICdmdW5jdGlvbicpIGJsb2NrMChjb21wb25lbnQpXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiL2FwcC9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCcxZDA2NmJjMCcpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCcxZDA2NmJjMCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCcxZDA2NmJjMCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vR3JvdXBpbmdUb29sLmh0bWw/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWQwNjZiYzAmc2NvcGVkPXRydWUmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignMWQwNjZiYzAnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1JlcGxhY2VQYW5lbC9Hcm91cGluZ1Rvb2wvR3JvdXBpbmdUb29sLnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQy9JQTtBQUVBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFKQTtBQUFBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQ25PQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBbkZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF5RkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQSw2QkFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUFBO0FBNUNBO0FBQUE7QUFBQTtBQUFBO0FBK0NBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQSw2QkFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQUE7QUFBQTtBQXBCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBeUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQ3BnQkE7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBaUJBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///424\n')}}]);