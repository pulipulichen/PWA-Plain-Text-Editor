(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{114:function(module,exports,__webpack_require__){eval("var content = __webpack_require__(386);\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(7)(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz85MGFmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0zIS4vR3JvdXBpbmdUb29sLmxlc3M/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xZDA2NmJjMCZsYW5nPWxlc3Mmc2NvcGVkPXRydWUmXCIpO1xuXG5pZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbn1cblxudmFyIG9wdGlvbnMgPSB7fVxuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZiAoY29udGVudC5sb2NhbHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///114\n")},115:function(module,exports){eval('module.exports = function (Component) {\n  Component.options.__i18n = Component.options.__i18n || []\n  Component.options.__i18n.push(\'{"en-US":{"Search":"Search"},"zh-TW":{"Search":"搜尋"}}\')\n  delete Component.options._Ctor\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wueWFtbD8xOGVhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICBDb21wb25lbnQub3B0aW9ucy5fX2kxOG4gPSBDb21wb25lbnQub3B0aW9ucy5fX2kxOG4gfHwgW11cbiAgQ29tcG9uZW50Lm9wdGlvbnMuX19pMThuLnB1c2goJ3tcImVuLVVTXCI6e1wiU2VhcmNoXCI6XCJTZWFyY2hcIn0sXCJ6aC1UV1wiOntcIlNlYXJjaFwiOlwi5pCc5bCLXCJ9fScpXG4gIGRlbGV0ZSBDb21wb25lbnQub3B0aW9ucy5fQ3RvclxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///115\n')},385:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(114);\n/* harmony import */ var _node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz82YzliIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMyEuL0dyb3VwaW5nVG9vbC5sZXNzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MWQwNjZiYzAmbGFuZz1sZXNzJnNjb3BlZD10cnVlJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTMhLi9Hcm91cGluZ1Rvb2wubGVzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFkMDY2YmMwJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///385\n")},386:function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(6)(true);\n// Module\nexports.push([module.i, "input[data-v-1d066bc0]{width:5rem!important}select[data-v-1d066bc0]{width:auto!important}", "",{"version":3,"sources":["/app/src/components/ReplacePanel/GroupingTool/GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&","/app/src/components/ReplacePanel/GroupingTool/GroupingTool.less"],"names":[],"mappings":"AAAA,uBACE,oBCCF,CDMA,wBACE,oBCJF","file":"GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&","sourcesContent":["input {\\n  width: 5rem !important;\\n}\\n\\n// .GroupingTool {\\n//   margin-top: 0.2rem !important;\\n// }\\n\\nselect {\\n  width: auto !important;\\n}","input {\\n  width: 5rem !important;\\n}\\nselect {\\n  width: auto !important;\\n}\\n"]}]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz81MWRiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKHRydWUpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJpbnB1dFtkYXRhLXYtMWQwNjZiYzBde3dpZHRoOjVyZW0haW1wb3J0YW50fXNlbGVjdFtkYXRhLXYtMWQwNjZiYzBde3dpZHRoOmF1dG8haW1wb3J0YW50fVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHAvc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFkMDY2YmMwJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIixcIi9hcHAvc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSx1QkFDRSxvQkNDRixDRE1BLHdCQUNFLG9CQ0pGXCIsXCJmaWxlXCI6XCJHcm91cGluZ1Rvb2wubGVzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFkMDY2YmMwJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIixcInNvdXJjZXNDb250ZW50XCI6W1wiaW5wdXQge1xcbiAgd2lkdGg6IDVyZW0gIWltcG9ydGFudDtcXG59XFxuXFxuLy8gLkdyb3VwaW5nVG9vbCB7XFxuLy8gICBtYXJnaW4tdG9wOiAwLjJyZW0gIWltcG9ydGFudDtcXG4vLyB9XFxuXFxuc2VsZWN0IHtcXG4gIHdpZHRoOiBhdXRvICFpbXBvcnRhbnQ7XFxufVwiLFwiaW5wdXQge1xcbiAgd2lkdGg6IDVyZW0gIWltcG9ydGFudDtcXG59XFxuc2VsZWN0IHtcXG4gIHdpZHRoOiBhdXRvICFpbXBvcnRhbnQ7XFxufVxcblwiXX1dKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///386\n')},387:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(115);\n/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__);\n /* harmony default export */ __webpack_exports__["default"] = (_node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wueWFtbD8zYWFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BrYXp1cG9uL3Z1ZS1pMThuLWxvYWRlci9saWIvaW5kZXguanMhLi9Hcm91cGluZ1Rvb2wueWFtbD92dWUmdHlwZT1jdXN0b20maW5kZXg9MCZibG9ja1R5cGU9aTE4biZpc3N1ZXJQYXRoPSUyRmFwcCUyRnNyYyUyRmNvbXBvbmVudHMlMkZSZXBsYWNlUGFuZWwlMkZHcm91cGluZ1Rvb2wlMkZHcm91cGluZ1Rvb2wudnVlJmxhbmc9eWFtbFwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2F6dXBvbi92dWUtaTE4bi1sb2FkZXIvbGliL2luZGV4LmpzIS4vR3JvdXBpbmdUb29sLnlhbWw/dnVlJnR5cGU9Y3VzdG9tJmluZGV4PTAmYmxvY2tUeXBlPWkxOG4maXNzdWVyUGF0aD0lMkZhcHAlMkZzcmMlMkZjb21wb25lbnRzJTJGUmVwbGFjZVBhbmVsJTJGR3JvdXBpbmdUb29sJTJGR3JvdXBpbmdUb29sLnZ1ZSZsYW5nPXlhbWxcIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///387\n')},424:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./src/components/ReplacePanel/GroupingTool/GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c("div", { staticClass: "GroupingTool" }, [\n    _c("div", { staticClass: "fields" }, [\n      _c(\n        "select",\n        {\n          directives: [\n            {\n              name: "model",\n              rawName: "v-model",\n              value: _vm.localConfig.GroupingTool.groupType,\n              expression: "localConfig.GroupingTool.groupType"\n            }\n          ],\n          on: {\n            change: function($event) {\n              var $$selectedVal = Array.prototype.filter\n                .call($event.target.options, function(o) {\n                  return o.selected\n                })\n                .map(function(o) {\n                  var val = "_value" in o ? o._value : o.value\n                  return val\n                })\n              _vm.$set(\n                _vm.localConfig.GroupingTool,\n                "groupType",\n                $event.target.multiple ? $$selectedVal : $$selectedVal[0]\n              )\n            }\n          }\n        },\n        [\n          _c("option", { attrs: { value: "group" } }, [\n            _vm._v(_vm._s(_vm.$t("Group: ")))\n          ]),\n          _vm._v(" "),\n          _c("option", { attrs: { value: "member" } }, [\n            _vm._v(_vm._s(_vm.$t("Member: ")))\n          ])\n        ]\n      ),\n      _vm._v(" "),\n      _c("input", {\n        directives: [\n          {\n            name: "model",\n            rawName: "v-model",\n            value: _vm.localConfig.GroupingTool.groupLength,\n            expression: "localConfig.GroupingTool.groupLength"\n          }\n        ],\n        attrs: { type: "number" },\n        domProps: { value: _vm.localConfig.GroupingTool.groupLength },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig.GroupingTool,\n              "groupLength",\n              $event.target.value\n            )\n          }\n        }\n      })\n    ])\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js\nvar helpers_typeof = __webpack_require__(1);\nvar typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__(2);\nvar asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);\n\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/kmeans.js\n// Initialize\n// ----------\nfunction Kmeans(vector, k, callback) {\n  //**Vector:** array of arrays. Inner array\n  //represents a multidimensional data point (vector)  \n  //*These should be normalized*\n  this.callback = callback;\n  this.vector = vector;\n  //**K:** represents the number of groups/clusters into \n  //which the vectors will be grouped\n  this.k = k;\n  //Initialize the centroids and clusters     \n  //**Centroids:** represent the center of each cluster. \n  //They are taken by averaging each dimension of the vectors\n  this.centroids = new Array(k);\n  this.cluster = new Array(k);\n  this.clusterIndex = new Array(this.vector.length);\n  // console.log(this.cluster)\n  //Create centroids and place them randomly because \n  //we don\'t yet know where the vectors are most concentrated\n  this.createCentroids();\n  var count = 0,\n    notFinished = true;\n  this.iterate(this.centroids.slice(0));\n}\n\n// Assign vector to each centroid\n// ----------\n// Randomly choose **k** vectors from the vector \n// array **vector**. These represent our guess \n// at where clusters may exist. \nKmeans.prototype.createCentroids = function () {\n  var randomArray = this.vector.slice(0);\n  var self = this;\n  randomArray.sort(function () {\n    return Math.floor(Math.random() * self.vector.length);\n  });\n  this.centroids = randomArray.slice(0, this.k);\n};\n\n// Recursively cluster and move the centroids\n// ----------\n//This method groups vectors into clusters and then determine the \n//the new location for each centroid based upon the mean\n//location of the vectors in the cooresponding cluster\nKmeans.prototype.iterate = function (vecArray) {\n  this.cluster = new Array(this.k);\n  this.clusterIndex = new Array(this.k);\n  this.clusterVector = new Array(vecArray.length);\n  // console.logt(his.cluster)\n  var tempArray = [];\n  for (var a = 0; a < this.vector[0].length; a++) {\n    tempArray.push(0);\n  }\n  var vecArray = [];\n  for (var a = 0; a < this.k; a++) {\n    vecArray[a] = tempArray.slice(0);\n  }\n  //Group each vector to a cluster based upon the \n  //cooresponding centroid\n  // console.log(vecArray.length)\n  for (var i in this.vector) {\n    var v = this.vector[i].slice(0);\n    // console.log(v)\n    var index = this.assignCentroid(v);\n    // console.log(index)\n    if (!Array.isArray(this.cluster[index])) {\n      this.cluster[index] = [];\n      this.clusterIndex[index] = [];\n    }\n    // console.log(index, this.cluster[index])\n    this.cluster[index].push(v);\n    // console.log(2, index)\n    this.clusterIndex[index].push(i);\n    // console.log(index)\n    this.clusterVector[i] = Number(index);\n    // console.log(this.cluster)\n    for (var a = 0; a < v.length; a++) {\n      vecArray[index][a] += v[a]; //keep a sum for cluster\n    }\n  }\n  // console.log(vecArray)\n  //Calculate the mean values for each cluster.\n  var distance,\n    max = 0;\n  for (var a = 0; a < this.k; a++) {\n    var clusterSize = 0; //cluster is empty\n    if (this.cluster[a]) clusterSize = this.cluster[a].length;\n    for (var b in vecArray[a]) {\n      vecArray[a][b] = vecArray[a][b] / clusterSize;\n    }\n    distance = this.distance(vecArray[a], this.centroids[a]);\n    if (distance > max) max = distance;\n  }\n  // console.log(this.cluster)\n  if (max <= 0.5) {\n    // console.log(this.cluster)\n    return this.callback(null, this.clusterVector, this.clusterIndex, this.cluster, this.centroids);\n  }\n\n  //For each centroid use the mean calculated for the \n  //corresponding cluster (effectively "moving" the centroid\n  //to its new "location")\n  for (var z in vecArray) {\n    this.centroids[z] = vecArray[z].slice(0);\n  }\n  this.iterate(vecArray);\n};\n\n// Determine the closest centroid to a vector\n// ----------\nKmeans.prototype.assignCentroid = function (point) {\n  var min = Infinity,\n    res = 0;\n\n  //For each vector we determine the distance to the \n  //nearest centroid. The vector is assigned to the \n  //cluster that corresponds to the nearest centroid.\n  for (var i in this.centroids) {\n    var dist = this.distance(point, this.centroids[i]);\n    if (dist < min) {\n      min = dist;\n      res = i;\n    }\n  }\n  return Number(res);\n};\n\n// Calculate euclidian distance between vectors\n// ----------\nKmeans.prototype.distance = function (v1, v2) {\n  var total = 0;\n  for (var c in v1) {\n    if (c != 0) total += Math.pow(v2[c] - v1[c], 2);\n  }\n  return Math.sqrt(total);\n};\n\n// kmeans.js 0.0.1\n\n//The kmeans clustering algorithm relies upon knowing in advance\n//the number of clusters in which to place vectors. \n\n// Expose \n// ----------\n\n//Expose our library to be called externally\n/* harmony default export */ var GroupingTool_kmeans = (function (vector, k, callback) {\n  if (!vector || !k || !callback) throw new Error("Provide 3 arguments: callback, vector, clusters");\n  return new Kmeans(vector, k, callback);\n});\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--6!./src/components/ReplacePanel/GroupingTool/GroupingTool.js?vue&type=script&lang=js&\n\n\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof_default()(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nvar GroupingTool = {\n  props: [\'config\', \'localConfig\', \'utils\'],\n  data: function data() {\n    this.$i18n.locale = this.localConfig.locale;\n    return {};\n  },\n  watch: {\n    \'localConfig.locale\': function localConfigLocale() {\n      this.$i18n.locale = this.localConfig.locale;\n    }\n  },\n  // computed: {\n\n  // },\n  // mounted: async function () {\n  // },\n  methods: {\n    test202210300033: function () {\n      var _test = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var vector;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                vector = [[1, 10, 2, 30], [\'A\', 30, 20, 2], [\'B\', 30, 30, 3], [\'C\', 30, 31, 3], [\'A\', 10, 10, 1], [\'B\', 20, 1, 30], [\'C\', 1, 25, 30]]; // console.log(await this.toVector(vector))\n                _context.t0 = console;\n                _context.next = 4;\n                return this.addKmeans(vector);\n              case 4:\n                _context.t1 = _context.sent;\n                _context.t0.log.call(_context.t0, _context.t1);\n                _context.t2 = console;\n                _context.next = 9;\n                return this.addGroupInDifference(vector);\n              case 9:\n                _context.t3 = _context.sent;\n                _context.t2.log.call(_context.t2, _context.t3);\n                _context.t4 = console;\n                _context.next = 14;\n                return this.addGroupInSimilarity(vector);\n              case 14:\n                _context.t5 = _context.sent;\n                _context.t4.log.call(_context.t4, _context.t5);\n              case 16:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function test202210300033() {\n        return _test.apply(this, arguments);\n      }\n      return test202210300033;\n    }(),\n    toVector: function () {\n      var _toVector = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(data) {\n        var rows, columeLength, c, list, isColumnNumber, d, value, isNumber, _ret, map, id, _d, _value, vectors, v, i, _d2, _value2, _i, v2;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                rows = new Array(data.length);\n                columeLength = data[0].length;\n                c = 0;\n              case 3:\n                if (!(c < columeLength)) {\n                  _context2.next = 36;\n                  break;\n                }\n                list = [];\n                isColumnNumber = true;\n                d = 0;\n              case 7:\n                if (!(d < data.length)) {\n                  _context2.next = 19;\n                  break;\n                }\n                value = data[d][c];\n                isNumber = typeof value === \'number\';\n                if (!(isNumber === false)) {\n                  _context2.next = 15;\n                  break;\n                }\n                isColumnNumber = false;\n                return _context2.abrupt("break", 19);\n              case 15:\n                list.push(value);\n              case 16:\n                d++;\n                _context2.next = 7;\n                break;\n              case 19:\n                if (!(isColumnNumber === true)) {\n                  _context2.next = 25;\n                  break;\n                }\n                _ret = function () {\n                  var max = Math.max.apply(Math, list);\n                  var min = Math.min.apply(Math, list);\n                  var range = max - min;\n                  if (range === 0) {\n                    return "continue";\n                  }\n                  var normalized = void 0;\n                  if (max === 1 && min === 0) {\n                    normalized = list.map(function (value) {\n                      return (value - min) / range;\n                    });\n                  } else {\n                    normalized = list;\n                  }\n                  for (var r = 0; r < rows.length; r++) {\n                    if (!rows[r]) {\n                      rows[r] = [];\n                    }\n                    rows[r].push(normalized[r]);\n                  }\n                }();\n                if (!(_ret === "continue")) {\n                  _context2.next = 23;\n                  break;\n                }\n                return _context2.abrupt("continue", 33);\n              case 23:\n                _context2.next = 33;\n                break;\n              case 25:\n                map = {};\n                id = 0;\n                for (_d = 0; _d < data.length; _d++) {\n                  _value = data[_d][c];\n                  _value = _value + \'\';\n                  // console.log(value)\n                  if (!map[_value]) {\n                    map[_value] = id;\n                    id++;\n                  }\n                  list.push(_value);\n                }\n\n                // console.log(map, list)\n                vectors = [];\n                v = [];\n                for (i = 0; i < Object.keys(map).length; i++) {\n                  v[i] = 0;\n                }\n                // console.log(v)\n                for (_d2 = 0; _d2 < data.length; _d2++) {\n                  _value2 = data[_d2][c];\n                  _value2 = _value2 + \'\';\n                  _i = map[_value2]; // console.log(i)\n                  v2 = [].concat(v);\n                  v2[_i] = 1;\n                  vectors.push(v2);\n                }\n                // console.log(vectors)\n\n                vectors.forEach(function (vector, r) {\n                  if (!rows[r]) {\n                    rows[r] = [];\n                  }\n                  rows[r] = rows[r].concat(vector);\n                });\n              case 33:\n                c++;\n                _context2.next = 3;\n                break;\n              case 36:\n                return _context2.abrupt("return", rows);\n              case 37:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      function toVector(_x) {\n        return _toVector.apply(this, arguments);\n      }\n      return toVector;\n    }(),\n    kmeans: function () {\n      var _kmeans2 = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(data) {\n        var cluster,\n          vector,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                cluster = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : 3;\n                _context3.next = 3;\n                return this.toVector(data);\n              case 3:\n                vector = _context3.sent;\n                return _context3.abrupt("return", new Promise(function (resolve, reject) {\n                  // console.log(cluster)\n                  GroupingTool_kmeans(vector, cluster, function (err, clusterVector, clusterIndex, cluster, centroids) {\n                    if (err) {\n                      // throw new Error(err)\n                      return reject(err);\n                    }\n\n                    //do something with the result\n                    // console.log(res)\n                    resolve({\n                      clusterVector: clusterVector,\n                      clusterIndex: clusterIndex,\n                      cluster: cluster,\n                      centroids: centroids\n                    });\n                  });\n                }));\n              case 5:\n              case "end":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function kmeans(_x2) {\n        return _kmeans2.apply(this, arguments);\n      }\n      return kmeans;\n    }(),\n    addKmeans: function () {\n      var _addKmeans = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(vector) {\n        var cluster,\n          result,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                cluster = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : 3;\n                _context4.next = 3;\n                return this.kmeans(vector, cluster);\n              case 3:\n                result = _context4.sent;\n                return _context4.abrupt("return", vector.map(function (item, i) {\n                  // console.log(item, i, result.clusterIndex)\n                  item.push(result.clusterVector[i]);\n                  return item;\n                }));\n              case 5:\n              case "end":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function addKmeans(_x3) {\n        return _addKmeans.apply(this, arguments);\n      }\n      return addKmeans;\n    }(),\n    groupingByDifference: function () {\n      var _groupingByDifference = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(vector) {\n        var groupType,\n          member,\n          result,\n          groups,\n          groupIndexList,\n          mod,\n          minMembers,\n          counter,\n          i,\n          group,\n          clusterI,\n          baseMember,\n          v,\n          randomId,\n          item,\n          output,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                groupType = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : \'member\';\n                member = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : 3;\n                member = Number(member);\n                _context5.next = 5;\n                return this.kmeans(vector, member);\n              case 5:\n                result = _context5.sent;\n                // console.log(result)\n                groups = Math.ceil(vector.length / member);\n                if (groupType === \'group\') {\n                  groups = member;\n                  member = Number(Math.floor(vector.length / groups));\n                }\n                console.log(groups, member);\n                groupIndexList = [];\n                mod = vector.length % groups;\n                minMembers = Math.floor(vector.length / groups);\n                counter = 0; // console.log(groups)\n                i = 0;\n              case 14:\n                if (!(i < groups)) {\n                  _context5.next = 40;\n                  break;\n                }\n                group = [];\n                clusterI = 0;\n                baseMember = minMembers;\n                if (i < mod) {\n                  baseMember++;\n                }\n\n                // console.log(baseMember)\n                // continue\n              case 19:\n                if (false) {}\n                v = result.clusterIndex[clusterI % groups]; // console.log(v, counter, vector.length) \n                if (!(v.length === 0)) {\n                  _context5.next = 24;\n                  break;\n                }\n                clusterI++;\n                return _context5.abrupt("continue", 19);\n              case 24:\n                randomId = Math.floor(Math.random() * v.length);\n                item = v[randomId];\n                group.push(Number(item));\n                // console.log(item)\n\n                v.splice(randomId, 1);\n                // console.log(vector)\n                // clusterVector[(clusterI % member)] = v\n                // console.log(result.clusterVector)\n                // console.log(v)\n\n                clusterI++;\n                counter++;\n                // console.log(counter, group.length, member)\n                if (!(counter === vector.length)) {\n                  _context5.next = 32;\n                  break;\n                }\n                return _context5.abrupt("break", 36);\n              case 32:\n                if (!(group.length === baseMember)) {\n                  _context5.next = 34;\n                  break;\n                }\n                return _context5.abrupt("break", 36);\n              case 34:\n                _context5.next = 19;\n                break;\n              case 36:\n                // console.log(group)\n                groupIndexList.push(group);\n              case 37:\n                i++;\n                _context5.next = 14;\n                break;\n              case 40:\n                // console.log(groupIndexList)\n                // let invertGroup = new Array(groups)\n                output = [].concat(vector);\n                groupIndexList.forEach(function (list, groupId) {\n                  list.forEach(function (index) {\n                    var o = [].concat(output[index]);\n                    o.push(groupId);\n                    output[index] = o;\n                  });\n                });\n                return _context5.abrupt("return", output);\n              case 43:\n              case "end":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function groupingByDifference(_x4) {\n        return _groupingByDifference.apply(this, arguments);\n      }\n      return groupingByDifference;\n    }(),\n    groupingBySimilarity: function () {\n      var _groupingBySimilarity = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(vector) {\n        var groupType,\n          member,\n          groups,\n          _yield$this$kmeans,\n          clusterIndex,\n          isFinish,\n          i,\n          list,\n          randomId,\n          _randomId,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                groupType = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : \'member\';\n                member = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : 3;\n                member = Number(member);\n                groups = Math.ceil(vector.length / member);\n                if (groupType === \'group\') {\n                  groups = member;\n                  member = Math.ceil(vector.length / groups);\n                }\n\n                // console.log(groups, member)\n                _context6.next = 7;\n                return this.kmeans(vector, groups);\n              case 7:\n                _yield$this$kmeans = _context6.sent;\n                clusterIndex = _yield$this$kmeans.clusterIndex;\n                // console.log(clusterIndex) \n                this.sortClusterIndexBySize(clusterIndex);\n              case 10:\n                if (false) {}\n                isFinish = true;\n                i = 0;\n              case 13:\n                if (!(i < clusterIndex.length)) {\n                  _context6.next = 24;\n                  break;\n                }\n                list = clusterIndex[i];\n                if (!(list.length <= member && list.length >= member - 1)) {\n                  _context6.next = 17;\n                  break;\n                }\n                return _context6.abrupt("continue", 21);\n              case 17:\n                isFinish = false;\n                if (list.length > member) {\n                  randomId = Math.floor(Math.random() * list.length);\n                  clusterIndex[clusterIndex.length - 1].push(list[randomId]);\n                  list.splice(randomId, 1);\n                } else {\n                  _randomId = Math.floor(Math.random() * clusterIndex[0].length);\n                  clusterIndex[i].push(clusterIndex[0][_randomId]);\n                  clusterIndex[0].splice(_randomId, 1);\n                }\n                this.sortClusterIndexBySize(clusterIndex);\n                return _context6.abrupt("break", 24);\n              case 21:\n                i++;\n                _context6.next = 13;\n                break;\n              case 24:\n                if (!isFinish) {\n                  _context6.next = 26;\n                  break;\n                }\n                return _context6.abrupt("break", 28);\n              case 26:\n                _context6.next = 10;\n                break;\n              case 28:\n                Object.keys(clusterIndex).forEach(function (groupId) {\n                  clusterIndex[groupId].forEach(function (i) {\n                    vector[i].push(Number(groupId));\n                  });\n                });\n                return _context6.abrupt("return", vector);\n              case 30:\n              case "end":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function groupingBySimilarity(_x5) {\n        return _groupingBySimilarity.apply(this, arguments);\n      }\n      return groupingBySimilarity;\n    }(),\n    sortClusterIndexBySize: function sortClusterIndexBySize(clusterIndex) {\n      clusterIndex.sort(function (a, b) {\n        return b.length - a.length;\n      });\n    }\n  }\n};\n/* harmony default export */ var GroupingToolvue_type_script_lang_js_ = (GroupingTool);\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.js?vue&type=script&lang=js&\n /* harmony default export */ var GroupingTool_GroupingToolvue_type_script_lang_js_ = (GroupingToolvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\nvar GroupingToolvue_type_style_index_0_id_1d066bc0_lang_less_scoped_true_ = __webpack_require__(385);\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(8);\n\n// EXTERNAL MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.yaml?vue&type=custom&index=0&blockType=i18n&issuerPath=%2Fapp%2Fsrc%2Fcomponents%2FReplacePanel%2FGroupingTool%2FGroupingTool.vue&lang=yaml\nvar GroupingToolvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml = __webpack_require__(387);\n\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  GroupingTool_GroupingToolvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "1d066bc0",\n  null\n  \n)\n\n/* custom blocks */\n\nif (typeof GroupingToolvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml["default"] === \'function\') Object(GroupingToolvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml["default"])(component)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "src/components/ReplacePanel/GroupingTool/GroupingTool.vue"\n/* harmony default export */ var GroupingTool_GroupingTool = __webpack_exports__["default"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wuaHRtbD85ZWIzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1JlcGxhY2VQYW5lbC9Hcm91cGluZ1Rvb2wva21lYW5zLmpzPzFhODIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wuanM/ZDZhYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9SZXBsYWNlUGFuZWwvR3JvdXBpbmdUb29sL0dyb3VwaW5nVG9vbC5qcz85NTAxIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1JlcGxhY2VQYW5lbC9Hcm91cGluZ1Rvb2wvR3JvdXBpbmdUb29sLnZ1ZT85NWQ4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJHcm91cGluZ1Rvb2xcIiB9LCBbXG4gICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJmaWVsZHNcIiB9LCBbXG4gICAgICBfYyhcbiAgICAgICAgXCJzZWxlY3RcIixcbiAgICAgICAge1xuICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuZ3JvdXBUeXBlLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5ncm91cFR5cGVcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNoYW5nZTogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhciAkJHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxuICAgICAgICAgICAgICAgIC5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucywgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IFwiX3ZhbHVlXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIF92bS4kc2V0KFxuICAgICAgICAgICAgICAgIF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wsXG4gICAgICAgICAgICAgICAgXCJncm91cFR5cGVcIixcbiAgICAgICAgICAgICAgICAkZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwib3B0aW9uXCIsIHsgYXR0cnM6IHsgdmFsdWU6IFwiZ3JvdXBcIiB9IH0sIFtcbiAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLiR0KFwiR3JvdXA6IFwiKSkpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcIm9wdGlvblwiLCB7IGF0dHJzOiB7IHZhbHVlOiBcIm1lbWJlclwiIH0gfSwgW1xuICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0uJHQoXCJNZW1iZXI6IFwiKSkpXG4gICAgICAgICAgXSlcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgdmFsdWU6IF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuZ3JvdXBMZW5ndGgsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBcImxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5ncm91cExlbmd0aFwiXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhdHRyczogeyB0eXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0ubG9jYWxDb25maWcuR3JvdXBpbmdUb29sLmdyb3VwTGVuZ3RoIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3ZtLiRzZXQoXG4gICAgICAgICAgICAgIF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wsXG4gICAgICAgICAgICAgIFwiZ3JvdXBMZW5ndGhcIixcbiAgICAgICAgICAgICAgJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIlxuLy8gSW5pdGlhbGl6ZVxuLy8gLS0tLS0tLS0tLVxuZnVuY3Rpb24gS21lYW5zICh2ZWN0b3IsIGssIGNhbGxiYWNrKSB7XG4gICAgLy8qKlZlY3RvcjoqKiBhcnJheSBvZiBhcnJheXMuIElubmVyIGFycmF5XG4gICAgLy9yZXByZXNlbnRzIGEgbXVsdGlkaW1lbnNpb25hbCBkYXRhIHBvaW50ICh2ZWN0b3IpICBcbiAgICAvLypUaGVzZSBzaG91bGQgYmUgbm9ybWFsaXplZCpcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLnZlY3RvciA9IHZlY3RvciBcbiAgICAvLyoqSzoqKiByZXByZXNlbnRzIHRoZSBudW1iZXIgb2YgZ3JvdXBzL2NsdXN0ZXJzIGludG8gXG4gICAgLy93aGljaCB0aGUgdmVjdG9ycyB3aWxsIGJlIGdyb3VwZWRcbiAgICB0aGlzLmsgPSBrXG4gICAgLy9Jbml0aWFsaXplIHRoZSBjZW50cm9pZHMgYW5kIGNsdXN0ZXJzICAgICBcbiAgICAvLyoqQ2VudHJvaWRzOioqIHJlcHJlc2VudCB0aGUgY2VudGVyIG9mIGVhY2ggY2x1c3Rlci4gXG4gICAgLy9UaGV5IGFyZSB0YWtlbiBieSBhdmVyYWdpbmcgZWFjaCBkaW1lbnNpb24gb2YgdGhlIHZlY3RvcnNcbiAgICB0aGlzLmNlbnRyb2lkcyA9IG5ldyBBcnJheShrKVxuICAgIHRoaXMuY2x1c3RlciA9IG5ldyBBcnJheShrKSBcbiAgICB0aGlzLmNsdXN0ZXJJbmRleCA9IG5ldyBBcnJheSh0aGlzLnZlY3Rvci5sZW5ndGgpIFxuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY2x1c3RlcilcbiAgICAvL0NyZWF0ZSBjZW50cm9pZHMgYW5kIHBsYWNlIHRoZW0gcmFuZG9tbHkgYmVjYXVzZSBcbiAgICAvL3dlIGRvbid0IHlldCBrbm93IHdoZXJlIHRoZSB2ZWN0b3JzIGFyZSBtb3N0IGNvbmNlbnRyYXRlZFxuICAgIHRoaXMuY3JlYXRlQ2VudHJvaWRzKClcbiAgICB2YXIgY291bnQgPSAwXG4gICAgICAgICwgbm90RmluaXNoZWQgPSB0cnVlXG4gICAgXG4gICAgdGhpcy5pdGVyYXRlKHRoaXMuY2VudHJvaWRzLnNsaWNlKDApKVxufVxuXG4vLyBBc3NpZ24gdmVjdG9yIHRvIGVhY2ggY2VudHJvaWRcbi8vIC0tLS0tLS0tLS1cbi8vIFJhbmRvbWx5IGNob29zZSAqKmsqKiB2ZWN0b3JzIGZyb20gdGhlIHZlY3RvciBcbi8vIGFycmF5ICoqdmVjdG9yKiouIFRoZXNlIHJlcHJlc2VudCBvdXIgZ3Vlc3MgXG4vLyBhdCB3aGVyZSBjbHVzdGVycyBtYXkgZXhpc3QuIFxuS21lYW5zLnByb3RvdHlwZS5jcmVhdGVDZW50cm9pZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJhbmRvbUFycmF5ID0gdGhpcy52ZWN0b3Iuc2xpY2UoMClcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICByYW5kb21BcnJheS5zb3J0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHNlbGYudmVjdG9yLmxlbmd0aCkpXG4gICAgfSk7XG4gICAgdGhpcy5jZW50cm9pZHMgPSByYW5kb21BcnJheS5zbGljZSgwLCB0aGlzLmspO1xufVxuXG4vLyBSZWN1cnNpdmVseSBjbHVzdGVyIGFuZCBtb3ZlIHRoZSBjZW50cm9pZHNcbi8vIC0tLS0tLS0tLS1cbi8vVGhpcyBtZXRob2QgZ3JvdXBzIHZlY3RvcnMgaW50byBjbHVzdGVycyBhbmQgdGhlbiBkZXRlcm1pbmUgdGhlIFxuLy90aGUgbmV3IGxvY2F0aW9uIGZvciBlYWNoIGNlbnRyb2lkIGJhc2VkIHVwb24gdGhlIG1lYW5cbi8vbG9jYXRpb24gb2YgdGhlIHZlY3RvcnMgaW4gdGhlIGNvb3Jlc3BvbmRpbmcgY2x1c3RlclxuS21lYW5zLnByb3RvdHlwZS5pdGVyYXRlID0gZnVuY3Rpb24gKHZlY0FycmF5KSB7XG4gICBcbiAgICB0aGlzLmNsdXN0ZXIgPSBuZXcgQXJyYXkodGhpcy5rKVxuICAgIHRoaXMuY2x1c3RlckluZGV4ID0gbmV3IEFycmF5KHRoaXMuaylcbiAgICB0aGlzLmNsdXN0ZXJWZWN0b3IgPSBuZXcgQXJyYXkodmVjQXJyYXkubGVuZ3RoKVxuICAgIC8vIGNvbnNvbGUubG9ndChoaXMuY2x1c3RlcilcbiAgICB2YXIgdGVtcEFycmF5ID0gW10gICAgXG4gICAgZm9yICh2YXIgYT0wOyBhPHRoaXMudmVjdG9yWzBdLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIHRlbXBBcnJheS5wdXNoKDApXG4gICAgfVxuICAgIHZhciB2ZWNBcnJheSA9IFtdXG4gICAgZm9yICh2YXIgYT0wOyBhPHRoaXMuazsgYSsrKSB7XG4gICAgICAgIHZlY0FycmF5W2FdID0gKHRlbXBBcnJheS5zbGljZSgwKSlcbiAgICB9XG4gICAgLy9Hcm91cCBlYWNoIHZlY3RvciB0byBhIGNsdXN0ZXIgYmFzZWQgdXBvbiB0aGUgXG4gICAgLy9jb29yZXNwb25kaW5nIGNlbnRyb2lkXG4gICAgLy8gY29uc29sZS5sb2codmVjQXJyYXkubGVuZ3RoKVxuICAgIGZvciAobGV0IGkgaW4gdGhpcy52ZWN0b3IpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlY3RvcltpXS5zbGljZSgwKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyh2KVxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmFzc2lnbkNlbnRyb2lkKHYpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGluZGV4KVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5jbHVzdGVyW2luZGV4XSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2x1c3RlcltpbmRleF09W11cbiAgICAgICAgICAgIHRoaXMuY2x1c3RlckluZGV4W2luZGV4XT1bXVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGluZGV4LCB0aGlzLmNsdXN0ZXJbaW5kZXhdKVxuICAgICAgICB0aGlzLmNsdXN0ZXJbaW5kZXhdLnB1c2godilcbiAgICAgICAgLy8gY29uc29sZS5sb2coMiwgaW5kZXgpXG4gICAgICAgIHRoaXMuY2x1c3RlckluZGV4W2luZGV4XS5wdXNoKGkpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGluZGV4KVxuICAgICAgICB0aGlzLmNsdXN0ZXJWZWN0b3JbaV0gPSBOdW1iZXIoaW5kZXgpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY2x1c3RlcilcbiAgICAgICAgZm9yICh2YXIgYT0wOyBhPHYubGVuZ3RoOyBhKyspe1xuICAgICAgICAgICAgdmVjQXJyYXlbaW5kZXhdW2FdKz12W2FdIC8va2VlcCBhIHN1bSBmb3IgY2x1c3RlclxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKHZlY0FycmF5KVxuICAgIC8vQ2FsY3VsYXRlIHRoZSBtZWFuIHZhbHVlcyBmb3IgZWFjaCBjbHVzdGVyLlxuICAgIHZhciBkaXN0YW5jZSwgbWF4ID0gMCBcbiAgIFxuICAgIGZvciAodmFyIGE9MDsgYTx0aGlzLms7IGErKykge1xuICAgICAgICBcbiAgICAgICAgdmFyIGNsdXN0ZXJTaXplID0gMCAvL2NsdXN0ZXIgaXMgZW1wdHlcbiAgICAgICAgaWYgKHRoaXMuY2x1c3RlclthXSkgY2x1c3RlclNpemUgPSB0aGlzLmNsdXN0ZXJbYV0ubGVuZ3RoXG4gICAgICAgIFxuICAgICAgICBmb3IgKGxldCBiIGluIHZlY0FycmF5W2FdKSB7XG4gICAgICAgICAgICB2ZWNBcnJheVthXVtiXSA9IHZlY0FycmF5W2FdW2JdL2NsdXN0ZXJTaXplXG4gICAgICAgIH1cbiAgICAgICAgZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlKHZlY0FycmF5W2FdLCB0aGlzLmNlbnRyb2lkc1thXSlcbiAgICAgICAgaWYgKGRpc3RhbmNlPm1heCkgXG4gICAgICAgICAgICBtYXg9ZGlzdGFuY2VcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2codGhpcy5jbHVzdGVyKVxuICAgIGlmIChtYXg8PTAuNSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmNsdXN0ZXIpXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKG51bGwsIHRoaXMuY2x1c3RlclZlY3RvciwgdGhpcy5jbHVzdGVySW5kZXgsIHRoaXMuY2x1c3RlciwgdGhpcy5jZW50cm9pZHMpXG4gICAgfVxuXG4gICAgLy9Gb3IgZWFjaCBjZW50cm9pZCB1c2UgdGhlIG1lYW4gY2FsY3VsYXRlZCBmb3IgdGhlIFxuICAgIC8vY29ycmVzcG9uZGluZyBjbHVzdGVyIChlZmZlY3RpdmVseSBcIm1vdmluZ1wiIHRoZSBjZW50cm9pZFxuICAgIC8vdG8gaXRzIG5ldyBcImxvY2F0aW9uXCIpXG4gICAgZm9yIChsZXQgeiBpbiB2ZWNBcnJheSkge1xuICAgICAgICB0aGlzLmNlbnRyb2lkc1t6XSA9IHZlY0FycmF5W3pdLnNsaWNlKDApXG4gICAgfVxuICAgIHRoaXMuaXRlcmF0ZSh2ZWNBcnJheSlcblxufVxuXG5cbi8vIERldGVybWluZSB0aGUgY2xvc2VzdCBjZW50cm9pZCB0byBhIHZlY3RvclxuLy8gLS0tLS0tLS0tLVxuS21lYW5zLnByb3RvdHlwZS5hc3NpZ25DZW50cm9pZCA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBtaW4gPSBJbmZpbml0eSwgcmVzID0gMFxuXG4gICAgLy9Gb3IgZWFjaCB2ZWN0b3Igd2UgZGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSB0byB0aGUgXG4gICAgLy9uZWFyZXN0IGNlbnRyb2lkLiBUaGUgdmVjdG9yIGlzIGFzc2lnbmVkIHRvIHRoZSBcbiAgICAvL2NsdXN0ZXIgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgbmVhcmVzdCBjZW50cm9pZC5cbiAgICBmb3IgKGxldCBpIGluIHRoaXMuY2VudHJvaWRzKSB7XG4gICAgICAgIGxldCBkaXN0ID0gdGhpcy5kaXN0YW5jZShwb2ludCwgdGhpcy5jZW50cm9pZHNbaV0pXG4gICAgICAgIGlmIChkaXN0IDwgbWluKSB7XG4gICAgICAgICAgICBtaW4gPSBkaXN0XG4gICAgICAgICAgICByZXMgPSBpICAgICAgIFxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIocmVzKVxufVxuXG4vLyBDYWxjdWxhdGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdmVjdG9yc1xuLy8gLS0tLS0tLS0tLVxuS21lYW5zLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uKHYxLCB2Mikge1xuICAgIHZhciB0b3RhbCA9IDBcbiAgICBmb3IgKGxldCBjIGluIHYxKSB7XG4gICAgICAgIGlmIChjIT0wKVxuICAgICAgICB0b3RhbCArPSBNYXRoLnBvdyh2MltjXS12MVtjXSwgMilcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguc3FydCh0b3RhbClcbn1cblxuLy8ga21lYW5zLmpzIDAuMC4xXG5cbi8vVGhlIGttZWFucyBjbHVzdGVyaW5nIGFsZ29yaXRobSByZWxpZXMgdXBvbiBrbm93aW5nIGluIGFkdmFuY2Vcbi8vdGhlIG51bWJlciBvZiBjbHVzdGVycyBpbiB3aGljaCB0byBwbGFjZSB2ZWN0b3JzLiBcblxuXG4vLyBFeHBvc2UgXG4vLyAtLS0tLS0tLS0tXG5cbi8vRXhwb3NlIG91ciBsaWJyYXJ5IHRvIGJlIGNhbGxlZCBleHRlcm5hbGx5XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih2ZWN0b3IsIGssIGNhbGxiYWNrKSB7IFxuICAgIGlmICghdmVjdG9yIHx8ICFrIHx8ICFjYWxsYmFjaykgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJQcm92aWRlIDMgYXJndW1lbnRzOiBjYWxsYmFjaywgdmVjdG9yLCBjbHVzdGVyc1wiKVxuICAgIFxuICAgIHJldHVybiBuZXcgS21lYW5zKHZlY3RvciwgaywgY2FsbGJhY2spXG59XG4iLCJpbXBvcnQga21lYW5zIGZyb20gJy4va21lYW5zLmpzJ1xyXG5cclxubGV0IEdyb3VwaW5nVG9vbCA9IHtcclxuICBwcm9wczogWydjb25maWcnLCAnbG9jYWxDb25maWcnLCAndXRpbHMnXSxcclxuICBkYXRhICgpIHsgICAgXHJcbiAgICB0aGlzLiRpMThuLmxvY2FsZSA9IHRoaXMubG9jYWxDb25maWcubG9jYWxlXHJcbiAgICByZXR1cm4ge1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgd2F0Y2g6IHtcclxuICAgICdsb2NhbENvbmZpZy5sb2NhbGUnKCkge1xyXG4gICAgICB0aGlzLiRpMThuLmxvY2FsZSA9IHRoaXMubG9jYWxDb25maWcubG9jYWxlO1xyXG4gICAgfSxcclxuICB9LFxyXG4gIC8vIGNvbXB1dGVkOiB7XHJcbiAgICBcclxuICAvLyB9LFxyXG4gIC8vIG1vdW50ZWQ6IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuICAvLyB9LFxyXG4gIG1ldGhvZHM6IHtcclxuICAgIHRlc3QyMDIyMTAzMDAwMzM6IGFzeW5jIGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIHZhciB2ZWN0b3IgPSBbXHJcbiAgICAgICAgWzEsIDEwLCAyLCAzMF0sXHJcbiAgICAgICAgWydBJywgMzAsIDIwLCAyXSxcclxuICAgICAgICBbJ0InLCAzMCwgMzAsIDNdLFxyXG4gICAgICAgIFsnQycsIDMwLCAzMSwgM10sXHJcbiAgICAgICAgWydBJywgMTAsIDEwLCAxXSxcclxuICAgICAgICBbJ0InLCAyMCwgMSwgMzBdLFxyXG4gICAgICAgIFsnQycsIDEsIDI1LCAzMF1cclxuICAgICAgXVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLnRvVmVjdG9yKHZlY3RvcikpXHJcbiAgICAgIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMuYWRkS21lYW5zKHZlY3RvcikpXHJcbiAgICAgIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMuYWRkR3JvdXBJbkRpZmZlcmVuY2UodmVjdG9yKSlcclxuICAgICAgY29uc29sZS5sb2coYXdhaXQgdGhpcy5hZGRHcm91cEluU2ltaWxhcml0eSh2ZWN0b3IpKVxyXG5cclxuICAgIH0sXHJcbiAgICB0b1ZlY3RvcjogYXN5bmMgZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICBsZXQgcm93cyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aClcclxuICAgICAgbGV0IGNvbHVtZUxlbmd0aCA9IGRhdGFbMF0ubGVuZ3RoXHJcblxyXG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvbHVtZUxlbmd0aDsgYysrKSB7XHJcbiAgICAgICAgbGV0IGxpc3QgPSBbXVxyXG4gICAgICAgIGxldCBpc0NvbHVtbk51bWJlciA9IHRydWVcclxuXHJcbiAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkYXRhLmxlbmd0aDsgZCsrKSB7XHJcbiAgICAgICAgICBsZXQgdmFsdWUgPSBkYXRhW2RdW2NdXHJcbiAgICAgICAgICBsZXQgaXNOdW1iZXIgPSAodHlwZW9mKHZhbHVlKSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICBpZiAoaXNOdW1iZXIgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlzQ29sdW1uTnVtYmVyID0gZmFsc2VcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsaXN0LnB1c2godmFsdWUpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhpc0NvbHVtbk51bWJlcilcclxuXHJcbiAgICAgICAgaWYgKGlzQ29sdW1uTnVtYmVyID09PSB0cnVlKSB7XHJcbiAgICAgICAgICBsZXQgbWF4ID0gTWF0aC5tYXgoLi4ubGlzdClcclxuICAgICAgICAgIGxldCBtaW4gPSBNYXRoLm1pbiguLi5saXN0KVxyXG4gICAgICAgICAgbGV0IHJhbmdlID0gbWF4IC0gbWluXHJcbiAgICAgICAgICBpZiAocmFuZ2UgPT09IDApIHtcclxuICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBsZXQgbm9ybWFsaXplZFxyXG4gICAgICAgICAgaWYgKG1heCA9PT0gMSAmJiBtaW4gPT09IDApIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZCA9IGxpc3QubWFwKHZhbHVlID0+ICgodmFsdWUgLSBtaW4pIC8gcmFuZ2UpKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBsaXN0XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3dzLmxlbmd0aDsgcisrKSB7XHJcbiAgICAgICAgICAgIGlmICghcm93c1tyXSkge1xyXG4gICAgICAgICAgICAgIHJvd3Nbcl0gPSBbXVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByb3dzW3JdLnB1c2gobm9ybWFsaXplZFtyXSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBsZXQgbWFwID0ge31cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgbGV0IGlkID0gMFxyXG4gICAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkYXRhLmxlbmd0aDsgZCsrKSB7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFbZF1bY11cclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSArICcnXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbHVlKVxyXG4gICAgICAgICAgICBpZiAoIW1hcFt2YWx1ZV0pIHtcclxuICAgICAgICAgICAgICBtYXBbdmFsdWVdID0gaWRcclxuICAgICAgICAgICAgICBpZCsrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGlzdC5wdXNoKHZhbHVlKVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG1hcCwgbGlzdClcclxuXHJcbiAgICAgICAgICBsZXQgdmVjdG9ycyA9IFtdXHJcbiAgICAgICAgICBsZXQgdiA9IFtdXHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE9iamVjdC5rZXlzKG1hcCkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdltpXSA9IDBcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHYpXHJcbiAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZGF0YVtkXVtjXVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgJydcclxuICAgICAgICAgICAgbGV0IGkgPSBtYXBbdmFsdWVdXHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGkpXHJcbiAgICAgICAgICAgIGxldCB2MiA9IFtdLmNvbmNhdCh2KVxyXG4gICAgICAgICAgICB2MltpXSA9IDFcclxuICAgICAgICAgICAgdmVjdG9ycy5wdXNoKHYyKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2codmVjdG9ycylcclxuXHJcbiAgICAgICAgICB2ZWN0b3JzLmZvckVhY2goKHZlY3RvciwgcikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXJvd3Nbcl0pIHtcclxuICAgICAgICAgICAgICByb3dzW3JdID0gW11cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByb3dzW3JdID0gcm93c1tyXS5jb25jYXQodmVjdG9yKVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByb3dzXHJcbiAgICB9LFxyXG4gICAga21lYW5zOiBhc3luYyBmdW5jdGlvbiAoZGF0YSwgY2x1c3RlciA9IDMpIHtcclxuICAgICAgbGV0IHZlY3RvciA9IGF3YWl0IHRoaXMudG9WZWN0b3IoZGF0YSlcclxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhjbHVzdGVyKVxyXG4gICAgICAgIGttZWFucyh2ZWN0b3IsIGNsdXN0ZXIsIGZ1bmN0aW9uKGVyciwgY2x1c3RlclZlY3RvciwgY2x1c3RlckluZGV4LCBjbHVzdGVyLCBjZW50cm9pZHMpIHtcclxuICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKGVycilcclxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpXHJcbiAgICAgICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAgICAgLy9kbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZXMpXHJcbiAgICAgICAgICByZXNvbHZlKHtcclxuICAgICAgICAgICAgY2x1c3RlclZlY3RvcixcclxuICAgICAgICAgICAgY2x1c3RlckluZGV4LFxyXG4gICAgICAgICAgICBjbHVzdGVyLFxyXG4gICAgICAgICAgICBjZW50cm9pZHNcclxuICAgICAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHZlY3RvcikgXHJcbiAgICB9LFxyXG4gICAgYWRkS21lYW5zOiBhc3luYyBmdW5jdGlvbiAodmVjdG9yLCBjbHVzdGVyID0gMykge1xyXG4gICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5rbWVhbnModmVjdG9yLCBjbHVzdGVyKVxyXG5cclxuICAgICAgcmV0dXJuIHZlY3Rvci5tYXAoKGl0ZW0sIGkpID0+IHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhpdGVtLCBpLCByZXN1bHQuY2x1c3RlckluZGV4KVxyXG4gICAgICAgIGl0ZW0ucHVzaChyZXN1bHQuY2x1c3RlclZlY3RvcltpXSlcclxuICAgICAgICByZXR1cm4gaXRlbVxyXG4gICAgICB9KVxyXG4gICAgfSxcclxuICAgIGdyb3VwaW5nQnlEaWZmZXJlbmNlOiBhc3luYyBmdW5jdGlvbiAodmVjdG9yLCBncm91cFR5cGUgPSAnbWVtYmVyJywgbWVtYmVyID0gMykge1xyXG4gICAgICBtZW1iZXIgPSBOdW1iZXIobWVtYmVyKVxyXG4gICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5rbWVhbnModmVjdG9yLCBtZW1iZXIpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHJlc3VsdClcclxuXHJcbiAgICAgIGxldCBncm91cHMgPSBNYXRoLmNlaWwodmVjdG9yLmxlbmd0aCAvIG1lbWJlcilcclxuICAgICAgXHJcbiAgICAgIGlmIChncm91cFR5cGUgPT09ICdncm91cCcpIHtcclxuICAgICAgICBncm91cHMgPSBtZW1iZXJcclxuICAgICAgICBtZW1iZXIgPSBOdW1iZXIoTWF0aC5mbG9vcih2ZWN0b3IubGVuZ3RoIC8gZ3JvdXBzKSlcclxuICAgICAgfVxyXG4gICAgICBjb25zb2xlLmxvZyhncm91cHMsIG1lbWJlcilcclxuICAgICAgXHJcbiAgICAgIGxldCBncm91cEluZGV4TGlzdCA9IFtdXHJcbiAgICAgIGxldCBtb2QgPSB2ZWN0b3IubGVuZ3RoICUgZ3JvdXBzXHJcbiAgICAgIGxldCBtaW5NZW1iZXJzID0gTWF0aC5mbG9vcih2ZWN0b3IubGVuZ3RoIC8gZ3JvdXBzKVxyXG5cclxuICAgICAgbGV0IGNvdW50ZXIgPSAwXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGdyb3VwcylcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHM7IGkrKykge1xyXG4gICAgICAgIGxldCBncm91cCA9IFtdXHJcblxyXG4gICAgICAgIGxldCBjbHVzdGVySSA9IDBcclxuICAgICAgICBsZXQgYmFzZU1lbWJlciA9IG1pbk1lbWJlcnNcclxuICAgICAgICBpZiAoaSA8IG1vZCkge1xyXG4gICAgICAgICAgYmFzZU1lbWJlcisrXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhiYXNlTWVtYmVyKVxyXG4gICAgICAgIC8vIGNvbnRpbnVlXHJcblxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICBsZXQgdiA9IHJlc3VsdC5jbHVzdGVySW5kZXhbKGNsdXN0ZXJJICUgZ3JvdXBzKV1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2codiwgY291bnRlciwgdmVjdG9yLmxlbmd0aCkgXHJcbiAgICAgICAgICBpZiAodi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY2x1c3RlckkrK1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGxldCByYW5kb21JZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHYubGVuZ3RoKVxyXG4gICAgICAgICAgbGV0IGl0ZW0gPSB2W3JhbmRvbUlkXVxyXG4gICAgICAgICAgZ3JvdXAucHVzaChOdW1iZXIoaXRlbSkpXHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhpdGVtKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICB2LnNwbGljZShyYW5kb21JZCwgMSlcclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZlY3RvcilcclxuICAgICAgICAgIC8vIGNsdXN0ZXJWZWN0b3JbKGNsdXN0ZXJJICUgbWVtYmVyKV0gPSB2XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZXN1bHQuY2x1c3RlclZlY3RvcilcclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHYpXHJcblxyXG4gICAgICAgICAgY2x1c3RlckkrK1xyXG4gICAgICAgICAgY291bnRlcisrXHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjb3VudGVyLCBncm91cC5sZW5ndGgsIG1lbWJlcilcclxuICAgICAgICAgIGlmIChjb3VudGVyID09PSB2ZWN0b3IubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGdyb3VwLmxlbmd0aCA9PT0gYmFzZU1lbWJlcikge1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhncm91cClcclxuICAgICAgICBncm91cEluZGV4TGlzdC5wdXNoKGdyb3VwKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhncm91cEluZGV4TGlzdClcclxuXHJcbiAgICAgIC8vIGxldCBpbnZlcnRHcm91cCA9IG5ldyBBcnJheShncm91cHMpXHJcbiAgICAgIGxldCBvdXRwdXQgPSBbXS5jb25jYXQodmVjdG9yKVxyXG4gICAgICBncm91cEluZGV4TGlzdC5mb3JFYWNoKChsaXN0LCBncm91cElkKSA9PiB7XHJcbiAgICAgICAgbGlzdC5mb3JFYWNoKGluZGV4ID0+IHtcclxuICAgICAgICAgIGxldCBvID0gW10uY29uY2F0KG91dHB1dFtpbmRleF0pXHJcbiAgICAgICAgICBvLnB1c2goZ3JvdXBJZClcclxuICAgICAgICAgIG91dHB1dFtpbmRleF0gPSBvXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiBvdXRwdXRcclxuICAgIH0sXHJcbiAgICBncm91cGluZ0J5U2ltaWxhcml0eTogYXN5bmMgZnVuY3Rpb24gKHZlY3RvciwgZ3JvdXBUeXBlID0gJ21lbWJlcicsIG1lbWJlciA9IDMpIHtcclxuICAgICAgbWVtYmVyID0gTnVtYmVyKG1lbWJlcilcclxuICAgICAgbGV0IGdyb3VwcyA9IE1hdGguY2VpbCh2ZWN0b3IubGVuZ3RoIC8gbWVtYmVyKVxyXG5cclxuICAgICAgaWYgKGdyb3VwVHlwZSA9PT0gJ2dyb3VwJykge1xyXG4gICAgICAgIGdyb3VwcyA9IG1lbWJlclxyXG4gICAgICAgIG1lbWJlciA9IE1hdGguY2VpbCh2ZWN0b3IubGVuZ3RoIC8gZ3JvdXBzKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhncm91cHMsIG1lbWJlcilcclxuXHJcbiAgICAgIGxldCB7Y2x1c3RlckluZGV4fSA9IGF3YWl0IHRoaXMua21lYW5zKHZlY3RvciwgZ3JvdXBzKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhjbHVzdGVySW5kZXgpIFxyXG4gICAgICB0aGlzLnNvcnRDbHVzdGVySW5kZXhCeVNpemUoY2x1c3RlckluZGV4KVxyXG4gICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGxldCBpc0ZpbmlzaCA9IHRydWVcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsdXN0ZXJJbmRleC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IGxpc3QgPSBjbHVzdGVySW5kZXhbaV1cclxuICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA8PSBtZW1iZXIgJiYgbGlzdC5sZW5ndGggPj0gbWVtYmVyIC0gMSkge1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlzRmluaXNoID0gZmFsc2VcclxuXHJcbiAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPiBtZW1iZXIpIHtcclxuICAgICAgICAgICAgbGV0IHJhbmRvbUlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGlzdC5sZW5ndGgpXHJcbiAgICAgICAgICAgIGNsdXN0ZXJJbmRleFsoY2x1c3RlckluZGV4Lmxlbmd0aCAtIDEpXS5wdXNoKGxpc3RbcmFuZG9tSWRdKVxyXG4gICAgICAgICAgICBsaXN0LnNwbGljZShyYW5kb21JZCwgMSlcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgcmFuZG9tSWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjbHVzdGVySW5kZXhbMF0ubGVuZ3RoKVxyXG4gICAgICAgICAgICBjbHVzdGVySW5kZXhbaV0ucHVzaChjbHVzdGVySW5kZXhbMF1bcmFuZG9tSWRdKVxyXG4gICAgICAgICAgICBjbHVzdGVySW5kZXhbMF0uc3BsaWNlKHJhbmRvbUlkLCAxKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICB0aGlzLnNvcnRDbHVzdGVySW5kZXhCeVNpemUoY2x1c3RlckluZGV4KVxyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBpZiAoaXNGaW5pc2gpIHtcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICB9XHJcblxyXG4gICAgICBPYmplY3Qua2V5cyhjbHVzdGVySW5kZXgpLmZvckVhY2goZ3JvdXBJZCA9PiB7XHJcbiAgICAgICAgY2x1c3RlckluZGV4W2dyb3VwSWRdLmZvckVhY2goaSA9PiB7XHJcbiAgICAgICAgICB2ZWN0b3JbaV0ucHVzaChOdW1iZXIoZ3JvdXBJZCkpXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiB2ZWN0b3JcclxuICAgIH0sXHJcbiAgICBzb3J0Q2x1c3RlckluZGV4QnlTaXplIChjbHVzdGVySW5kZXgpIHtcclxuICAgICAgY2x1c3RlckluZGV4LnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aFxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgR3JvdXBpbmdUb29sIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS02IS4vR3JvdXBpbmdUb29sLmpzP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTYhLi9Hcm91cGluZ1Rvb2wuanM/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0dyb3VwaW5nVG9vbC5odG1sP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTFkMDY2YmMwJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0dyb3VwaW5nVG9vbC5qcz92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vR3JvdXBpbmdUb29sLmpzP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL0dyb3VwaW5nVG9vbC5sZXNzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MWQwNjZiYzAmbGFuZz1sZXNzJnNjb3BlZD10cnVlJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCIxZDA2NmJjMFwiLFxuICBudWxsXG4gIFxuKVxuXG4vKiBjdXN0b20gYmxvY2tzICovXG5pbXBvcnQgYmxvY2swIGZyb20gXCIuL0dyb3VwaW5nVG9vbC55YW1sP3Z1ZSZ0eXBlPWN1c3RvbSZpbmRleD0wJmJsb2NrVHlwZT1pMThuJmlzc3VlclBhdGg9JTJGYXBwJTJGc3JjJTJGY29tcG9uZW50cyUyRlJlcGxhY2VQYW5lbCUyRkdyb3VwaW5nVG9vbCUyRkdyb3VwaW5nVG9vbC52dWUmbGFuZz15YW1sXCJcbmlmICh0eXBlb2YgYmxvY2swID09PSAnZnVuY3Rpb24nKSBibG9jazAoY29tcG9uZW50KVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIi9hcHAvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaS9kaXN0L2luZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnMWQwNjZiYzAnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnMWQwNjZiYzAnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnMWQwNjZiYzAnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0dyb3VwaW5nVG9vbC5odG1sP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTFkMDY2YmMwJnNjb3BlZD10cnVlJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzFkMDY2YmMwJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9SZXBsYWNlUGFuZWwvR3JvdXBpbmdUb29sL0dyb3VwaW5nVG9vbC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBOzs7O0FDaEtBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQVNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFqRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXFGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQSw2QkFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUFBO0FBNUNBO0FBQUE7QUFBQTtBQUFBO0FBK0NBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUEsNkJBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUFBO0FBQUE7QUFwQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXlCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUMvU0E7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBaUJBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///424\n')}}]);