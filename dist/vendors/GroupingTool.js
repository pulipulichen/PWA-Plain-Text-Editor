(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{114:function(module,exports,__webpack_require__){eval("var content = __webpack_require__(386);\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(7)(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz85MGFmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0zIS4vR3JvdXBpbmdUb29sLmxlc3M/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xZDA2NmJjMCZsYW5nPWxlc3Mmc2NvcGVkPXRydWUmXCIpO1xuXG5pZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbn1cblxudmFyIG9wdGlvbnMgPSB7fVxuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZiAoY29udGVudC5sb2NhbHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///114\n")},115:function(module,exports){eval('module.exports = function (Component) {\n  Component.options.__i18n = Component.options.__i18n || []\n  Component.options.__i18n.push(\'{"en-US":{"Search":"Search"},"zh-TW":{"Search":"搜尋"}}\')\n  delete Component.options._Ctor\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wueWFtbD8xOGVhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICBDb21wb25lbnQub3B0aW9ucy5fX2kxOG4gPSBDb21wb25lbnQub3B0aW9ucy5fX2kxOG4gfHwgW11cbiAgQ29tcG9uZW50Lm9wdGlvbnMuX19pMThuLnB1c2goJ3tcImVuLVVTXCI6e1wiU2VhcmNoXCI6XCJTZWFyY2hcIn0sXCJ6aC1UV1wiOntcIlNlYXJjaFwiOlwi5pCc5bCLXCJ9fScpXG4gIGRlbGV0ZSBDb21wb25lbnQub3B0aW9ucy5fQ3RvclxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///115\n')},385:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(114);\n/* harmony import */ var _node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz82YzliIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMyEuL0dyb3VwaW5nVG9vbC5sZXNzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MWQwNjZiYzAmbGFuZz1sZXNzJnNjb3BlZD10cnVlJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTMhLi9Hcm91cGluZ1Rvb2wubGVzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFkMDY2YmMwJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///385\n")},386:function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(6)(true);\n// Module\nexports.push([module.i, "input[data-v-1d066bc0]{width:5rem!important}select[data-v-1d066bc0]{width:auto!important}label[data-v-1d066bc0]{width:4rem!important;text-align:right!important}button[data-v-1d066bc0],label[data-v-1d066bc0]{margin-right:1rem!important}", "",{"version":3,"sources":["/app/src/components/ReplacePanel/GroupingTool/GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&","/app/src/components/ReplacePanel/GroupingTool/GroupingTool.less"],"names":[],"mappings":"AAAA,uBACE,oBCCF,CDMA,wBACE,oBCJF,CDQA,uBAEE,oBAAA,CACA,0BCNF,CDQA,+CAJE,2BCDF","file":"GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&","sourcesContent":["input {\\n  width: 5rem !important;\\n}\\n\\n// .GroupingTool {\\n//   margin-top: 0.2rem !important;\\n// }\\n\\nselect {\\n  width: auto !important;\\n}\\n\\n\\nlabel {\\n  margin-right: 1rem !important;\\n  width: 4rem !important;\\n  text-align: right !important;\\n}\\nbutton {\\n  margin-right: 1rem !important;\\n}","input {\\n  width: 5rem !important;\\n}\\nselect {\\n  width: auto !important;\\n}\\nlabel {\\n  margin-right: 1rem !important;\\n  width: 4rem !important;\\n  text-align: right !important;\\n}\\nbutton {\\n  margin-right: 1rem !important;\\n}\\n"]}]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz81MWRiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKHRydWUpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJpbnB1dFtkYXRhLXYtMWQwNjZiYzBde3dpZHRoOjVyZW0haW1wb3J0YW50fXNlbGVjdFtkYXRhLXYtMWQwNjZiYzBde3dpZHRoOmF1dG8haW1wb3J0YW50fWxhYmVsW2RhdGEtdi0xZDA2NmJjMF17d2lkdGg6NHJlbSFpbXBvcnRhbnQ7dGV4dC1hbGlnbjpyaWdodCFpbXBvcnRhbnR9YnV0dG9uW2RhdGEtdi0xZDA2NmJjMF0sbGFiZWxbZGF0YS12LTFkMDY2YmMwXXttYXJnaW4tcmlnaHQ6MXJlbSFpbXBvcnRhbnR9XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL2FwcC9zcmMvY29tcG9uZW50cy9SZXBsYWNlUGFuZWwvR3JvdXBpbmdUb29sL0dyb3VwaW5nVG9vbC5sZXNzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MWQwNjZiYzAmbGFuZz1sZXNzJnNjb3BlZD10cnVlJlwiLFwiL2FwcC9zcmMvY29tcG9uZW50cy9SZXBsYWNlUGFuZWwvR3JvdXBpbmdUb29sL0dyb3VwaW5nVG9vbC5sZXNzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLHVCQUNFLG9CQ0NGLENETUEsd0JBQ0Usb0JDSkYsQ0RRQSx1QkFFRSxvQkFBQSxDQUNBLDBCQ05GLENEUUEsK0NBSkUsMkJDREZcIixcImZpbGVcIjpcIkdyb3VwaW5nVG9vbC5sZXNzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MWQwNjZiYzAmbGFuZz1sZXNzJnNjb3BlZD10cnVlJlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJpbnB1dCB7XFxuICB3aWR0aDogNXJlbSAhaW1wb3J0YW50O1xcbn1cXG5cXG4vLyAuR3JvdXBpbmdUb29sIHtcXG4vLyAgIG1hcmdpbi10b3A6IDAuMnJlbSAhaW1wb3J0YW50O1xcbi8vIH1cXG5cXG5zZWxlY3Qge1xcbiAgd2lkdGg6IGF1dG8gIWltcG9ydGFudDtcXG59XFxuXFxuXFxubGFiZWwge1xcbiAgbWFyZ2luLXJpZ2h0OiAxcmVtICFpbXBvcnRhbnQ7XFxuICB3aWR0aDogNHJlbSAhaW1wb3J0YW50O1xcbiAgdGV4dC1hbGlnbjogcmlnaHQgIWltcG9ydGFudDtcXG59XFxuYnV0dG9uIHtcXG4gIG1hcmdpbi1yaWdodDogMXJlbSAhaW1wb3J0YW50O1xcbn1cIixcImlucHV0IHtcXG4gIHdpZHRoOiA1cmVtICFpbXBvcnRhbnQ7XFxufVxcbnNlbGVjdCB7XFxuICB3aWR0aDogYXV0byAhaW1wb3J0YW50O1xcbn1cXG5sYWJlbCB7XFxuICBtYXJnaW4tcmlnaHQ6IDFyZW0gIWltcG9ydGFudDtcXG4gIHdpZHRoOiA0cmVtICFpbXBvcnRhbnQ7XFxuICB0ZXh0LWFsaWduOiByaWdodCAhaW1wb3J0YW50O1xcbn1cXG5idXR0b24ge1xcbiAgbWFyZ2luLXJpZ2h0OiAxcmVtICFpbXBvcnRhbnQ7XFxufVxcblwiXX1dKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///386\n')},387:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(115);\n/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__);\n /* harmony default export */ __webpack_exports__["default"] = (_node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wueWFtbD8zYWFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BrYXp1cG9uL3Z1ZS1pMThuLWxvYWRlci9saWIvaW5kZXguanMhLi9Hcm91cGluZ1Rvb2wueWFtbD92dWUmdHlwZT1jdXN0b20maW5kZXg9MCZibG9ja1R5cGU9aTE4biZpc3N1ZXJQYXRoPSUyRmFwcCUyRnNyYyUyRmNvbXBvbmVudHMlMkZSZXBsYWNlUGFuZWwlMkZHcm91cGluZ1Rvb2wlMkZHcm91cGluZ1Rvb2wudnVlJmxhbmc9eWFtbFwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2F6dXBvbi92dWUtaTE4bi1sb2FkZXIvbGliL2luZGV4LmpzIS4vR3JvdXBpbmdUb29sLnlhbWw/dnVlJnR5cGU9Y3VzdG9tJmluZGV4PTAmYmxvY2tUeXBlPWkxOG4maXNzdWVyUGF0aD0lMkZhcHAlMkZzcmMlMkZjb21wb25lbnRzJTJGUmVwbGFjZVBhbmVsJTJGR3JvdXBpbmdUb29sJTJGR3JvdXBpbmdUb29sLnZ1ZSZsYW5nPXlhbWxcIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///387\n')},424:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./src/components/ReplacePanel/GroupingTool/GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c("div", { staticClass: "GroupingTool" }, [\n    _c("div", { staticClass: "fields" }, [\n      _c("label", { attrs: { for: "GroupingToolSkipColumns" } }, [\n        _vm._v("\\n      " + _vm._s(_vm.$t("Skip Cols")) + "\\n    ")\n      ]),\n      _vm._v(" "),\n      _c("input", {\n        directives: [\n          {\n            name: "model",\n            rawName: "v-model",\n            value: _vm.localConfig.GroupingTool.skipColumns,\n            expression: "localConfig.GroupingTool.skipColumns"\n          }\n        ],\n        attrs: { type: "number", id: "GroupingToolSkipColumns" },\n        domProps: { value: _vm.localConfig.GroupingTool.skipColumns },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig.GroupingTool,\n              "skipColumns",\n              $event.target.value\n            )\n          }\n        }\n      }),\n      _vm._v(" "),\n      _c(\n        "select",\n        {\n          directives: [\n            {\n              name: "model",\n              rawName: "v-model",\n              value: _vm.localConfig.GroupingTool.groupType,\n              expression: "localConfig.GroupingTool.groupType"\n            }\n          ],\n          on: {\n            change: function($event) {\n              var $$selectedVal = Array.prototype.filter\n                .call($event.target.options, function(o) {\n                  return o.selected\n                })\n                .map(function(o) {\n                  var val = "_value" in o ? o._value : o.value\n                  return val\n                })\n              _vm.$set(\n                _vm.localConfig.GroupingTool,\n                "groupType",\n                $event.target.multiple ? $$selectedVal : $$selectedVal[0]\n              )\n            }\n          }\n        },\n        [\n          _c("option", { attrs: { value: "group" } }, [\n            _vm._v(_vm._s(_vm.$t("Group: ")))\n          ]),\n          _vm._v(" "),\n          _c("option", { attrs: { value: "member" } }, [\n            _vm._v(_vm._s(_vm.$t("Member: ")))\n          ])\n        ]\n      ),\n      _vm._v(" "),\n      _c("input", {\n        directives: [\n          {\n            name: "model",\n            rawName: "v-model",\n            value: _vm.localConfig.GroupingTool.groupLength,\n            expression: "localConfig.GroupingTool.groupLength"\n          }\n        ],\n        attrs: { type: "number", min: "0" },\n        domProps: { value: _vm.localConfig.GroupingTool.groupLength },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig.GroupingTool,\n              "groupLength",\n              $event.target.value\n            )\n          }\n        }\n      }),\n      _vm._v(" "),\n      _c(\n        "button",\n        {\n          staticClass: "ui icon button basic",\n          attrs: { type: "button" },\n          on: { click: _vm.removeLastColumn }\n        },\n        [_c("i", { staticClass: "undo icon" })]\n      )\n    ])\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js\nvar helpers_typeof = __webpack_require__(1);\nvar typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__(2);\nvar asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);\n\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/kmeans.js\n\nvar MAX_ITERATIONS = 50;\nfunction randomBetween(min, max) {\n  return Math.floor(Math.random() * (max - min) + min);\n}\nfunction calcMeanCentroid(dataSet, start, end) {\n  var features = dataSet[0].length;\n  var n = end - start;\n  var mean = [];\n  for (var i = 0; i < features; i++) {\n    mean.push(0);\n  }\n  for (var _i = start; _i < end; _i++) {\n    for (var j = 0; j < features; j++) {\n      mean[j] = mean[j] + dataSet[_i][j] / n;\n    }\n  }\n  return mean;\n}\nfunction getRandomCentroidsNaiveSharding(dataset, k) {\n  // implementation of a variation of naive sharding centroid initialization method\n  // (not using sums or sorting, just dividing into k shards and calc mean)\n  // https://www.kdnuggets.com/2017/03/naive-sharding-centroid-initialization-method.html\n  var numSamples = dataset.length;\n  // Divide dataset into k shards:\n  var step = Math.floor(numSamples / k);\n  // console.log(step);\n  var centroids = [];\n  for (var i = 0; i < k; i++) {\n    var start = step * i;\n    var end = step * (i + 1);\n    if (i + 1 === k) {\n      end = numSamples;\n    }\n    // console.log(start, end);\n    centroids.push(calcMeanCentroid(dataset, start, end));\n  }\n  return centroids;\n}\nfunction getRandomCentroids(dataset, k) {\n  // selects random points as centroids from the dataset\n  var numSamples = dataset.length;\n  var centroidsIndex = [];\n  var index;\n  while (centroidsIndex.length < k) {\n    index = randomBetween(0, numSamples);\n    if (centroidsIndex.indexOf(index) === -1) {\n      centroidsIndex.push(index);\n    }\n  }\n  var centroids = [];\n  for (var i = 0; i < centroidsIndex.length; i++) {\n    var centroid = [].concat(dataset[centroidsIndex[i]]);\n    centroids.push(centroid);\n  }\n  return centroids;\n}\nfunction compareCentroids(a, b) {\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shouldStop(oldCentroids, centroids, iterations) {\n  if (iterations > MAX_ITERATIONS) {\n    return true;\n  }\n  if (!oldCentroids || !oldCentroids.length) {\n    return false;\n  }\n  var sameCount = true;\n  for (var i = 0; i < centroids.length; i++) {\n    if (!compareCentroids(centroids[i], oldCentroids[i])) {\n      sameCount = false;\n    }\n  }\n  return sameCount;\n}\n\n// Calculate Squared Euclidean Distance\nfunction getDistanceSQ(a, b) {\n  var diffs = [];\n  for (var i = 0; i < a.length; i++) {\n    diffs.push(a[i] - b[i]);\n  }\n  return diffs.reduce(function (r, e) {\n    return r + e * e;\n  }, 0);\n}\n\n// Returns a label for each piece of data in the dataset. \nfunction getLabels(dataSet, centroids) {\n  // prep data structure:\n  var labels = {};\n  for (var c = 0; c < centroids.length; c++) {\n    labels[c] = {\n      points: [],\n      centroid: centroids[c],\n      indexes: []\n    };\n  }\n  // For each element in the dataset, choose the closest centroid. \n  // Make that centroid the element\'s label.\n  for (var i = 0; i < dataSet.length; i++) {\n    var a = dataSet[i];\n    var closestCentroid = void 0,\n      closestCentroidIndex = void 0,\n      prevDistance = void 0;\n    for (var j = 0; j < centroids.length; j++) {\n      var centroid = centroids[j];\n      if (j === 0) {\n        closestCentroid = centroid;\n        closestCentroidIndex = j;\n        prevDistance = getDistanceSQ(a, closestCentroid);\n      } else {\n        // get distance:\n        var distance = getDistanceSQ(a, centroid);\n        if (distance < prevDistance) {\n          prevDistance = distance;\n          closestCentroid = centroid;\n          closestCentroidIndex = j;\n        }\n      }\n    }\n    // add point to centroid labels:\n    labels[closestCentroidIndex].points.push(a);\n    labels[closestCentroidIndex].indexes.push(i);\n  }\n  return labels;\n}\nfunction getPointsMean(pointList) {\n  var totalPoints = pointList.length;\n  var means = [];\n  for (var j = 0; j < pointList[0].length; j++) {\n    means.push(0);\n  }\n  for (var i = 0; i < pointList.length; i++) {\n    var point = pointList[i];\n    for (var _j = 0; _j < point.length; _j++) {\n      var val = point[_j];\n      means[_j] = means[_j] + val / totalPoints;\n    }\n  }\n  return means;\n}\nfunction recalculateCentroids(dataSet, labels, k) {\n  // Each centroid is the geometric mean of the points that\n  // have that centroid\'s label. Important: If a centroid is empty (no points have\n  // that centroid\'s label) you should randomly re-initialize it.\n  var newCentroid;\n  var newCentroidList = [];\n  for (var _k in labels) {\n    var centroidGroup = labels[_k];\n    if (centroidGroup.points.length > 0) {\n      // find mean:\n      newCentroid = getPointsMean(centroidGroup.points);\n    } else {\n      // get new random centroid\n      newCentroid = getRandomCentroids(dataSet, 1)[0];\n    }\n    newCentroidList.push(newCentroid);\n  }\n  return newCentroidList;\n}\nfunction kmeans_kmeans(dataset, k) {\n  var useNaiveSharding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'auto\';\n  if (useNaiveSharding === \'auto\') {\n    useNaiveSharding = dataset.length > 4;\n  }\n  //   console.log(dataset)\n  if (dataset.length && dataset[0].length && dataset.length > k) {\n    var _ret = function () {\n      // Initialize book keeping variables\n      var iterations = 0;\n      var oldCentroids, labels, centroids;\n\n      // Initialize centroids randomly\n      if (useNaiveSharding) {\n        centroids = getRandomCentroidsNaiveSharding(dataset, k);\n      } else {\n        centroids = getRandomCentroids(dataset, k);\n      }\n      // console.log(centroids)\n\n      // Run the main k-means algorithm\n      while (!shouldStop(oldCentroids, centroids, iterations)) {\n        // Save old centroids for convergence test.\n        oldCentroids = [].concat(centroids);\n        iterations++;\n\n        // Assign labels to each datapoint based on centroids\n        labels = getLabels(dataset, centroids);\n        // console.log(oldCentroids)\n        centroids = recalculateCentroids(dataset, labels, k);\n        // console.log(centroids)\n      }\n\n      var clusters = [];\n      var datasetLabels = new Array(dataset.length);\n      var _loop = function _loop(i) {\n        clusters.push(labels[i].indexes);\n        labels[i].indexes.forEach(function (datasetIndex) {\n          datasetLabels[datasetIndex] = i;\n        });\n      };\n      for (var i = 0; i < k; i++) {\n        _loop(i);\n      }\n      var results = {\n        datasetLabels: datasetLabels,\n        clusterVector: datasetLabels,\n        clusters: clusters,\n        clusterIndex: clusters,\n        centroids: centroids,\n        iterations: iterations,\n        converged: iterations <= MAX_ITERATIONS\n      };\n      return {\n        v: results\n      };\n    }();\n    if (typeof_default()(_ret) === "object") return _ret.v;\n  } else {\n    throw new Error(\'Invalid dataset\');\n  }\n}\n/* harmony default export */ var GroupingTool_kmeans = (kmeans_kmeans);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--6!./src/components/ReplacePanel/GroupingTool/GroupingTool.js?vue&type=script&lang=js&\n\n\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof_default()(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nvar GroupingTool = {\n  props: [\'config\', \'localConfig\', \'utils\'],\n  data: function data() {\n    this.$i18n.locale = this.localConfig.locale;\n    return {};\n  },\n  watch: {\n    \'localConfig.locale\': function localConfigLocale() {\n      this.$i18n.locale = this.localConfig.locale;\n    }\n  },\n  // computed: {\n\n  // },\n  // mounted: async function () {\n  //   this.test202210301729()\n  // },\n  methods: {\n    test202210300033: function () {\n      var _test = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var vector;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // var vector = [\n                //   [1, 10, 2, 30],\n                //   [\'A\', 30, 20, 2],\n                //   [\'B\', 30, 30, 3],\n                //   [\'C\', 30, 31, 3],\n                //   [\'A\', 10, 10, 1],\n                //   [\'B\', 20, 1, 30],\n                //   [\'C\', 1, 25, 30]\n                // ]\n                vector = [[10, 2, 30], [30, 20, 2], [30, 30, 3], [30, 31, 3], [10, 10, 1], [20, 1, 30], [1, 25, 30]]; // console.log(await this.toVector(vector))\n                // console.log(await this.addKmeans(vector))\n                // console.log(await this.addGroupInDifference(vector))\n                // console.log(await this.addGroupInSimilarity(vector))\n                // console.log(vector)\n                _context.t0 = console;\n                _context.next = 4;\n                return this.kmeans(vector, 3);\n              case 4:\n                _context.t1 = _context.sent;\n                _context.t0.log.call(_context.t0, _context.t1);\n              case 6:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function test202210300033() {\n        return _test.apply(this, arguments);\n      }\n      return test202210300033;\n    }(),\n    test202210301729: function () {\n      var _test2 = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var vector;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                vector = [[1, 2, 3, 1], [5, 2, 3, 1], [1, 2, 4, 0], [5, 3, 4, 0]]; // console.log(await this.toVector(vector))\n                // console.log(await this.addKmeans(vector))\n                // console.log(vector)\n                // console.log(await this.kmeans(vector, 2))\n                // console.log(await this.groupingBySimilarity(vector, \'member\', 2))\n                // console.log(await this.groupingByDifference(vector, \'member\', 2))\n              case 1:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      function test202210301729() {\n        return _test2.apply(this, arguments);\n      }\n      return test202210301729;\n    }(),\n    toVector: function () {\n      var _toVector = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(data) {\n        var rows, columeLength, c, list, isColumnNumber, d, value, isNumber, _ret, map, id, _d, _value, vectors, v, keys, i, _d2, _value2, _i, v2;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // console.log(data)\n                rows = new Array(data.length);\n                columeLength = data[0].length;\n                c = this.localConfig.GroupingTool.skipColumns;\n              case 3:\n                if (!(c < columeLength)) {\n                  _context3.next = 37;\n                  break;\n                }\n                list = [];\n                isColumnNumber = true;\n                d = 0;\n              case 7:\n                if (!(d < data.length)) {\n                  _context3.next = 19;\n                  break;\n                }\n                value = data[d][c];\n                isNumber = typeof value === \'number\';\n                if (!(isNumber === false)) {\n                  _context3.next = 15;\n                  break;\n                }\n                isColumnNumber = false;\n                return _context3.abrupt("break", 19);\n              case 15:\n                list.push(value);\n              case 16:\n                d++;\n                _context3.next = 7;\n                break;\n              case 19:\n                if (!(isColumnNumber === true)) {\n                  _context3.next = 25;\n                  break;\n                }\n                _ret = function () {\n                  var max = Math.max.apply(Math, list);\n                  var min = Math.min.apply(Math, list);\n                  var range = max - min;\n                  if (range === 0) {\n                    return "continue";\n                  }\n                  var normalized = void 0;\n                  if (max === 1 && min === 0) {\n                    normalized = list;\n                  } else {\n                    normalized = list.map(function (value) {\n                      return (value - min) / range;\n                    });\n                  }\n                  for (var r = 0; r < rows.length; r++) {\n                    if (!rows[r]) {\n                      rows[r] = [];\n                    }\n                    rows[r].push(normalized[r]);\n                  }\n                }();\n                if (!(_ret === "continue")) {\n                  _context3.next = 23;\n                  break;\n                }\n                return _context3.abrupt("continue", 34);\n              case 23:\n                _context3.next = 34;\n                break;\n              case 25:\n                map = {};\n                id = 0;\n                for (_d = 0; _d < data.length; _d++) {\n                  _value = data[_d][c];\n                  _value = _value + \'\';\n                  // console.log(value)\n                  if (!map[_value]) {\n                    map[_value] = id;\n                    id++;\n                  }\n                  list.push(_value);\n                }\n\n                // console.log(map, list)\n                vectors = [];\n                v = [];\n                keys = Object.keys(map);\n                for (i = 0; i < keys.length; i++) {\n                  v[i] = 0;\n                }\n                // console.log(v)\n\n                for (_d2 = 0; _d2 < data.length; _d2++) {\n                  _value2 = data[_d2][c];\n                  _value2 = _value2 + \'\';\n                  _i = keys.indexOf(_value2); // console.log(i)\n                  v2 = [].concat(v);\n                  v2[_i] = 1;\n                  vectors.push(v2);\n                }\n                // console.log(vectors)\n\n                vectors.forEach(function (vector, r) {\n                  if (!rows[r]) {\n                    rows[r] = [];\n                  }\n                  rows[r] = rows[r].concat(vector);\n                });\n              case 34:\n                c++;\n                _context3.next = 3;\n                break;\n              case 37:\n                return _context3.abrupt("return", rows);\n              case 38:\n              case "end":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function toVector(_x) {\n        return _toVector.apply(this, arguments);\n      }\n      return toVector;\n    }(),\n    // kmeans: async function (data, cluster = 3) {\n    //   let vector = await this.toVector(data)\n    //   return new Promise(function (resolve, reject) {\n    //     // console.log(cluster)\n    //     kmeans(vector, cluster, function(err, clusterVector, clusterIndex, cluster, centroids) {\n    //       if (err) {\n    //         // throw new Error(err)\n    //         return reject(err)\n    //       }\n\n    //       //do something with the result\n    //       // console.log(res)\n    //       resolve({\n    //         clusterVector,\n    //         clusterIndex,\n    //         cluster,\n    //         centroids\n    //       })\n    //     })\n    //   })\n    //   // console.log(vector) \n    // },\n    kmeans: function () {\n      var _kmeans2 = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(data) {\n        var cluster,\n          vector,\n          result,\n          _args4 = arguments;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                cluster = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : 3;\n                _context4.next = 3;\n                return this.toVector(data);\n              case 3:\n                vector = _context4.sent;\n                // return new Promise(function (resolve, reject) {\n                // console.log(cluster)\n                // resovle(kmeans(vector, cluster))\n                // })\n                // console.log(vector) \n                result = GroupingTool_kmeans(vector, cluster); // console.log(result)\n                return _context4.abrupt("return", result);\n              case 6:\n              case "end":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function kmeans(_x2) {\n        return _kmeans2.apply(this, arguments);\n      }\n      return kmeans;\n    }(),\n    addKmeans: function () {\n      var _addKmeans = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(vector) {\n        var cluster,\n          result,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                cluster = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : 3;\n                _context5.next = 3;\n                return this.kmeans(vector, cluster);\n              case 3:\n                result = _context5.sent;\n                return _context5.abrupt("return", vector.map(function (item, i) {\n                  // console.log(item, i, result.clusterIndex)\n                  item.push(result.clusterVector[i]);\n                  return item;\n                }));\n              case 5:\n              case "end":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function addKmeans(_x3) {\n        return _addKmeans.apply(this, arguments);\n      }\n      return addKmeans;\n    }(),\n    groupingByDifference: function () {\n      var _groupingByDifference = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(vector) {\n        var groupType,\n          member,\n          result,\n          groups,\n          groupIndexList,\n          mod,\n          minMembers,\n          counter,\n          i,\n          group,\n          clusterI,\n          baseMember,\n          v,\n          randomId,\n          item,\n          output,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                groupType = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : \'member\';\n                member = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : 3;\n                member = Number(member);\n                _context6.next = 5;\n                return this.kmeans(vector, member);\n              case 5:\n                result = _context6.sent;\n                // console.log(result)\n                groups = Math.ceil(vector.length / member);\n                if (groupType === \'group\') {\n                  groups = member;\n                  member = Number(Math.floor(vector.length / groups));\n                }\n                // console.log(groups, member)\n                groupIndexList = [];\n                mod = vector.length % groups;\n                minMembers = Math.floor(vector.length / groups);\n                counter = 0; // console.log(groups)\n                i = 0;\n              case 13:\n                if (!(i < groups)) {\n                  _context6.next = 39;\n                  break;\n                }\n                group = [];\n                clusterI = 0;\n                baseMember = minMembers;\n                if (i < mod) {\n                  baseMember++;\n                }\n\n                // console.log(baseMember)\n                // continue\n              case 18:\n                if (false) {}\n                v = result.clusterIndex[clusterI % groups]; // console.log(v, counter, vector.length) \n                if (!(v.length === 0)) {\n                  _context6.next = 23;\n                  break;\n                }\n                clusterI++;\n                return _context6.abrupt("continue", 18);\n              case 23:\n                randomId = Math.floor(Math.random() * v.length);\n                item = v[randomId];\n                group.push(Number(item));\n                // console.log(item)\n\n                v.splice(randomId, 1);\n                // console.log(vector)\n                // clusterVector[(clusterI % member)] = v\n                // console.log(result.clusterVector)\n                // console.log(v)\n\n                clusterI++;\n                counter++;\n                // console.log(counter, group.length, member)\n                if (!(counter === vector.length)) {\n                  _context6.next = 31;\n                  break;\n                }\n                return _context6.abrupt("break", 35);\n              case 31:\n                if (!(group.length === baseMember)) {\n                  _context6.next = 33;\n                  break;\n                }\n                return _context6.abrupt("break", 35);\n              case 33:\n                _context6.next = 18;\n                break;\n              case 35:\n                // console.log(group)\n                groupIndexList.push(group);\n              case 36:\n                i++;\n                _context6.next = 13;\n                break;\n              case 39:\n                // console.log(groupIndexList)\n                // let invertGroup = new Array(groups)\n                output = [].concat(vector);\n                groupIndexList.forEach(function (list, groupId) {\n                  list.forEach(function (index) {\n                    var o = [].concat(output[index]);\n                    o.push(groupId);\n                    output[index] = o;\n                  });\n                });\n                return _context6.abrupt("return", output);\n              case 42:\n              case "end":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function groupingByDifference(_x4) {\n        return _groupingByDifference.apply(this, arguments);\n      }\n      return groupingByDifference;\n    }(),\n    groupingBySimilarity: function () {\n      var _groupingBySimilarity = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(vector) {\n        var groupType,\n          member,\n          groups,\n          _yield$this$kmeans,\n          clusterIndex,\n          isFinish,\n          i,\n          list,\n          randomId,\n          _randomId,\n          _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                groupType = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : \'member\';\n                member = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : 3;\n                member = Number(member);\n                groups = Math.ceil(vector.length / member);\n                if (groupType === \'group\') {\n                  groups = member;\n                  member = Math.ceil(vector.length / groups);\n                }\n\n                // console.log(groups, member)\n                _context7.next = 7;\n                return this.kmeans(vector, groups);\n              case 7:\n                _yield$this$kmeans = _context7.sent;\n                clusterIndex = _yield$this$kmeans.clusterIndex;\n                // console.log(clusterIndex) \n                this.sortClusterIndexBySize(clusterIndex);\n              case 10:\n                if (false) {}\n                isFinish = true;\n                i = 0;\n              case 13:\n                if (!(i < clusterIndex.length)) {\n                  _context7.next = 24;\n                  break;\n                }\n                list = clusterIndex[i];\n                if (!(list.length <= member && list.length >= member - 1)) {\n                  _context7.next = 17;\n                  break;\n                }\n                return _context7.abrupt("continue", 21);\n              case 17:\n                isFinish = false;\n                if (list.length > member) {\n                  randomId = Math.floor(Math.random() * list.length);\n                  clusterIndex[clusterIndex.length - 1].push(list[randomId]);\n                  list.splice(randomId, 1);\n                } else {\n                  _randomId = Math.floor(Math.random() * clusterIndex[0].length);\n                  clusterIndex[i].push(clusterIndex[0][_randomId]);\n                  clusterIndex[0].splice(_randomId, 1);\n                }\n                this.sortClusterIndexBySize(clusterIndex);\n                return _context7.abrupt("break", 24);\n              case 21:\n                i++;\n                _context7.next = 13;\n                break;\n              case 24:\n                if (!isFinish) {\n                  _context7.next = 26;\n                  break;\n                }\n                return _context7.abrupt("break", 28);\n              case 26:\n                _context7.next = 10;\n                break;\n              case 28:\n                Object.keys(clusterIndex).forEach(function (groupId) {\n                  clusterIndex[groupId].forEach(function (i) {\n                    vector[i].push(Number(groupId));\n                  });\n                });\n                return _context7.abrupt("return", vector);\n              case 30:\n              case "end":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function groupingBySimilarity(_x5) {\n        return _groupingBySimilarity.apply(this, arguments);\n      }\n      return groupingBySimilarity;\n    }(),\n    sortClusterIndexBySize: function sortClusterIndexBySize(clusterIndex) {\n      clusterIndex.sort(function (a, b) {\n        return b.length - a.length;\n      });\n    },\n    removeLastColumn: function removeLastColumn() {\n      var data = this.$parent.dataMatrix;\n      // console.log(data)\n      data = data.map(function (row) {\n        return row.slice(0, row.length - 1);\n      });\n      // console.log(data)\n      this.localConfig.textContent = data.map(function (line) {\n        return line.join(\'\\t\');\n      }).join(\'\\n\');\n    }\n  }\n};\n/* harmony default export */ var GroupingToolvue_type_script_lang_js_ = (GroupingTool);\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.js?vue&type=script&lang=js&\n /* harmony default export */ var GroupingTool_GroupingToolvue_type_script_lang_js_ = (GroupingToolvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\nvar GroupingToolvue_type_style_index_0_id_1d066bc0_lang_less_scoped_true_ = __webpack_require__(385);\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(8);\n\n// EXTERNAL MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.yaml?vue&type=custom&index=0&blockType=i18n&issuerPath=%2Fapp%2Fsrc%2Fcomponents%2FReplacePanel%2FGroupingTool%2FGroupingTool.vue&lang=yaml\nvar GroupingToolvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml = __webpack_require__(387);\n\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  GroupingTool_GroupingToolvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "1d066bc0",\n  null\n  \n)\n\n/* custom blocks */\n\nif (typeof GroupingToolvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml["default"] === \'function\') Object(GroupingToolvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml["default"])(component)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "src/components/ReplacePanel/GroupingTool/GroupingTool.vue"\n/* harmony default export */ var GroupingTool_GroupingTool = __webpack_exports__["default"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wuaHRtbD85ZWIzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1JlcGxhY2VQYW5lbC9Hcm91cGluZ1Rvb2wva21lYW5zLmpzPzFhODIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wuanM/ZDZhYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9SZXBsYWNlUGFuZWwvR3JvdXBpbmdUb29sL0dyb3VwaW5nVG9vbC5qcz85NTAxIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1JlcGxhY2VQYW5lbC9Hcm91cGluZ1Rvb2wvR3JvdXBpbmdUb29sLnZ1ZT85NWQ4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJHcm91cGluZ1Rvb2xcIiB9LCBbXG4gICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJmaWVsZHNcIiB9LCBbXG4gICAgICBfYyhcImxhYmVsXCIsIHsgYXR0cnM6IHsgZm9yOiBcIkdyb3VwaW5nVG9vbFNraXBDb2x1bW5zXCIgfSB9LCBbXG4gICAgICAgIF92bS5fdihcIlxcbiAgICAgIFwiICsgX3ZtLl9zKF92bS4kdChcIlNraXAgQ29sc1wiKSkgKyBcIlxcbiAgICBcIilcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICB2YWx1ZTogX3ZtLmxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5za2lwQ29sdW1ucyxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IFwibG9jYWxDb25maWcuR3JvdXBpbmdUb29sLnNraXBDb2x1bW5zXCJcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGF0dHJzOiB7IHR5cGU6IFwibnVtYmVyXCIsIGlkOiBcIkdyb3VwaW5nVG9vbFNraXBDb2x1bW5zXCIgfSxcbiAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuc2tpcENvbHVtbnMgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBpbnB1dDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdm0uJHNldChcbiAgICAgICAgICAgICAgX3ZtLmxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbCxcbiAgICAgICAgICAgICAgXCJza2lwQ29sdW1uc1wiLFxuICAgICAgICAgICAgICAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJzZWxlY3RcIixcbiAgICAgICAge1xuICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuZ3JvdXBUeXBlLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5ncm91cFR5cGVcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNoYW5nZTogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhciAkJHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxuICAgICAgICAgICAgICAgIC5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucywgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IFwiX3ZhbHVlXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIF92bS4kc2V0KFxuICAgICAgICAgICAgICAgIF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wsXG4gICAgICAgICAgICAgICAgXCJncm91cFR5cGVcIixcbiAgICAgICAgICAgICAgICAkZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwib3B0aW9uXCIsIHsgYXR0cnM6IHsgdmFsdWU6IFwiZ3JvdXBcIiB9IH0sIFtcbiAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLiR0KFwiR3JvdXA6IFwiKSkpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcIm9wdGlvblwiLCB7IGF0dHJzOiB7IHZhbHVlOiBcIm1lbWJlclwiIH0gfSwgW1xuICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0uJHQoXCJNZW1iZXI6IFwiKSkpXG4gICAgICAgICAgXSlcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgdmFsdWU6IF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuZ3JvdXBMZW5ndGgsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBcImxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5ncm91cExlbmd0aFwiXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhdHRyczogeyB0eXBlOiBcIm51bWJlclwiLCBtaW46IFwiMFwiIH0sXG4gICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0ubG9jYWxDb25maWcuR3JvdXBpbmdUb29sLmdyb3VwTGVuZ3RoIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3ZtLiRzZXQoXG4gICAgICAgICAgICAgIF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wsXG4gICAgICAgICAgICAgIFwiZ3JvdXBMZW5ndGhcIixcbiAgICAgICAgICAgICAgJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXG4gICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJ1aSBpY29uIGJ1dHRvbiBiYXNpY1wiLFxuICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnJlbW92ZUxhc3RDb2x1bW4gfVxuICAgICAgICB9LFxuICAgICAgICBbX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwidW5kbyBpY29uXCIgfSldXG4gICAgICApXG4gICAgXSlcbiAgXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJjb25zdCBNQVhfSVRFUkFUSU9OUyA9IDUwO1xuXG5mdW5jdGlvbiByYW5kb21CZXR3ZWVuKG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKFxuICAgIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pblxuICApO1xufVxuXG5mdW5jdGlvbiBjYWxjTWVhbkNlbnRyb2lkKGRhdGFTZXQsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgZmVhdHVyZXMgPSBkYXRhU2V0WzBdLmxlbmd0aDtcbiAgY29uc3QgbiA9IGVuZCAtIHN0YXJ0O1xuICBsZXQgbWVhbiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZlYXR1cmVzOyBpKyspIHtcbiAgICBtZWFuLnB1c2goMCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZlYXR1cmVzOyBqKyspIHtcbiAgICAgIG1lYW5bal0gPSBtZWFuW2pdICsgZGF0YVNldFtpXVtqXSAvIG47XG4gICAgfVxuICB9XG4gIHJldHVybiBtZWFuO1xufVxuXG5mdW5jdGlvbiBnZXRSYW5kb21DZW50cm9pZHNOYWl2ZVNoYXJkaW5nKGRhdGFzZXQsIGspIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gb2YgYSB2YXJpYXRpb24gb2YgbmFpdmUgc2hhcmRpbmcgY2VudHJvaWQgaW5pdGlhbGl6YXRpb24gbWV0aG9kXG4gIC8vIChub3QgdXNpbmcgc3VtcyBvciBzb3J0aW5nLCBqdXN0IGRpdmlkaW5nIGludG8gayBzaGFyZHMgYW5kIGNhbGMgbWVhbilcbiAgLy8gaHR0cHM6Ly93d3cua2RudWdnZXRzLmNvbS8yMDE3LzAzL25haXZlLXNoYXJkaW5nLWNlbnRyb2lkLWluaXRpYWxpemF0aW9uLW1ldGhvZC5odG1sXG4gIGNvbnN0IG51bVNhbXBsZXMgPSBkYXRhc2V0Lmxlbmd0aDtcbiAgLy8gRGl2aWRlIGRhdGFzZXQgaW50byBrIHNoYXJkczpcbiAgY29uc3Qgc3RlcCA9IE1hdGguZmxvb3IobnVtU2FtcGxlcyAvIGspO1xuICAvLyBjb25zb2xlLmxvZyhzdGVwKTtcbiAgY29uc3QgY2VudHJvaWRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBzdGVwICogaTtcbiAgICBsZXQgZW5kID0gc3RlcCAqIChpICsgMSk7XG4gICAgaWYgKGkgKyAxID09PSBrKSB7XG4gICAgICBlbmQgPSBudW1TYW1wbGVzO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhzdGFydCwgZW5kKTtcbiAgICBjZW50cm9pZHMucHVzaChjYWxjTWVhbkNlbnRyb2lkKGRhdGFzZXQsIHN0YXJ0LCBlbmQpKTtcbiAgfVxuICByZXR1cm4gY2VudHJvaWRzO1xufVxuXG5mdW5jdGlvbiBnZXRSYW5kb21DZW50cm9pZHMoZGF0YXNldCwgaykge1xuICAvLyBzZWxlY3RzIHJhbmRvbSBwb2ludHMgYXMgY2VudHJvaWRzIGZyb20gdGhlIGRhdGFzZXRcbiAgY29uc3QgbnVtU2FtcGxlcyA9IGRhdGFzZXQubGVuZ3RoO1xuICBjb25zdCBjZW50cm9pZHNJbmRleCA9IFtdO1xuICBsZXQgaW5kZXg7XG4gIHdoaWxlIChjZW50cm9pZHNJbmRleC5sZW5ndGggPCBrKSB7XG4gICAgaW5kZXggPSByYW5kb21CZXR3ZWVuKDAsIG51bVNhbXBsZXMpO1xuICAgIGlmIChjZW50cm9pZHNJbmRleC5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgIGNlbnRyb2lkc0luZGV4LnB1c2goaW5kZXgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjZW50cm9pZHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZW50cm9pZHNJbmRleC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNlbnRyb2lkID0gW10uY29uY2F0KGRhdGFzZXRbY2VudHJvaWRzSW5kZXhbaV1dKTtcbiAgICBjZW50cm9pZHMucHVzaChjZW50cm9pZCk7XG4gIH1cbiAgcmV0dXJuIGNlbnRyb2lkcztcbn1cblxuZnVuY3Rpb24gY29tcGFyZUNlbnRyb2lkcyhhLCBiKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRTdG9wKG9sZENlbnRyb2lkcywgY2VudHJvaWRzLCBpdGVyYXRpb25zKSB7XG4gIGlmIChpdGVyYXRpb25zID4gTUFYX0lURVJBVElPTlMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIW9sZENlbnRyb2lkcyB8fCAhb2xkQ2VudHJvaWRzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgc2FtZUNvdW50ID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZW50cm9pZHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWNvbXBhcmVDZW50cm9pZHMoY2VudHJvaWRzW2ldLCBvbGRDZW50cm9pZHNbaV0pKSB7XG4gICAgICBzYW1lQ291bnQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNhbWVDb3VudDtcbn1cblxuLy8gQ2FsY3VsYXRlIFNxdWFyZWQgRXVjbGlkZWFuIERpc3RhbmNlXG5mdW5jdGlvbiBnZXREaXN0YW5jZVNRKGEsIGIpIHtcbiAgY29uc3QgZGlmZnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlmZnMucHVzaChhW2ldIC0gYltpXSk7XG4gIH1cbiAgcmV0dXJuIGRpZmZzLnJlZHVjZSgociwgZSkgPT4gKHIgKyAoZSAqIGUpKSwgMCk7XG59XG5cbi8vIFJldHVybnMgYSBsYWJlbCBmb3IgZWFjaCBwaWVjZSBvZiBkYXRhIGluIHRoZSBkYXRhc2V0LiBcbmZ1bmN0aW9uIGdldExhYmVscyhkYXRhU2V0LCBjZW50cm9pZHMpIHtcbiAgLy8gcHJlcCBkYXRhIHN0cnVjdHVyZTpcbiAgY29uc3QgbGFiZWxzID0ge307XG4gIGZvciAobGV0IGMgPSAwOyBjIDwgY2VudHJvaWRzLmxlbmd0aDsgYysrKSB7XG4gICAgbGFiZWxzW2NdID0ge1xuICAgICAgcG9pbnRzOiBbXSxcbiAgICAgIGNlbnRyb2lkOiBjZW50cm9pZHNbY10sXG4gICAgICBpbmRleGVzOiBbXVxuICAgIH07XG4gIH1cbiAgLy8gRm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgZGF0YXNldCwgY2hvb3NlIHRoZSBjbG9zZXN0IGNlbnRyb2lkLiBcbiAgLy8gTWFrZSB0aGF0IGNlbnRyb2lkIHRoZSBlbGVtZW50J3MgbGFiZWwuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YVNldC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGEgPSBkYXRhU2V0W2ldO1xuICAgIGxldCBjbG9zZXN0Q2VudHJvaWQsIGNsb3Nlc3RDZW50cm9pZEluZGV4LCBwcmV2RGlzdGFuY2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjZW50cm9pZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBjZW50cm9pZCA9IGNlbnRyb2lkc1tqXTtcbiAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgIGNsb3Nlc3RDZW50cm9pZCA9IGNlbnRyb2lkO1xuICAgICAgICBjbG9zZXN0Q2VudHJvaWRJbmRleCA9IGo7XG4gICAgICAgIHByZXZEaXN0YW5jZSA9IGdldERpc3RhbmNlU1EoYSwgY2xvc2VzdENlbnRyb2lkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldCBkaXN0YW5jZTpcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBnZXREaXN0YW5jZVNRKGEsIGNlbnRyb2lkKTtcbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgcHJldkRpc3RhbmNlKSB7XG4gICAgICAgICAgcHJldkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgY2xvc2VzdENlbnRyb2lkID0gY2VudHJvaWQ7XG4gICAgICAgICAgY2xvc2VzdENlbnRyb2lkSW5kZXggPSBqO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCBwb2ludCB0byBjZW50cm9pZCBsYWJlbHM6XG4gICAgbGFiZWxzW2Nsb3Nlc3RDZW50cm9pZEluZGV4XS5wb2ludHMucHVzaChhKTtcbiAgICBsYWJlbHNbY2xvc2VzdENlbnRyb2lkSW5kZXhdLmluZGV4ZXMucHVzaChpKTtcbiAgfVxuICByZXR1cm4gbGFiZWxzO1xufVxuXG5mdW5jdGlvbiBnZXRQb2ludHNNZWFuKHBvaW50TGlzdCkge1xuICBjb25zdCB0b3RhbFBvaW50cyA9IHBvaW50TGlzdC5sZW5ndGg7XG4gIGNvbnN0IG1lYW5zID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgcG9pbnRMaXN0WzBdLmxlbmd0aDsgaisrKSB7XG4gICAgbWVhbnMucHVzaCgwKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBvaW50ID0gcG9pbnRMaXN0W2ldO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcG9pbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHZhbCA9IHBvaW50W2pdO1xuICAgICAgbWVhbnNbal0gPSBtZWFuc1tqXSArIHZhbCAvIHRvdGFsUG9pbnRzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVhbnM7XG59XG5cbmZ1bmN0aW9uIHJlY2FsY3VsYXRlQ2VudHJvaWRzKGRhdGFTZXQsIGxhYmVscywgaykge1xuICAvLyBFYWNoIGNlbnRyb2lkIGlzIHRoZSBnZW9tZXRyaWMgbWVhbiBvZiB0aGUgcG9pbnRzIHRoYXRcbiAgLy8gaGF2ZSB0aGF0IGNlbnRyb2lkJ3MgbGFiZWwuIEltcG9ydGFudDogSWYgYSBjZW50cm9pZCBpcyBlbXB0eSAobm8gcG9pbnRzIGhhdmVcbiAgLy8gdGhhdCBjZW50cm9pZCdzIGxhYmVsKSB5b3Ugc2hvdWxkIHJhbmRvbWx5IHJlLWluaXRpYWxpemUgaXQuXG4gIGxldCBuZXdDZW50cm9pZDtcbiAgY29uc3QgbmV3Q2VudHJvaWRMaXN0ID0gW107XG4gIGZvciAoY29uc3QgayBpbiBsYWJlbHMpIHtcbiAgICBjb25zdCBjZW50cm9pZEdyb3VwID0gbGFiZWxzW2tdO1xuICAgIGlmIChjZW50cm9pZEdyb3VwLnBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBmaW5kIG1lYW46XG4gICAgICBuZXdDZW50cm9pZCA9IGdldFBvaW50c01lYW4oY2VudHJvaWRHcm91cC5wb2ludHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZXQgbmV3IHJhbmRvbSBjZW50cm9pZFxuICAgICAgbmV3Q2VudHJvaWQgPSBnZXRSYW5kb21DZW50cm9pZHMoZGF0YVNldCwgMSlbMF07XG4gICAgfVxuICAgIG5ld0NlbnRyb2lkTGlzdC5wdXNoKG5ld0NlbnRyb2lkKTtcbiAgfVxuICByZXR1cm4gbmV3Q2VudHJvaWRMaXN0O1xufVxuXG5mdW5jdGlvbiBrbWVhbnMoZGF0YXNldCwgaywgdXNlTmFpdmVTaGFyZGluZyA9ICdhdXRvJykge1xuICBpZiAodXNlTmFpdmVTaGFyZGluZyA9PT0gJ2F1dG8nKSB7XG4gICAgdXNlTmFpdmVTaGFyZGluZyA9IChkYXRhc2V0Lmxlbmd0aCA+IDQpXG4gIH1cbiAgICAvLyAgIGNvbnNvbGUubG9nKGRhdGFzZXQpXG4gIGlmIChkYXRhc2V0Lmxlbmd0aCAmJiBkYXRhc2V0WzBdLmxlbmd0aCAmJiBkYXRhc2V0Lmxlbmd0aCA+IGspIHtcbiAgICAvLyBJbml0aWFsaXplIGJvb2sga2VlcGluZyB2YXJpYWJsZXNcbiAgICBsZXQgaXRlcmF0aW9ucyA9IDA7XG4gICAgbGV0IG9sZENlbnRyb2lkcywgbGFiZWxzLCBjZW50cm9pZHM7XG5cbiAgICAvLyBJbml0aWFsaXplIGNlbnRyb2lkcyByYW5kb21seVxuICAgIGlmICh1c2VOYWl2ZVNoYXJkaW5nKSB7XG4gICAgICBjZW50cm9pZHMgPSBnZXRSYW5kb21DZW50cm9pZHNOYWl2ZVNoYXJkaW5nKGRhdGFzZXQsIGspO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZW50cm9pZHMgPSBnZXRSYW5kb21DZW50cm9pZHMoZGF0YXNldCwgayk7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKGNlbnRyb2lkcylcblxuICAgIC8vIFJ1biB0aGUgbWFpbiBrLW1lYW5zIGFsZ29yaXRobVxuICAgIHdoaWxlICghc2hvdWxkU3RvcChvbGRDZW50cm9pZHMsIGNlbnRyb2lkcywgaXRlcmF0aW9ucykpIHtcbiAgICAgIC8vIFNhdmUgb2xkIGNlbnRyb2lkcyBmb3IgY29udmVyZ2VuY2UgdGVzdC5cbiAgICAgIG9sZENlbnRyb2lkcyA9IFtdLmNvbmNhdChjZW50cm9pZHMpO1xuICAgICAgaXRlcmF0aW9ucysrO1xuXG4gICAgICAvLyBBc3NpZ24gbGFiZWxzIHRvIGVhY2ggZGF0YXBvaW50IGJhc2VkIG9uIGNlbnRyb2lkc1xuICAgICAgbGFiZWxzID0gZ2V0TGFiZWxzKGRhdGFzZXQsIGNlbnRyb2lkcyk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhvbGRDZW50cm9pZHMpXG4gICAgICBjZW50cm9pZHMgPSByZWNhbGN1bGF0ZUNlbnRyb2lkcyhkYXRhc2V0LCBsYWJlbHMsIGspO1xuICAgICAgLy8gY29uc29sZS5sb2coY2VudHJvaWRzKVxuICAgIH1cblxuICAgIGNvbnN0IGNsdXN0ZXJzID0gW107XG4gICAgbGV0IGRhdGFzZXRMYWJlbHMgPSBuZXcgQXJyYXkoZGF0YXNldC5sZW5ndGgpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgIGNsdXN0ZXJzLnB1c2gobGFiZWxzW2ldLmluZGV4ZXMpO1xuICAgICAgbGFiZWxzW2ldLmluZGV4ZXMuZm9yRWFjaChkYXRhc2V0SW5kZXggPT4ge1xuICAgICAgICBkYXRhc2V0TGFiZWxzW2RhdGFzZXRJbmRleF0gPSBpXG4gICAgICB9KVxuICAgIH1cbiAgICBcbiAgICBjb25zdCByZXN1bHRzID0ge1xuICAgICAgZGF0YXNldExhYmVscyxcbiAgICAgIGNsdXN0ZXJWZWN0b3I6IGRhdGFzZXRMYWJlbHMsXG4gICAgICBjbHVzdGVyczogY2x1c3RlcnMsXG4gICAgICBjbHVzdGVySW5kZXg6IGNsdXN0ZXJzLFxuICAgICAgY2VudHJvaWRzOiBjZW50cm9pZHMsXG4gICAgICBpdGVyYXRpb25zOiBpdGVyYXRpb25zLFxuICAgICAgY29udmVyZ2VkOiBpdGVyYXRpb25zIDw9IE1BWF9JVEVSQVRJT05TLFxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGFzZXQnKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBrbWVhbnM7IiwiaW1wb3J0IGttZWFucyBmcm9tICcuL2ttZWFucy5qcydcclxuXHJcbmxldCBHcm91cGluZ1Rvb2wgPSB7XHJcbiAgcHJvcHM6IFsnY29uZmlnJywgJ2xvY2FsQ29uZmlnJywgJ3V0aWxzJ10sXHJcbiAgZGF0YSAoKSB7ICAgIFxyXG4gICAgdGhpcy4kaTE4bi5sb2NhbGUgPSB0aGlzLmxvY2FsQ29uZmlnLmxvY2FsZVxyXG4gICAgcmV0dXJuIHtcclxuICAgIH1cclxuICB9LFxyXG4gIHdhdGNoOiB7XHJcbiAgICAnbG9jYWxDb25maWcubG9jYWxlJygpIHtcclxuICAgICAgdGhpcy4kaTE4bi5sb2NhbGUgPSB0aGlzLmxvY2FsQ29uZmlnLmxvY2FsZTtcclxuICAgIH0sXHJcbiAgfSxcclxuICAvLyBjb21wdXRlZDoge1xyXG4gICAgXHJcbiAgLy8gfSxcclxuICAvLyBtb3VudGVkOiBhc3luYyBmdW5jdGlvbiAoKSB7XHJcbiAgLy8gICB0aGlzLnRlc3QyMDIyMTAzMDE3MjkoKVxyXG4gIC8vIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgdGVzdDIwMjIxMDMwMDAzMzogYXN5bmMgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgLy8gdmFyIHZlY3RvciA9IFtcclxuICAgICAgLy8gICBbMSwgMTAsIDIsIDMwXSxcclxuICAgICAgLy8gICBbJ0EnLCAzMCwgMjAsIDJdLFxyXG4gICAgICAvLyAgIFsnQicsIDMwLCAzMCwgM10sXHJcbiAgICAgIC8vICAgWydDJywgMzAsIDMxLCAzXSxcclxuICAgICAgLy8gICBbJ0EnLCAxMCwgMTAsIDFdLFxyXG4gICAgICAvLyAgIFsnQicsIDIwLCAxLCAzMF0sXHJcbiAgICAgIC8vICAgWydDJywgMSwgMjUsIDMwXVxyXG4gICAgICAvLyBdXHJcblxyXG4gICAgICB2YXIgdmVjdG9yID0gW1xyXG4gICAgICAgIFsxMCwgMiwgMzBdLFxyXG4gICAgICAgIFszMCwgMjAsIDJdLFxyXG4gICAgICAgIFszMCwgMzAsIDNdLFxyXG4gICAgICAgIFszMCwgMzEsIDNdLFxyXG4gICAgICAgIFsxMCwgMTAsIDFdLFxyXG4gICAgICAgIFsyMCwgMSwgMzBdLFxyXG4gICAgICAgIFsxLCAyNSwgMzBdXHJcbiAgICAgIF1cclxuXHJcblxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLnRvVmVjdG9yKHZlY3RvcikpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMuYWRkS21lYW5zKHZlY3RvcikpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMuYWRkR3JvdXBJbkRpZmZlcmVuY2UodmVjdG9yKSlcclxuICAgICAgLy8gY29uc29sZS5sb2coYXdhaXQgdGhpcy5hZGRHcm91cEluU2ltaWxhcml0eSh2ZWN0b3IpKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyh2ZWN0b3IpXHJcbiAgICAgIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMua21lYW5zKHZlY3RvciwgMykpXHJcbiAgICB9LFxyXG4gICAgdGVzdDIwMjIxMDMwMTcyOTogYXN5bmMgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgdmFyIHZlY3RvciA9IFtcclxuICAgICAgICBbMSwgMiwgMywgMV0sXHJcbiAgICAgICAgWzUsMiwzLDFdLFxyXG4gICAgICAgIFsxLDIsNCwwXSxcclxuICAgICAgICBbNSwzLDQsMF1cclxuICAgICAgXVxyXG5cclxuXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMudG9WZWN0b3IodmVjdG9yKSlcclxuICAgICAgLy8gY29uc29sZS5sb2coYXdhaXQgdGhpcy5hZGRLbWVhbnModmVjdG9yKSlcclxuICAgICAgLy8gY29uc29sZS5sb2codmVjdG9yKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLmttZWFucyh2ZWN0b3IsIDIpKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLmdyb3VwaW5nQnlTaW1pbGFyaXR5KHZlY3RvciwgJ21lbWJlcicsIDIpKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLmdyb3VwaW5nQnlEaWZmZXJlbmNlKHZlY3RvciwgJ21lbWJlcicsIDIpKVxyXG4gICAgfSxcclxuICAgIHRvVmVjdG9yOiBhc3luYyBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEpXHJcblxyXG5cclxuICAgICAgbGV0IHJvd3MgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpXHJcbiAgICAgIGxldCBjb2x1bWVMZW5ndGggPSBkYXRhWzBdLmxlbmd0aFxyXG5cclxuICAgICAgZm9yIChsZXQgYyA9IHRoaXMubG9jYWxDb25maWcuR3JvdXBpbmdUb29sLnNraXBDb2x1bW5zOyBjIDwgY29sdW1lTGVuZ3RoOyBjKyspIHtcclxuICAgICAgICBsZXQgbGlzdCA9IFtdXHJcbiAgICAgICAgbGV0IGlzQ29sdW1uTnVtYmVyID0gdHJ1ZVxyXG5cclxuICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcclxuICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFbZF1bY11cclxuICAgICAgICAgIGxldCBpc051bWJlciA9ICh0eXBlb2YodmFsdWUpID09PSAnbnVtYmVyJylcclxuICAgICAgICAgIGlmIChpc051bWJlciA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaXNDb2x1bW5OdW1iZXIgPSBmYWxzZVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaCh2YWx1ZSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGlzQ29sdW1uTnVtYmVyKVxyXG5cclxuICAgICAgICBpZiAoaXNDb2x1bW5OdW1iZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgIGxldCBtYXggPSBNYXRoLm1heCguLi5saXN0KVxyXG4gICAgICAgICAgbGV0IG1pbiA9IE1hdGgubWluKC4uLmxpc3QpXHJcbiAgICAgICAgICBsZXQgcmFuZ2UgPSBtYXggLSBtaW5cclxuICAgICAgICAgIGlmIChyYW5nZSA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGxldCBub3JtYWxpemVkXHJcbiAgICAgICAgICBpZiAobWF4ID09PSAxICYmIG1pbiA9PT0gMCkge1xyXG4gICAgICAgICAgICBub3JtYWxpemVkID0gbGlzdFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBsaXN0Lm1hcCh2YWx1ZSA9PiAoKHZhbHVlIC0gbWluKSAvIHJhbmdlKSlcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKGxldCByID0gMDsgciA8IHJvd3MubGVuZ3RoOyByKyspIHtcclxuICAgICAgICAgICAgaWYgKCFyb3dzW3JdKSB7XHJcbiAgICAgICAgICAgICAgcm93c1tyXSA9IFtdXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJvd3Nbcl0ucHVzaChub3JtYWxpemVkW3JdKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGxldCBtYXAgPSB7fVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBsZXQgaWQgPSAwXHJcbiAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZGF0YVtkXVtjXVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgJydcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codmFsdWUpXHJcbiAgICAgICAgICAgIGlmICghbWFwW3ZhbHVlXSkge1xyXG4gICAgICAgICAgICAgIG1hcFt2YWx1ZV0gPSBpZFxyXG4gICAgICAgICAgICAgIGlkKytcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaXN0LnB1c2godmFsdWUpXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2cobWFwLCBsaXN0KVxyXG5cclxuICAgICAgICAgIGxldCB2ZWN0b3JzID0gW11cclxuICAgICAgICAgIGxldCB2ID0gW11cclxuICAgICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMobWFwKVxyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZbaV0gPSAwXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyh2KVxyXG5cclxuICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGF0YS5sZW5ndGg7IGQrKykge1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBkYXRhW2RdW2NdXHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAnJ1xyXG4gICAgICAgICAgICBsZXQgaSA9IGtleXMuaW5kZXhPZih2YWx1ZSlcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coaSlcclxuICAgICAgICAgICAgbGV0IHYyID0gW10uY29uY2F0KHYpXHJcbiAgICAgICAgICAgIHYyW2ldID0gMVxyXG4gICAgICAgICAgICB2ZWN0b3JzLnB1c2godjIpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyh2ZWN0b3JzKVxyXG5cclxuICAgICAgICAgIHZlY3RvcnMuZm9yRWFjaCgodmVjdG9yLCByKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghcm93c1tyXSkge1xyXG4gICAgICAgICAgICAgIHJvd3Nbcl0gPSBbXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvd3Nbcl0gPSByb3dzW3JdLmNvbmNhdCh2ZWN0b3IpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY29uc29sZS5sb2cocm93cylcclxuXHJcbiAgICAgIHJldHVybiByb3dzXHJcbiAgICB9LFxyXG4gICAgLy8ga21lYW5zOiBhc3luYyBmdW5jdGlvbiAoZGF0YSwgY2x1c3RlciA9IDMpIHtcclxuICAgIC8vICAgbGV0IHZlY3RvciA9IGF3YWl0IHRoaXMudG9WZWN0b3IoZGF0YSlcclxuICAgIC8vICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgIC8vICAgICAvLyBjb25zb2xlLmxvZyhjbHVzdGVyKVxyXG4gICAgLy8gICAgIGttZWFucyh2ZWN0b3IsIGNsdXN0ZXIsIGZ1bmN0aW9uKGVyciwgY2x1c3RlclZlY3RvciwgY2x1c3RlckluZGV4LCBjbHVzdGVyLCBjZW50cm9pZHMpIHtcclxuICAgIC8vICAgICAgIGlmIChlcnIpIHtcclxuICAgIC8vICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKGVycilcclxuICAgIC8vICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpXHJcbiAgICAvLyAgICAgICB9XHJcbiAgICAgIFxyXG4gICAgLy8gICAgICAgLy9kbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XHJcbiAgICAvLyAgICAgICAvLyBjb25zb2xlLmxvZyhyZXMpXHJcbiAgICAvLyAgICAgICByZXNvbHZlKHtcclxuICAgIC8vICAgICAgICAgY2x1c3RlclZlY3RvcixcclxuICAgIC8vICAgICAgICAgY2x1c3RlckluZGV4LFxyXG4gICAgLy8gICAgICAgICBjbHVzdGVyLFxyXG4gICAgLy8gICAgICAgICBjZW50cm9pZHNcclxuICAgIC8vICAgICAgIH0pXHJcbiAgICAvLyAgICAgfSlcclxuICAgIC8vICAgfSlcclxuICAgIC8vICAgLy8gY29uc29sZS5sb2codmVjdG9yKSBcclxuICAgIC8vIH0sXHJcbiAgICBrbWVhbnM6IGFzeW5jIGZ1bmN0aW9uIChkYXRhLCBjbHVzdGVyID0gMykge1xyXG4gICAgICBsZXQgdmVjdG9yID0gYXdhaXQgdGhpcy50b1ZlY3RvcihkYXRhKVxyXG4gICAgICAvLyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGNsdXN0ZXIpXHJcbiAgICAgICAgLy8gcmVzb3ZsZShrbWVhbnModmVjdG9yLCBjbHVzdGVyKSlcclxuICAgICAgLy8gfSlcclxuICAgICAgLy8gY29uc29sZS5sb2codmVjdG9yKSBcclxuICAgICAgbGV0IHJlc3VsdCA9IGttZWFucyh2ZWN0b3IsIGNsdXN0ZXIpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHJlc3VsdClcclxuICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgfSxcclxuICAgIGFkZEttZWFuczogYXN5bmMgZnVuY3Rpb24gKHZlY3RvciwgY2x1c3RlciA9IDMpIHtcclxuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMua21lYW5zKHZlY3RvciwgY2x1c3RlcilcclxuXHJcbiAgICAgIHJldHVybiB2ZWN0b3IubWFwKChpdGVtLCBpKSA9PiB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coaXRlbSwgaSwgcmVzdWx0LmNsdXN0ZXJJbmRleClcclxuICAgICAgICBpdGVtLnB1c2gocmVzdWx0LmNsdXN0ZXJWZWN0b3JbaV0pXHJcbiAgICAgICAgcmV0dXJuIGl0ZW1cclxuICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBncm91cGluZ0J5RGlmZmVyZW5jZTogYXN5bmMgZnVuY3Rpb24gKHZlY3RvciwgZ3JvdXBUeXBlID0gJ21lbWJlcicsIG1lbWJlciA9IDMpIHtcclxuICAgICAgbWVtYmVyID0gTnVtYmVyKG1lbWJlcilcclxuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMua21lYW5zKHZlY3RvciwgbWVtYmVyKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhyZXN1bHQpXHJcblxyXG4gICAgICBsZXQgZ3JvdXBzID0gTWF0aC5jZWlsKHZlY3Rvci5sZW5ndGggLyBtZW1iZXIpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZ3JvdXBUeXBlID09PSAnZ3JvdXAnKSB7XHJcbiAgICAgICAgZ3JvdXBzID0gbWVtYmVyXHJcbiAgICAgICAgbWVtYmVyID0gTnVtYmVyKE1hdGguZmxvb3IodmVjdG9yLmxlbmd0aCAvIGdyb3VwcykpXHJcbiAgICAgIH1cclxuICAgICAgLy8gY29uc29sZS5sb2coZ3JvdXBzLCBtZW1iZXIpXHJcbiAgICAgIFxyXG4gICAgICBsZXQgZ3JvdXBJbmRleExpc3QgPSBbXVxyXG4gICAgICBsZXQgbW9kID0gdmVjdG9yLmxlbmd0aCAlIGdyb3Vwc1xyXG4gICAgICBsZXQgbWluTWVtYmVycyA9IE1hdGguZmxvb3IodmVjdG9yLmxlbmd0aCAvIGdyb3VwcylcclxuXHJcbiAgICAgIGxldCBjb3VudGVyID0gMFxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhncm91cHMpXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBzOyBpKyspIHtcclxuICAgICAgICBsZXQgZ3JvdXAgPSBbXVxyXG5cclxuICAgICAgICBsZXQgY2x1c3RlckkgPSAwXHJcbiAgICAgICAgbGV0IGJhc2VNZW1iZXIgPSBtaW5NZW1iZXJzXHJcbiAgICAgICAgaWYgKGkgPCBtb2QpIHtcclxuICAgICAgICAgIGJhc2VNZW1iZXIrK1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coYmFzZU1lbWJlcilcclxuICAgICAgICAvLyBjb250aW51ZVxyXG5cclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgbGV0IHYgPSByZXN1bHQuY2x1c3RlckluZGV4WyhjbHVzdGVySSAlIGdyb3VwcyldXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHYsIGNvdW50ZXIsIHZlY3Rvci5sZW5ndGgpIFxyXG4gICAgICAgICAgaWYgKHYubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNsdXN0ZXJJKytcclxuICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBsZXQgcmFuZG9tSWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB2Lmxlbmd0aClcclxuICAgICAgICAgIGxldCBpdGVtID0gdltyYW5kb21JZF1cclxuICAgICAgICAgIGdyb3VwLnB1c2goTnVtYmVyKGl0ZW0pKVxyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coaXRlbSlcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgdi5zcGxpY2UocmFuZG9tSWQsIDEpXHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyh2ZWN0b3IpXHJcbiAgICAgICAgICAvLyBjbHVzdGVyVmVjdG9yWyhjbHVzdGVySSAlIG1lbWJlcildID0gdlxyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2cocmVzdWx0LmNsdXN0ZXJWZWN0b3IpXHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyh2KVxyXG5cclxuICAgICAgICAgIGNsdXN0ZXJJKytcclxuICAgICAgICAgIGNvdW50ZXIrK1xyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coY291bnRlciwgZ3JvdXAubGVuZ3RoLCBtZW1iZXIpXHJcbiAgICAgICAgICBpZiAoY291bnRlciA9PT0gdmVjdG9yLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChncm91cC5sZW5ndGggPT09IGJhc2VNZW1iZXIpIHtcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coZ3JvdXApXHJcbiAgICAgICAgZ3JvdXBJbmRleExpc3QucHVzaChncm91cClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY29uc29sZS5sb2coZ3JvdXBJbmRleExpc3QpXHJcblxyXG4gICAgICAvLyBsZXQgaW52ZXJ0R3JvdXAgPSBuZXcgQXJyYXkoZ3JvdXBzKVxyXG4gICAgICBsZXQgb3V0cHV0ID0gW10uY29uY2F0KHZlY3RvcilcclxuICAgICAgZ3JvdXBJbmRleExpc3QuZm9yRWFjaCgobGlzdCwgZ3JvdXBJZCkgPT4ge1xyXG4gICAgICAgIGxpc3QuZm9yRWFjaChpbmRleCA9PiB7XHJcbiAgICAgICAgICBsZXQgbyA9IFtdLmNvbmNhdChvdXRwdXRbaW5kZXhdKVxyXG4gICAgICAgICAgby5wdXNoKGdyb3VwSWQpXHJcbiAgICAgICAgICBvdXRwdXRbaW5kZXhdID0gb1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICByZXR1cm4gb3V0cHV0XHJcbiAgICB9LFxyXG4gICAgZ3JvdXBpbmdCeVNpbWlsYXJpdHk6IGFzeW5jIGZ1bmN0aW9uICh2ZWN0b3IsIGdyb3VwVHlwZSA9ICdtZW1iZXInLCBtZW1iZXIgPSAzKSB7XHJcbiAgICAgIG1lbWJlciA9IE51bWJlcihtZW1iZXIpXHJcbiAgICAgIGxldCBncm91cHMgPSBNYXRoLmNlaWwodmVjdG9yLmxlbmd0aCAvIG1lbWJlcilcclxuXHJcbiAgICAgIGlmIChncm91cFR5cGUgPT09ICdncm91cCcpIHtcclxuICAgICAgICBncm91cHMgPSBtZW1iZXJcclxuICAgICAgICBtZW1iZXIgPSBNYXRoLmNlaWwodmVjdG9yLmxlbmd0aCAvIGdyb3VwcylcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY29uc29sZS5sb2coZ3JvdXBzLCBtZW1iZXIpXHJcblxyXG4gICAgICBsZXQge2NsdXN0ZXJJbmRleH0gPSBhd2FpdCB0aGlzLmttZWFucyh2ZWN0b3IsIGdyb3VwcylcclxuICAgICAgLy8gY29uc29sZS5sb2coY2x1c3RlckluZGV4KSBcclxuICAgICAgdGhpcy5zb3J0Q2x1c3RlckluZGV4QnlTaXplKGNsdXN0ZXJJbmRleClcclxuICAgICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBsZXQgaXNGaW5pc2ggPSB0cnVlXHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbHVzdGVySW5kZXgubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGxldCBsaXN0ID0gY2x1c3RlckluZGV4W2ldXHJcbiAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPD0gbWVtYmVyICYmIGxpc3QubGVuZ3RoID49IG1lbWJlciAtIDEpIHtcclxuICAgICAgICAgICAgY29udGludWVcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpc0ZpbmlzaCA9IGZhbHNlXHJcblxyXG4gICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID4gbWVtYmVyKSB7XHJcbiAgICAgICAgICAgIGxldCByYW5kb21JZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxpc3QubGVuZ3RoKVxyXG4gICAgICAgICAgICBjbHVzdGVySW5kZXhbKGNsdXN0ZXJJbmRleC5sZW5ndGggLSAxKV0ucHVzaChsaXN0W3JhbmRvbUlkXSlcclxuICAgICAgICAgICAgbGlzdC5zcGxpY2UocmFuZG9tSWQsIDEpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHJhbmRvbUlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2x1c3RlckluZGV4WzBdLmxlbmd0aClcclxuICAgICAgICAgICAgY2x1c3RlckluZGV4W2ldLnB1c2goY2x1c3RlckluZGV4WzBdW3JhbmRvbUlkXSlcclxuICAgICAgICAgICAgY2x1c3RlckluZGV4WzBdLnNwbGljZShyYW5kb21JZCwgMSlcclxuICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgdGhpcy5zb3J0Q2x1c3RlckluZGV4QnlTaXplKGNsdXN0ZXJJbmRleClcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgaWYgKGlzRmluaXNoKSB7XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgfVxyXG5cclxuICAgICAgT2JqZWN0LmtleXMoY2x1c3RlckluZGV4KS5mb3JFYWNoKGdyb3VwSWQgPT4ge1xyXG4gICAgICAgIGNsdXN0ZXJJbmRleFtncm91cElkXS5mb3JFYWNoKGkgPT4ge1xyXG4gICAgICAgICAgdmVjdG9yW2ldLnB1c2goTnVtYmVyKGdyb3VwSWQpKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICByZXR1cm4gdmVjdG9yXHJcbiAgICB9LFxyXG4gICAgc29ydENsdXN0ZXJJbmRleEJ5U2l6ZSAoY2x1c3RlckluZGV4KSB7XHJcbiAgICAgIGNsdXN0ZXJJbmRleC5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGhcclxuICAgICAgfSlcclxuICAgIH0sXHJcbiAgICByZW1vdmVMYXN0Q29sdW1uICgpIHtcclxuICAgICAgbGV0IGRhdGEgPSB0aGlzLiRwYXJlbnQuZGF0YU1hdHJpeFxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhkYXRhKVxyXG4gICAgICBkYXRhID0gZGF0YS5tYXAocm93ID0+IHJvdy5zbGljZSgwLCByb3cubGVuZ3RoIC0gMSkpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEpXHJcbiAgICAgIHRoaXMubG9jYWxDb25maWcudGV4dENvbnRlbnQgPSBkYXRhLm1hcChsaW5lID0+IGxpbmUuam9pbignXFx0JykpLmpvaW4oJ1xcbicpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHcm91cGluZ1Rvb2wiLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTYhLi9Hcm91cGluZ1Rvb2wuanM/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tNiEuL0dyb3VwaW5nVG9vbC5qcz92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vR3JvdXBpbmdUb29sLmh0bWw/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWQwNjZiYzAmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vR3JvdXBpbmdUb29sLmpzP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9Hcm91cGluZ1Rvb2wuanM/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vR3JvdXBpbmdUb29sLmxlc3M/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xZDA2NmJjMCZsYW5nPWxlc3Mmc2NvcGVkPXRydWUmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjFkMDY2YmMwXCIsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGN1c3RvbSBibG9ja3MgKi9cbmltcG9ydCBibG9jazAgZnJvbSBcIi4vR3JvdXBpbmdUb29sLnlhbWw/dnVlJnR5cGU9Y3VzdG9tJmluZGV4PTAmYmxvY2tUeXBlPWkxOG4maXNzdWVyUGF0aD0lMkZhcHAlMkZzcmMlMkZjb21wb25lbnRzJTJGUmVwbGFjZVBhbmVsJTJGR3JvdXBpbmdUb29sJTJGR3JvdXBpbmdUb29sLnZ1ZSZsYW5nPXlhbWxcIlxuaWYgKHR5cGVvZiBibG9jazAgPT09ICdmdW5jdGlvbicpIGJsb2NrMChjb21wb25lbnQpXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiL2FwcC9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCcxZDA2NmJjMCcpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCcxZDA2NmJjMCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCcxZDA2NmJjMCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vR3JvdXBpbmdUb29sLmh0bWw/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MWQwNjZiYzAmc2NvcGVkPXRydWUmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignMWQwNjZiYzAnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInNyYy9jb21wb25lbnRzL1JlcGxhY2VQYW5lbC9Hcm91cGluZ1Rvb2wvR3JvdXBpbmdUb29sLnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbEhBO0FBRUE7QUFDQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFKQTtBQUFBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQ2xPQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBUkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQWNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBbkZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF5RkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUEsNkJBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBQ0E7QUFBQTtBQTVDQTtBQUFBO0FBQUE7QUFBQTtBQStDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBLDZCQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBcEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF5QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQ3ZXQTs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFpQkE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///424\n')}}]);