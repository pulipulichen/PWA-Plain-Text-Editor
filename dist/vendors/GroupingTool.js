(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{114:function(module,exports,__webpack_require__){eval("var content = __webpack_require__(386);\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(7)(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz85MGFmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0zIS4vR3JvdXBpbmdUb29sLmxlc3M/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0xZDA2NmJjMCZsYW5nPWxlc3Mmc2NvcGVkPXRydWUmXCIpO1xuXG5pZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbn1cblxudmFyIG9wdGlvbnMgPSB7fVxuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZiAoY29udGVudC5sb2NhbHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///114\n")},115:function(module,exports){eval('module.exports = function (Component) {\n  Component.options.__i18n = Component.options.__i18n || []\n  Component.options.__i18n.push(\'{"en-US":{"Search":"Search"},"zh-TW":{"Search":"搜尋"}}\')\n  delete Component.options._Ctor\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wueWFtbD8xOGVhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICBDb21wb25lbnQub3B0aW9ucy5fX2kxOG4gPSBDb21wb25lbnQub3B0aW9ucy5fX2kxOG4gfHwgW11cbiAgQ29tcG9uZW50Lm9wdGlvbnMuX19pMThuLnB1c2goJ3tcImVuLVVTXCI6e1wiU2VhcmNoXCI6XCJTZWFyY2hcIn0sXCJ6aC1UV1wiOntcIlNlYXJjaFwiOlwi5pCc5bCLXCJ9fScpXG4gIGRlbGV0ZSBDb21wb25lbnQub3B0aW9ucy5fQ3RvclxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///115\n')},385:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var _node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(114);\n/* harmony import */ var _node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_style_loader_dist_index_js_node_modules_css_loader_dist_cjs_js_ref_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_1_2_node_modules_less_loader_dist_cjs_js_ref_1_3_GroupingTool_less_vue_type_style_index_0_id_1d066bc0_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz82YzliIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMyEuL0dyb3VwaW5nVG9vbC5sZXNzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MWQwNjZiYzAmbGFuZz1sZXNzJnNjb3BlZD10cnVlJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xLTMhLi9Hcm91cGluZ1Rvb2wubGVzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFkMDY2YmMwJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///385\n")},386:function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(6)(true);\n// Module\nexports.push([module.i, "input[data-v-1d066bc0]{width:5rem!important}select[data-v-1d066bc0]{width:auto!important}label[data-v-1d066bc0]{margin-right:1rem!important;width:4rem!important;text-align:right!important}", "",{"version":3,"sources":["/app/src/components/ReplacePanel/GroupingTool/GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&","/app/src/components/ReplacePanel/GroupingTool/GroupingTool.less"],"names":[],"mappings":"AAAA,uBACE,oBCCF,CDMA,wBACE,oBCJF,CDQA,uBACE,2BAAA,CACA,oBAAA,CACA,0BCNF","file":"GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&","sourcesContent":["input {\\n  width: 5rem !important;\\n}\\n\\n// .GroupingTool {\\n//   margin-top: 0.2rem !important;\\n// }\\n\\nselect {\\n  width: auto !important;\\n}\\n\\n\\nlabel {\\n  margin-right: 1rem !important;\\n  width: 4rem !important;\\n  text-align: right !important;\\n}","input {\\n  width: 5rem !important;\\n}\\nselect {\\n  width: auto !important;\\n}\\nlabel {\\n  margin-right: 1rem !important;\\n  width: 4rem !important;\\n  text-align: right !important;\\n}\\n"]}]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz81MWRiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKHRydWUpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJpbnB1dFtkYXRhLXYtMWQwNjZiYzBde3dpZHRoOjVyZW0haW1wb3J0YW50fXNlbGVjdFtkYXRhLXYtMWQwNjZiYzBde3dpZHRoOmF1dG8haW1wb3J0YW50fWxhYmVsW2RhdGEtdi0xZDA2NmJjMF17bWFyZ2luLXJpZ2h0OjFyZW0haW1wb3J0YW50O3dpZHRoOjRyZW0haW1wb3J0YW50O3RleHQtYWxpZ246cmlnaHQhaW1wb3J0YW50fVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHAvc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFkMDY2YmMwJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIixcIi9hcHAvc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wubGVzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSx1QkFDRSxvQkNDRixDRE1BLHdCQUNFLG9CQ0pGLENEUUEsdUJBQ0UsMkJBQUEsQ0FDQSxvQkFBQSxDQUNBLDBCQ05GXCIsXCJmaWxlXCI6XCJHcm91cGluZ1Rvb2wubGVzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTFkMDY2YmMwJmxhbmc9bGVzcyZzY29wZWQ9dHJ1ZSZcIixcInNvdXJjZXNDb250ZW50XCI6W1wiaW5wdXQge1xcbiAgd2lkdGg6IDVyZW0gIWltcG9ydGFudDtcXG59XFxuXFxuLy8gLkdyb3VwaW5nVG9vbCB7XFxuLy8gICBtYXJnaW4tdG9wOiAwLjJyZW0gIWltcG9ydGFudDtcXG4vLyB9XFxuXFxuc2VsZWN0IHtcXG4gIHdpZHRoOiBhdXRvICFpbXBvcnRhbnQ7XFxufVxcblxcblxcbmxhYmVsIHtcXG4gIG1hcmdpbi1yaWdodDogMXJlbSAhaW1wb3J0YW50O1xcbiAgd2lkdGg6IDRyZW0gIWltcG9ydGFudDtcXG4gIHRleHQtYWxpZ246IHJpZ2h0ICFpbXBvcnRhbnQ7XFxufVwiLFwiaW5wdXQge1xcbiAgd2lkdGg6IDVyZW0gIWltcG9ydGFudDtcXG59XFxuc2VsZWN0IHtcXG4gIHdpZHRoOiBhdXRvICFpbXBvcnRhbnQ7XFxufVxcbmxhYmVsIHtcXG4gIG1hcmdpbi1yaWdodDogMXJlbSAhaW1wb3J0YW50O1xcbiAgd2lkdGg6IDRyZW0gIWltcG9ydGFudDtcXG4gIHRleHQtYWxpZ246IHJpZ2h0ICFpbXBvcnRhbnQ7XFxufVxcblwiXX1dKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///386\n')},387:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(115);\n/* harmony import */ var _node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0__);\n /* harmony default export */ __webpack_exports__["default"] = (_node_modules_kazupon_vue_i18n_loader_lib_index_js_GroupingTool_yaml_vue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml__WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wueWFtbD8zYWFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BrYXp1cG9uL3Z1ZS1pMThuLWxvYWRlci9saWIvaW5kZXguanMhLi9Hcm91cGluZ1Rvb2wueWFtbD92dWUmdHlwZT1jdXN0b20maW5kZXg9MCZibG9ja1R5cGU9aTE4biZpc3N1ZXJQYXRoPSUyRmFwcCUyRnNyYyUyRmNvbXBvbmVudHMlMkZSZXBsYWNlUGFuZWwlMkZHcm91cGluZ1Rvb2wlMkZHcm91cGluZ1Rvb2wudnVlJmxhbmc9eWFtbFwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9Aa2F6dXBvbi92dWUtaTE4bi1sb2FkZXIvbGliL2luZGV4LmpzIS4vR3JvdXBpbmdUb29sLnlhbWw/dnVlJnR5cGU9Y3VzdG9tJmluZGV4PTAmYmxvY2tUeXBlPWkxOG4maXNzdWVyUGF0aD0lMkZhcHAlMkZzcmMlMkZjb21wb25lbnRzJTJGUmVwbGFjZVBhbmVsJTJGR3JvdXBpbmdUb29sJTJGR3JvdXBpbmdUb29sLnZ1ZSZsYW5nPXlhbWxcIiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///387\n')},424:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./src/components/ReplacePanel/GroupingTool/GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c("div", { staticClass: "GroupingTool" }, [\n    _c("div", { staticClass: "fields" }, [\n      _c("label", { attrs: { for: "GroupingToolSkipColumns" } }, [\n        _vm._v("\\n      " + _vm._s(_vm.$t("Skip Cols")) + "\\n    ")\n      ]),\n      _vm._v(" "),\n      _c("input", {\n        directives: [\n          {\n            name: "model",\n            rawName: "v-model",\n            value: _vm.localConfig.GroupingTool.skipColumns,\n            expression: "localConfig.GroupingTool.skipColumns"\n          }\n        ],\n        attrs: { type: "number", id: "GroupingToolSkipColumns" },\n        domProps: { value: _vm.localConfig.GroupingTool.skipColumns },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig.GroupingTool,\n              "skipColumns",\n              $event.target.value\n            )\n          }\n        }\n      }),\n      _vm._v(" "),\n      _c(\n        "select",\n        {\n          directives: [\n            {\n              name: "model",\n              rawName: "v-model",\n              value: _vm.localConfig.GroupingTool.groupType,\n              expression: "localConfig.GroupingTool.groupType"\n            }\n          ],\n          on: {\n            change: function($event) {\n              var $$selectedVal = Array.prototype.filter\n                .call($event.target.options, function(o) {\n                  return o.selected\n                })\n                .map(function(o) {\n                  var val = "_value" in o ? o._value : o.value\n                  return val\n                })\n              _vm.$set(\n                _vm.localConfig.GroupingTool,\n                "groupType",\n                $event.target.multiple ? $$selectedVal : $$selectedVal[0]\n              )\n            }\n          }\n        },\n        [\n          _c("option", { attrs: { value: "group" } }, [\n            _vm._v(_vm._s(_vm.$t("Group: ")))\n          ]),\n          _vm._v(" "),\n          _c("option", { attrs: { value: "member" } }, [\n            _vm._v(_vm._s(_vm.$t("Member: ")))\n          ])\n        ]\n      ),\n      _vm._v(" "),\n      _c("input", {\n        directives: [\n          {\n            name: "model",\n            rawName: "v-model",\n            value: _vm.localConfig.GroupingTool.groupLength,\n            expression: "localConfig.GroupingTool.groupLength"\n          }\n        ],\n        attrs: { type: "number" },\n        domProps: { value: _vm.localConfig.GroupingTool.groupLength },\n        on: {\n          input: function($event) {\n            if ($event.target.composing) {\n              return\n            }\n            _vm.$set(\n              _vm.localConfig.GroupingTool,\n              "groupLength",\n              $event.target.value\n            )\n          }\n        }\n      })\n    ])\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.html?vue&type=template&id=1d066bc0&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/typeof.js\nvar helpers_typeof = __webpack_require__(1);\nvar typeof_default = /*#__PURE__*/__webpack_require__.n(helpers_typeof);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__(2);\nvar asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator);\n\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/kmeans.js\n\nvar MAX_ITERATIONS = 50;\nfunction randomBetween(min, max) {\n  return Math.floor(Math.random() * (max - min) + min);\n}\nfunction calcMeanCentroid(dataSet, start, end) {\n  var features = dataSet[0].length;\n  var n = end - start;\n  var mean = [];\n  for (var i = 0; i < features; i++) {\n    mean.push(0);\n  }\n  for (var _i = start; _i < end; _i++) {\n    for (var j = 0; j < features; j++) {\n      mean[j] = mean[j] + dataSet[_i][j] / n;\n    }\n  }\n  return mean;\n}\nfunction getRandomCentroidsNaiveSharding(dataset, k) {\n  // implementation of a variation of naive sharding centroid initialization method\n  // (not using sums or sorting, just dividing into k shards and calc mean)\n  // https://www.kdnuggets.com/2017/03/naive-sharding-centroid-initialization-method.html\n  var numSamples = dataset.length;\n  // Divide dataset into k shards:\n  var step = Math.floor(numSamples / k);\n  var centroids = [];\n  for (var i = 0; i < k; i++) {\n    var start = step * i;\n    var end = step * (i + 1);\n    if (i + 1 === k) {\n      end = numSamples;\n    }\n    centroids.push(calcMeanCentroid(dataset, start, end));\n  }\n  return centroids;\n}\nfunction getRandomCentroids(dataset, k) {\n  // selects random points as centroids from the dataset\n  var numSamples = dataset.length;\n  var centroidsIndex = [];\n  var index;\n  while (centroidsIndex.length < k) {\n    index = randomBetween(0, numSamples);\n    if (centroidsIndex.indexOf(index) === -1) {\n      centroidsIndex.push(index);\n    }\n  }\n  var centroids = [];\n  for (var i = 0; i < centroidsIndex.length; i++) {\n    var centroid = [].concat(dataset[centroidsIndex[i]]);\n    centroids.push(centroid);\n  }\n  return centroids;\n}\nfunction compareCentroids(a, b) {\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction shouldStop(oldCentroids, centroids, iterations) {\n  if (iterations > MAX_ITERATIONS) {\n    return true;\n  }\n  if (!oldCentroids || !oldCentroids.length) {\n    return false;\n  }\n  var sameCount = true;\n  for (var i = 0; i < centroids.length; i++) {\n    if (!compareCentroids(centroids[i], oldCentroids[i])) {\n      sameCount = false;\n    }\n  }\n  return sameCount;\n}\n\n// Calculate Squared Euclidean Distance\nfunction getDistanceSQ(a, b) {\n  var diffs = [];\n  for (var i = 0; i < a.length; i++) {\n    diffs.push(a[i] - b[i]);\n  }\n  return diffs.reduce(function (r, e) {\n    return r + e * e;\n  }, 0);\n}\n\n// Returns a label for each piece of data in the dataset. \nfunction getLabels(dataSet, centroids) {\n  // prep data structure:\n  var labels = {};\n  for (var c = 0; c < centroids.length; c++) {\n    labels[c] = {\n      points: [],\n      centroid: centroids[c],\n      indexes: []\n    };\n  }\n  // For each element in the dataset, choose the closest centroid. \n  // Make that centroid the element\'s label.\n  for (var i = 0; i < dataSet.length; i++) {\n    var a = dataSet[i];\n    var closestCentroid = void 0,\n      closestCentroidIndex = void 0,\n      prevDistance = void 0;\n    for (var j = 0; j < centroids.length; j++) {\n      var centroid = centroids[j];\n      if (j === 0) {\n        closestCentroid = centroid;\n        closestCentroidIndex = j;\n        prevDistance = getDistanceSQ(a, closestCentroid);\n      } else {\n        // get distance:\n        var distance = getDistanceSQ(a, centroid);\n        if (distance < prevDistance) {\n          prevDistance = distance;\n          closestCentroid = centroid;\n          closestCentroidIndex = j;\n        }\n      }\n    }\n    // add point to centroid labels:\n    labels[closestCentroidIndex].points.push(a);\n    labels[closestCentroidIndex].indexes.push(i);\n  }\n  return labels;\n}\nfunction getPointsMean(pointList) {\n  var totalPoints = pointList.length;\n  var means = [];\n  for (var j = 0; j < pointList[0].length; j++) {\n    means.push(0);\n  }\n  for (var i = 0; i < pointList.length; i++) {\n    var point = pointList[i];\n    for (var _j = 0; _j < point.length; _j++) {\n      var val = point[_j];\n      means[_j] = means[_j] + val / totalPoints;\n    }\n  }\n  return means;\n}\nfunction recalculateCentroids(dataSet, labels, k) {\n  // Each centroid is the geometric mean of the points that\n  // have that centroid\'s label. Important: If a centroid is empty (no points have\n  // that centroid\'s label) you should randomly re-initialize it.\n  var newCentroid;\n  var newCentroidList = [];\n  for (var _k in labels) {\n    var centroidGroup = labels[_k];\n    if (centroidGroup.points.length > 0) {\n      // find mean:\n      newCentroid = getPointsMean(centroidGroup.points);\n    } else {\n      // get new random centroid\n      newCentroid = getRandomCentroids(dataSet, 1)[0];\n    }\n    newCentroidList.push(newCentroid);\n  }\n  return newCentroidList;\n}\nfunction kmeans_kmeans(dataset, k) {\n  var useNaiveSharding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  //   console.log(dataset)\n  if (dataset.length && dataset[0].length && dataset.length > k) {\n    var _ret = function () {\n      // Initialize book keeping variables\n      var iterations = 0;\n      var oldCentroids, labels, centroids;\n\n      // Initialize centroids randomly\n      if (useNaiveSharding) {\n        centroids = getRandomCentroidsNaiveSharding(dataset, k);\n      } else {\n        centroids = getRandomCentroids(dataset, k);\n      }\n\n      // Run the main k-means algorithm\n      while (!shouldStop(oldCentroids, centroids, iterations)) {\n        // Save old centroids for convergence test.\n        oldCentroids = [].concat(centroids);\n        iterations++;\n\n        // Assign labels to each datapoint based on centroids\n        labels = getLabels(dataset, centroids);\n        centroids = recalculateCentroids(dataset, labels, k);\n      }\n      var clusters = [];\n      var datasetLabels = new Array(dataset.length);\n      var _loop = function _loop(i) {\n        clusters.push(labels[i].indexes);\n        labels[i].indexes.forEach(function (datasetIndex) {\n          datasetLabels[datasetIndex] = i;\n        });\n      };\n      for (var i = 0; i < k; i++) {\n        _loop(i);\n      }\n      var results = {\n        datasetLabels: datasetLabels,\n        clusterVector: datasetLabels,\n        clusters: clusters,\n        clusterIndex: clusters,\n        centroids: centroids,\n        iterations: iterations,\n        converged: iterations <= MAX_ITERATIONS\n      };\n      return {\n        v: results\n      };\n    }();\n    if (typeof_default()(_ret) === "object") return _ret.v;\n  } else {\n    throw new Error(\'Invalid dataset\');\n  }\n}\n/* harmony default export */ var GroupingTool_kmeans = (kmeans_kmeans);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--6!./src/components/ReplacePanel/GroupingTool/GroupingTool.js?vue&type=script&lang=js&\n\n\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == typeof_default()(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nvar GroupingTool = {\n  props: [\'config\', \'localConfig\', \'utils\'],\n  data: function data() {\n    this.$i18n.locale = this.localConfig.locale;\n    return {};\n  },\n  watch: {\n    \'localConfig.locale\': function localConfigLocale() {\n      this.$i18n.locale = this.localConfig.locale;\n    }\n  },\n  // computed: {\n\n  // },\n  mounted: function () {\n    var _mounted = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              this.test202210301729();\n            case 1:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n    function mounted() {\n      return _mounted.apply(this, arguments);\n    }\n    return mounted;\n  }(),\n  methods: {\n    test202210300033: function () {\n      var _test = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var vector;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // var vector = [\n                //   [1, 10, 2, 30],\n                //   [\'A\', 30, 20, 2],\n                //   [\'B\', 30, 30, 3],\n                //   [\'C\', 30, 31, 3],\n                //   [\'A\', 10, 10, 1],\n                //   [\'B\', 20, 1, 30],\n                //   [\'C\', 1, 25, 30]\n                // ]\n                vector = [[10, 2, 30], [30, 20, 2], [30, 30, 3], [30, 31, 3], [10, 10, 1], [20, 1, 30], [1, 25, 30]]; // console.log(await this.toVector(vector))\n                // console.log(await this.addKmeans(vector))\n                // console.log(await this.addGroupInDifference(vector))\n                // console.log(await this.addGroupInSimilarity(vector))\n                // console.log(vector)\n                _context2.t0 = console;\n                _context2.next = 4;\n                return this.kmeans(vector, 3);\n              case 4:\n                _context2.t1 = _context2.sent;\n                _context2.t0.log.call(_context2.t0, _context2.t1);\n              case 6:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function test202210300033() {\n        return _test.apply(this, arguments);\n      }\n      return test202210300033;\n    }(),\n    test202210301729: function () {\n      var _test2 = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var vector;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                vector = [[1, 2, 3, 1], [5, 2, 3, 1], [1, 2, 4, 0], [5, 3, 4, 0]]; // console.log(await this.toVector(vector))\n                // console.log(await this.addKmeans(vector))\n                // console.log(vector)\n                // console.log(await this.kmeans(vector, 2))\n                // console.log(await this.groupingBySimilarity(vector, \'member\', 2))\n                // console.log(await this.groupingByDifference(vector, \'member\', 2))\n              case 1:\n              case "end":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      function test202210301729() {\n        return _test2.apply(this, arguments);\n      }\n      return test202210301729;\n    }(),\n    toVector: function () {\n      var _toVector = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(data) {\n        var rows, columeLength, c, list, isColumnNumber, d, value, isNumber, _ret, map, id, _d, _value, vectors, v, keys, i, _d2, _value2, _i, v2;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                // console.log(data)\n                rows = new Array(data.length);\n                columeLength = data[0].length;\n                c = this.localConfig.GroupingTool.skipColumns;\n              case 3:\n                if (!(c < columeLength)) {\n                  _context4.next = 37;\n                  break;\n                }\n                list = [];\n                isColumnNumber = true;\n                d = 0;\n              case 7:\n                if (!(d < data.length)) {\n                  _context4.next = 19;\n                  break;\n                }\n                value = data[d][c];\n                isNumber = typeof value === \'number\';\n                if (!(isNumber === false)) {\n                  _context4.next = 15;\n                  break;\n                }\n                isColumnNumber = false;\n                return _context4.abrupt("break", 19);\n              case 15:\n                list.push(value);\n              case 16:\n                d++;\n                _context4.next = 7;\n                break;\n              case 19:\n                if (!(isColumnNumber === true)) {\n                  _context4.next = 25;\n                  break;\n                }\n                _ret = function () {\n                  var max = Math.max.apply(Math, list);\n                  var min = Math.min.apply(Math, list);\n                  var range = max - min;\n                  if (range === 0) {\n                    return "continue";\n                  }\n                  var normalized = void 0;\n                  if (max === 1 && min === 0) {\n                    normalized = list;\n                  } else {\n                    normalized = list.map(function (value) {\n                      return (value - min) / range;\n                    });\n                  }\n                  for (var r = 0; r < rows.length; r++) {\n                    if (!rows[r]) {\n                      rows[r] = [];\n                    }\n                    rows[r].push(normalized[r]);\n                  }\n                }();\n                if (!(_ret === "continue")) {\n                  _context4.next = 23;\n                  break;\n                }\n                return _context4.abrupt("continue", 34);\n              case 23:\n                _context4.next = 34;\n                break;\n              case 25:\n                map = {};\n                id = 0;\n                for (_d = 0; _d < data.length; _d++) {\n                  _value = data[_d][c];\n                  _value = _value + \'\';\n                  // console.log(value)\n                  if (!map[_value]) {\n                    map[_value] = id;\n                    id++;\n                  }\n                  list.push(_value);\n                }\n\n                // console.log(map, list)\n                vectors = [];\n                v = [];\n                keys = Object.keys(map);\n                for (i = 0; i < keys.length; i++) {\n                  v[i] = 0;\n                }\n                // console.log(v)\n\n                for (_d2 = 0; _d2 < data.length; _d2++) {\n                  _value2 = data[_d2][c];\n                  _value2 = _value2 + \'\';\n                  _i = keys.indexOf(_value2); // console.log(i)\n                  v2 = [].concat(v);\n                  v2[_i] = 1;\n                  vectors.push(v2);\n                }\n                // console.log(vectors)\n\n                vectors.forEach(function (vector, r) {\n                  if (!rows[r]) {\n                    rows[r] = [];\n                  }\n                  rows[r] = rows[r].concat(vector);\n                });\n              case 34:\n                c++;\n                _context4.next = 3;\n                break;\n              case 37:\n                return _context4.abrupt("return", rows);\n              case 38:\n              case "end":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n      function toVector(_x) {\n        return _toVector.apply(this, arguments);\n      }\n      return toVector;\n    }(),\n    // kmeans: async function (data, cluster = 3) {\n    //   let vector = await this.toVector(data)\n    //   return new Promise(function (resolve, reject) {\n    //     // console.log(cluster)\n    //     kmeans(vector, cluster, function(err, clusterVector, clusterIndex, cluster, centroids) {\n    //       if (err) {\n    //         // throw new Error(err)\n    //         return reject(err)\n    //       }\n\n    //       //do something with the result\n    //       // console.log(res)\n    //       resolve({\n    //         clusterVector,\n    //         clusterIndex,\n    //         cluster,\n    //         centroids\n    //       })\n    //     })\n    //   })\n    //   // console.log(vector) \n    // },\n    kmeans: function () {\n      var _kmeans2 = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(data) {\n        var cluster,\n          vector,\n          _args5 = arguments;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                cluster = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : 3;\n                _context5.next = 3;\n                return this.toVector(data);\n              case 3:\n                vector = _context5.sent;\n                return _context5.abrupt("return", GroupingTool_kmeans(vector, cluster));\n              case 5:\n              case "end":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function kmeans(_x2) {\n        return _kmeans2.apply(this, arguments);\n      }\n      return kmeans;\n    }(),\n    addKmeans: function () {\n      var _addKmeans = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(vector) {\n        var cluster,\n          result,\n          _args6 = arguments;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                cluster = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : 3;\n                _context6.next = 3;\n                return this.kmeans(vector, cluster);\n              case 3:\n                result = _context6.sent;\n                return _context6.abrupt("return", vector.map(function (item, i) {\n                  // console.log(item, i, result.clusterIndex)\n                  item.push(result.clusterVector[i]);\n                  return item;\n                }));\n              case 5:\n              case "end":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function addKmeans(_x3) {\n        return _addKmeans.apply(this, arguments);\n      }\n      return addKmeans;\n    }(),\n    groupingByDifference: function () {\n      var _groupingByDifference = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(vector) {\n        var groupType,\n          member,\n          result,\n          groups,\n          groupIndexList,\n          mod,\n          minMembers,\n          counter,\n          i,\n          group,\n          clusterI,\n          baseMember,\n          v,\n          randomId,\n          item,\n          output,\n          _args7 = arguments;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                groupType = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : \'member\';\n                member = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : 3;\n                member = Number(member);\n                _context7.next = 5;\n                return this.kmeans(vector, member);\n              case 5:\n                result = _context7.sent;\n                // console.log(result)\n                groups = Math.ceil(vector.length / member);\n                if (groupType === \'group\') {\n                  groups = member;\n                  member = Number(Math.floor(vector.length / groups));\n                }\n                // console.log(groups, member)\n                groupIndexList = [];\n                mod = vector.length % groups;\n                minMembers = Math.floor(vector.length / groups);\n                counter = 0; // console.log(groups)\n                i = 0;\n              case 13:\n                if (!(i < groups)) {\n                  _context7.next = 39;\n                  break;\n                }\n                group = [];\n                clusterI = 0;\n                baseMember = minMembers;\n                if (i < mod) {\n                  baseMember++;\n                }\n\n                // console.log(baseMember)\n                // continue\n              case 18:\n                if (false) {}\n                v = result.clusterIndex[clusterI % groups]; // console.log(v, counter, vector.length) \n                if (!(v.length === 0)) {\n                  _context7.next = 23;\n                  break;\n                }\n                clusterI++;\n                return _context7.abrupt("continue", 18);\n              case 23:\n                randomId = Math.floor(Math.random() * v.length);\n                item = v[randomId];\n                group.push(Number(item));\n                // console.log(item)\n\n                v.splice(randomId, 1);\n                // console.log(vector)\n                // clusterVector[(clusterI % member)] = v\n                // console.log(result.clusterVector)\n                // console.log(v)\n\n                clusterI++;\n                counter++;\n                // console.log(counter, group.length, member)\n                if (!(counter === vector.length)) {\n                  _context7.next = 31;\n                  break;\n                }\n                return _context7.abrupt("break", 35);\n              case 31:\n                if (!(group.length === baseMember)) {\n                  _context7.next = 33;\n                  break;\n                }\n                return _context7.abrupt("break", 35);\n              case 33:\n                _context7.next = 18;\n                break;\n              case 35:\n                // console.log(group)\n                groupIndexList.push(group);\n              case 36:\n                i++;\n                _context7.next = 13;\n                break;\n              case 39:\n                // console.log(groupIndexList)\n                // let invertGroup = new Array(groups)\n                output = [].concat(vector);\n                groupIndexList.forEach(function (list, groupId) {\n                  list.forEach(function (index) {\n                    var o = [].concat(output[index]);\n                    o.push(groupId);\n                    output[index] = o;\n                  });\n                });\n                return _context7.abrupt("return", output);\n              case 42:\n              case "end":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n      function groupingByDifference(_x4) {\n        return _groupingByDifference.apply(this, arguments);\n      }\n      return groupingByDifference;\n    }(),\n    groupingBySimilarity: function () {\n      var _groupingBySimilarity = asyncToGenerator_default()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(vector) {\n        var groupType,\n          member,\n          groups,\n          _yield$this$kmeans,\n          clusterIndex,\n          isFinish,\n          i,\n          list,\n          randomId,\n          _randomId,\n          _args8 = arguments;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                groupType = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : \'member\';\n                member = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : 3;\n                member = Number(member);\n                groups = Math.ceil(vector.length / member);\n                if (groupType === \'group\') {\n                  groups = member;\n                  member = Math.ceil(vector.length / groups);\n                }\n                console.log(groups, member);\n                _context8.next = 8;\n                return this.kmeans(vector, groups);\n              case 8:\n                _yield$this$kmeans = _context8.sent;\n                clusterIndex = _yield$this$kmeans.clusterIndex;\n                console.log(clusterIndex);\n                this.sortClusterIndexBySize(clusterIndex);\n              case 12:\n                if (false) {}\n                isFinish = true;\n                i = 0;\n              case 15:\n                if (!(i < clusterIndex.length)) {\n                  _context8.next = 26;\n                  break;\n                }\n                list = clusterIndex[i];\n                if (!(list.length <= member && list.length >= member - 1)) {\n                  _context8.next = 19;\n                  break;\n                }\n                return _context8.abrupt("continue", 23);\n              case 19:\n                isFinish = false;\n                if (list.length > member) {\n                  randomId = Math.floor(Math.random() * list.length);\n                  clusterIndex[clusterIndex.length - 1].push(list[randomId]);\n                  list.splice(randomId, 1);\n                } else {\n                  _randomId = Math.floor(Math.random() * clusterIndex[0].length);\n                  clusterIndex[i].push(clusterIndex[0][_randomId]);\n                  clusterIndex[0].splice(_randomId, 1);\n                }\n                this.sortClusterIndexBySize(clusterIndex);\n                return _context8.abrupt("break", 26);\n              case 23:\n                i++;\n                _context8.next = 15;\n                break;\n              case 26:\n                if (!isFinish) {\n                  _context8.next = 28;\n                  break;\n                }\n                return _context8.abrupt("break", 30);\n              case 28:\n                _context8.next = 12;\n                break;\n              case 30:\n                Object.keys(clusterIndex).forEach(function (groupId) {\n                  clusterIndex[groupId].forEach(function (i) {\n                    vector[i].push(Number(groupId));\n                  });\n                });\n                return _context8.abrupt("return", vector);\n              case 32:\n              case "end":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n      function groupingBySimilarity(_x5) {\n        return _groupingBySimilarity.apply(this, arguments);\n      }\n      return groupingBySimilarity;\n    }(),\n    sortClusterIndexBySize: function sortClusterIndexBySize(clusterIndex) {\n      clusterIndex.sort(function (a, b) {\n        return b.length - a.length;\n      });\n    }\n  }\n};\n/* harmony default export */ var GroupingToolvue_type_script_lang_js_ = (GroupingTool);\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.js?vue&type=script&lang=js&\n /* harmony default export */ var GroupingTool_GroupingToolvue_type_script_lang_js_ = (GroupingToolvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.less?vue&type=style&index=0&id=1d066bc0&lang=less&scoped=true&\nvar GroupingToolvue_type_style_index_0_id_1d066bc0_lang_less_scoped_true_ = __webpack_require__(385);\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(8);\n\n// EXTERNAL MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.yaml?vue&type=custom&index=0&blockType=i18n&issuerPath=%2Fapp%2Fsrc%2Fcomponents%2FReplacePanel%2FGroupingTool%2FGroupingTool.vue&lang=yaml\nvar GroupingToolvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml = __webpack_require__(387);\n\n// CONCATENATED MODULE: ./src/components/ReplacePanel/GroupingTool/GroupingTool.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  GroupingTool_GroupingToolvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "1d066bc0",\n  null\n  \n)\n\n/* custom blocks */\n\nif (typeof GroupingToolvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml["default"] === \'function\') Object(GroupingToolvue_type_custom_index_0_blockType_i18n_issuerPath_2Fapp_2Fsrc_2Fcomponents_2FReplacePanel_2FGroupingTool_2FGroupingTool_vue_lang_yaml["default"])(component)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "src/components/ReplacePanel/GroupingTool/GroupingTool.vue"\n/* harmony default export */ var GroupingTool_GroupingTool = __webpack_exports__["default"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wuaHRtbD85ZWIzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1JlcGxhY2VQYW5lbC9Hcm91cGluZ1Rvb2wva21lYW5zLmpzPzFhODIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvUmVwbGFjZVBhbmVsL0dyb3VwaW5nVG9vbC9Hcm91cGluZ1Rvb2wuanM/ZDZhYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9SZXBsYWNlUGFuZWwvR3JvdXBpbmdUb29sL0dyb3VwaW5nVG9vbC5qcz85NTAxIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1JlcGxhY2VQYW5lbC9Hcm91cGluZ1Rvb2wvR3JvdXBpbmdUb29sLnZ1ZT85NWQ4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJHcm91cGluZ1Rvb2xcIiB9LCBbXG4gICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJmaWVsZHNcIiB9LCBbXG4gICAgICBfYyhcImxhYmVsXCIsIHsgYXR0cnM6IHsgZm9yOiBcIkdyb3VwaW5nVG9vbFNraXBDb2x1bW5zXCIgfSB9LCBbXG4gICAgICAgIF92bS5fdihcIlxcbiAgICAgIFwiICsgX3ZtLl9zKF92bS4kdChcIlNraXAgQ29sc1wiKSkgKyBcIlxcbiAgICBcIilcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICB2YWx1ZTogX3ZtLmxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5za2lwQ29sdW1ucyxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IFwibG9jYWxDb25maWcuR3JvdXBpbmdUb29sLnNraXBDb2x1bW5zXCJcbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGF0dHJzOiB7IHR5cGU6IFwibnVtYmVyXCIsIGlkOiBcIkdyb3VwaW5nVG9vbFNraXBDb2x1bW5zXCIgfSxcbiAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuc2tpcENvbHVtbnMgfSxcbiAgICAgICAgb246IHtcbiAgICAgICAgICBpbnB1dDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdm0uJHNldChcbiAgICAgICAgICAgICAgX3ZtLmxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbCxcbiAgICAgICAgICAgICAgXCJza2lwQ29sdW1uc1wiLFxuICAgICAgICAgICAgICAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJzZWxlY3RcIixcbiAgICAgICAge1xuICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgdmFsdWU6IF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuZ3JvdXBUeXBlLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5ncm91cFR5cGVcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgb246IHtcbiAgICAgICAgICAgIGNoYW5nZTogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhciAkJHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxuICAgICAgICAgICAgICAgIC5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucywgZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IFwiX3ZhbHVlXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIF92bS4kc2V0KFxuICAgICAgICAgICAgICAgIF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wsXG4gICAgICAgICAgICAgICAgXCJncm91cFR5cGVcIixcbiAgICAgICAgICAgICAgICAkZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIF9jKFwib3B0aW9uXCIsIHsgYXR0cnM6IHsgdmFsdWU6IFwiZ3JvdXBcIiB9IH0sIFtcbiAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLiR0KFwiR3JvdXA6IFwiKSkpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcIm9wdGlvblwiLCB7IGF0dHJzOiB7IHZhbHVlOiBcIm1lbWJlclwiIH0gfSwgW1xuICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0uJHQoXCJNZW1iZXI6IFwiKSkpXG4gICAgICAgICAgXSlcbiAgICAgICAgXVxuICAgICAgKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgdmFsdWU6IF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wuZ3JvdXBMZW5ndGgsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBcImxvY2FsQ29uZmlnLkdyb3VwaW5nVG9vbC5ncm91cExlbmd0aFwiXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBhdHRyczogeyB0eXBlOiBcIm51bWJlclwiIH0sXG4gICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0ubG9jYWxDb25maWcuR3JvdXBpbmdUb29sLmdyb3VwTGVuZ3RoIH0sXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3ZtLiRzZXQoXG4gICAgICAgICAgICAgIF92bS5sb2NhbENvbmZpZy5Hcm91cGluZ1Rvb2wsXG4gICAgICAgICAgICAgIFwiZ3JvdXBMZW5ndGhcIixcbiAgICAgICAgICAgICAgJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBdKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsImNvbnN0IE1BWF9JVEVSQVRJT05TID0gNTA7XG5cbmZ1bmN0aW9uIHJhbmRvbUJldHdlZW4obWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNhbGNNZWFuQ2VudHJvaWQoZGF0YVNldCwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBmZWF0dXJlcyA9IGRhdGFTZXRbMF0ubGVuZ3RoO1xuICBjb25zdCBuID0gZW5kIC0gc3RhcnQ7XG4gIGxldCBtZWFuID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZmVhdHVyZXM7IGkrKykge1xuICAgIG1lYW4ucHVzaCgwKTtcbiAgfVxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmVhdHVyZXM7IGorKykge1xuICAgICAgbWVhbltqXSA9IG1lYW5bal0gKyBkYXRhU2V0W2ldW2pdIC8gbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lYW47XG59XG5cbmZ1bmN0aW9uIGdldFJhbmRvbUNlbnRyb2lkc05haXZlU2hhcmRpbmcoZGF0YXNldCwgaykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBhIHZhcmlhdGlvbiBvZiBuYWl2ZSBzaGFyZGluZyBjZW50cm9pZCBpbml0aWFsaXphdGlvbiBtZXRob2RcbiAgLy8gKG5vdCB1c2luZyBzdW1zIG9yIHNvcnRpbmcsIGp1c3QgZGl2aWRpbmcgaW50byBrIHNoYXJkcyBhbmQgY2FsYyBtZWFuKVxuICAvLyBodHRwczovL3d3dy5rZG51Z2dldHMuY29tLzIwMTcvMDMvbmFpdmUtc2hhcmRpbmctY2VudHJvaWQtaW5pdGlhbGl6YXRpb24tbWV0aG9kLmh0bWxcbiAgY29uc3QgbnVtU2FtcGxlcyA9IGRhdGFzZXQubGVuZ3RoO1xuICAvLyBEaXZpZGUgZGF0YXNldCBpbnRvIGsgc2hhcmRzOlxuICBjb25zdCBzdGVwID0gTWF0aC5mbG9vcihudW1TYW1wbGVzIC8gayk7XG4gIGNvbnN0IGNlbnRyb2lkcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgIGNvbnN0IHN0YXJ0ID0gc3RlcCAqIGk7XG4gICAgbGV0IGVuZCA9IHN0ZXAgKiAoaSArIDEpO1xuICAgIGlmIChpICsgMSA9PT0gaykge1xuICAgICAgZW5kID0gbnVtU2FtcGxlcztcbiAgICB9XG4gICAgY2VudHJvaWRzLnB1c2goY2FsY01lYW5DZW50cm9pZChkYXRhc2V0LCBzdGFydCwgZW5kKSk7XG4gIH1cbiAgcmV0dXJuIGNlbnRyb2lkcztcbn1cblxuZnVuY3Rpb24gZ2V0UmFuZG9tQ2VudHJvaWRzKGRhdGFzZXQsIGspIHtcbiAgLy8gc2VsZWN0cyByYW5kb20gcG9pbnRzIGFzIGNlbnRyb2lkcyBmcm9tIHRoZSBkYXRhc2V0XG4gIGNvbnN0IG51bVNhbXBsZXMgPSBkYXRhc2V0Lmxlbmd0aDtcbiAgY29uc3QgY2VudHJvaWRzSW5kZXggPSBbXTtcbiAgbGV0IGluZGV4O1xuICB3aGlsZSAoY2VudHJvaWRzSW5kZXgubGVuZ3RoIDwgaykge1xuICAgIGluZGV4ID0gcmFuZG9tQmV0d2VlbigwLCBudW1TYW1wbGVzKTtcbiAgICBpZiAoY2VudHJvaWRzSW5kZXguaW5kZXhPZihpbmRleCkgPT09IC0xKSB7XG4gICAgICBjZW50cm9pZHNJbmRleC5wdXNoKGluZGV4KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgY2VudHJvaWRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2VudHJvaWRzSW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjZW50cm9pZCA9IFtdLmNvbmNhdChkYXRhc2V0W2NlbnRyb2lkc0luZGV4W2ldXSk7XG4gICAgY2VudHJvaWRzLnB1c2goY2VudHJvaWQpO1xuICB9XG4gIHJldHVybiBjZW50cm9pZHM7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVDZW50cm9pZHMoYSwgYikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkU3RvcChvbGRDZW50cm9pZHMsIGNlbnRyb2lkcywgaXRlcmF0aW9ucykge1xuICBpZiAoaXRlcmF0aW9ucyA+IE1BWF9JVEVSQVRJT05TKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFvbGRDZW50cm9pZHMgfHwgIW9sZENlbnRyb2lkcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IHNhbWVDb3VudCA9IHRydWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2VudHJvaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFjb21wYXJlQ2VudHJvaWRzKGNlbnRyb2lkc1tpXSwgb2xkQ2VudHJvaWRzW2ldKSkge1xuICAgICAgc2FtZUNvdW50ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBzYW1lQ291bnQ7XG59XG5cbi8vIENhbGN1bGF0ZSBTcXVhcmVkIEV1Y2xpZGVhbiBEaXN0YW5jZVxuZnVuY3Rpb24gZ2V0RGlzdGFuY2VTUShhLCBiKSB7XG4gIGNvbnN0IGRpZmZzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGRpZmZzLnB1c2goYVtpXSAtIGJbaV0pO1xuICB9XG4gIHJldHVybiBkaWZmcy5yZWR1Y2UoKHIsIGUpID0+IChyICsgKGUgKiBlKSksIDApO1xufVxuXG4vLyBSZXR1cm5zIGEgbGFiZWwgZm9yIGVhY2ggcGllY2Ugb2YgZGF0YSBpbiB0aGUgZGF0YXNldC4gXG5mdW5jdGlvbiBnZXRMYWJlbHMoZGF0YVNldCwgY2VudHJvaWRzKSB7XG4gIC8vIHByZXAgZGF0YSBzdHJ1Y3R1cmU6XG4gIGNvbnN0IGxhYmVscyA9IHt9O1xuICBmb3IgKGxldCBjID0gMDsgYyA8IGNlbnRyb2lkcy5sZW5ndGg7IGMrKykge1xuICAgIGxhYmVsc1tjXSA9IHtcbiAgICAgIHBvaW50czogW10sXG4gICAgICBjZW50cm9pZDogY2VudHJvaWRzW2NdLFxuICAgICAgaW5kZXhlczogW11cbiAgICB9O1xuICB9XG4gIC8vIEZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIGRhdGFzZXQsIGNob29zZSB0aGUgY2xvc2VzdCBjZW50cm9pZC4gXG4gIC8vIE1ha2UgdGhhdCBjZW50cm9pZCB0aGUgZWxlbWVudCdzIGxhYmVsLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFTZXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhID0gZGF0YVNldFtpXTtcbiAgICBsZXQgY2xvc2VzdENlbnRyb2lkLCBjbG9zZXN0Q2VudHJvaWRJbmRleCwgcHJldkRpc3RhbmNlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2VudHJvaWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBsZXQgY2VudHJvaWQgPSBjZW50cm9pZHNbal07XG4gICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICBjbG9zZXN0Q2VudHJvaWQgPSBjZW50cm9pZDtcbiAgICAgICAgY2xvc2VzdENlbnRyb2lkSW5kZXggPSBqO1xuICAgICAgICBwcmV2RGlzdGFuY2UgPSBnZXREaXN0YW5jZVNRKGEsIGNsb3Nlc3RDZW50cm9pZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnZXQgZGlzdGFuY2U6XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gZ2V0RGlzdGFuY2VTUShhLCBjZW50cm9pZCk7XG4gICAgICAgIGlmIChkaXN0YW5jZSA8IHByZXZEaXN0YW5jZSkge1xuICAgICAgICAgIHByZXZEaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgIGNsb3Nlc3RDZW50cm9pZCA9IGNlbnRyb2lkO1xuICAgICAgICAgIGNsb3Nlc3RDZW50cm9pZEluZGV4ID0gajtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgcG9pbnQgdG8gY2VudHJvaWQgbGFiZWxzOlxuICAgIGxhYmVsc1tjbG9zZXN0Q2VudHJvaWRJbmRleF0ucG9pbnRzLnB1c2goYSk7XG4gICAgbGFiZWxzW2Nsb3Nlc3RDZW50cm9pZEluZGV4XS5pbmRleGVzLnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIGxhYmVscztcbn1cblxuZnVuY3Rpb24gZ2V0UG9pbnRzTWVhbihwb2ludExpc3QpIHtcbiAgY29uc3QgdG90YWxQb2ludHMgPSBwb2ludExpc3QubGVuZ3RoO1xuICBjb25zdCBtZWFucyA9IFtdO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IHBvaW50TGlzdFswXS5sZW5ndGg7IGorKykge1xuICAgIG1lYW5zLnB1c2goMCk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwb2ludCA9IHBvaW50TGlzdFtpXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBvaW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCB2YWwgPSBwb2ludFtqXTtcbiAgICAgIG1lYW5zW2pdID0gbWVhbnNbal0gKyB2YWwgLyB0b3RhbFBvaW50cztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lYW5zO1xufVxuXG5mdW5jdGlvbiByZWNhbGN1bGF0ZUNlbnRyb2lkcyhkYXRhU2V0LCBsYWJlbHMsIGspIHtcbiAgLy8gRWFjaCBjZW50cm9pZCBpcyB0aGUgZ2VvbWV0cmljIG1lYW4gb2YgdGhlIHBvaW50cyB0aGF0XG4gIC8vIGhhdmUgdGhhdCBjZW50cm9pZCdzIGxhYmVsLiBJbXBvcnRhbnQ6IElmIGEgY2VudHJvaWQgaXMgZW1wdHkgKG5vIHBvaW50cyBoYXZlXG4gIC8vIHRoYXQgY2VudHJvaWQncyBsYWJlbCkgeW91IHNob3VsZCByYW5kb21seSByZS1pbml0aWFsaXplIGl0LlxuICBsZXQgbmV3Q2VudHJvaWQ7XG4gIGNvbnN0IG5ld0NlbnRyb2lkTGlzdCA9IFtdO1xuICBmb3IgKGNvbnN0IGsgaW4gbGFiZWxzKSB7XG4gICAgY29uc3QgY2VudHJvaWRHcm91cCA9IGxhYmVsc1trXTtcbiAgICBpZiAoY2VudHJvaWRHcm91cC5wb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gZmluZCBtZWFuOlxuICAgICAgbmV3Q2VudHJvaWQgPSBnZXRQb2ludHNNZWFuKGNlbnRyb2lkR3JvdXAucG9pbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZ2V0IG5ldyByYW5kb20gY2VudHJvaWRcbiAgICAgIG5ld0NlbnRyb2lkID0gZ2V0UmFuZG9tQ2VudHJvaWRzKGRhdGFTZXQsIDEpWzBdO1xuICAgIH1cbiAgICBuZXdDZW50cm9pZExpc3QucHVzaChuZXdDZW50cm9pZCk7XG4gIH1cbiAgcmV0dXJuIG5ld0NlbnRyb2lkTGlzdDtcbn1cblxuZnVuY3Rpb24ga21lYW5zKGRhdGFzZXQsIGssIHVzZU5haXZlU2hhcmRpbmcgPSB0cnVlKSB7XG4gICAgLy8gICBjb25zb2xlLmxvZyhkYXRhc2V0KVxuICBpZiAoZGF0YXNldC5sZW5ndGggJiYgZGF0YXNldFswXS5sZW5ndGggJiYgZGF0YXNldC5sZW5ndGggPiBrKSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBib29rIGtlZXBpbmcgdmFyaWFibGVzXG4gICAgbGV0IGl0ZXJhdGlvbnMgPSAwO1xuICAgIGxldCBvbGRDZW50cm9pZHMsIGxhYmVscywgY2VudHJvaWRzO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBjZW50cm9pZHMgcmFuZG9tbHlcbiAgICBpZiAodXNlTmFpdmVTaGFyZGluZykge1xuICAgICAgY2VudHJvaWRzID0gZ2V0UmFuZG9tQ2VudHJvaWRzTmFpdmVTaGFyZGluZyhkYXRhc2V0LCBrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VudHJvaWRzID0gZ2V0UmFuZG9tQ2VudHJvaWRzKGRhdGFzZXQsIGspO1xuICAgIH1cblxuICAgIC8vIFJ1biB0aGUgbWFpbiBrLW1lYW5zIGFsZ29yaXRobVxuICAgIHdoaWxlICghc2hvdWxkU3RvcChvbGRDZW50cm9pZHMsIGNlbnRyb2lkcywgaXRlcmF0aW9ucykpIHtcbiAgICAgIC8vIFNhdmUgb2xkIGNlbnRyb2lkcyBmb3IgY29udmVyZ2VuY2UgdGVzdC5cbiAgICAgIG9sZENlbnRyb2lkcyA9IFtdLmNvbmNhdChjZW50cm9pZHMpO1xuICAgICAgaXRlcmF0aW9ucysrO1xuXG4gICAgICAvLyBBc3NpZ24gbGFiZWxzIHRvIGVhY2ggZGF0YXBvaW50IGJhc2VkIG9uIGNlbnRyb2lkc1xuICAgICAgbGFiZWxzID0gZ2V0TGFiZWxzKGRhdGFzZXQsIGNlbnRyb2lkcyk7XG4gICAgICBjZW50cm9pZHMgPSByZWNhbGN1bGF0ZUNlbnRyb2lkcyhkYXRhc2V0LCBsYWJlbHMsIGspO1xuICAgIH1cblxuICAgIGNvbnN0IGNsdXN0ZXJzID0gW107XG4gICAgbGV0IGRhdGFzZXRMYWJlbHMgPSBuZXcgQXJyYXkoZGF0YXNldC5sZW5ndGgpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgIGNsdXN0ZXJzLnB1c2gobGFiZWxzW2ldLmluZGV4ZXMpO1xuICAgICAgbGFiZWxzW2ldLmluZGV4ZXMuZm9yRWFjaChkYXRhc2V0SW5kZXggPT4ge1xuICAgICAgICBkYXRhc2V0TGFiZWxzW2RhdGFzZXRJbmRleF0gPSBpXG4gICAgICB9KVxuICAgIH1cbiAgICBcbiAgICBjb25zdCByZXN1bHRzID0ge1xuICAgICAgZGF0YXNldExhYmVscyxcbiAgICAgIGNsdXN0ZXJWZWN0b3I6IGRhdGFzZXRMYWJlbHMsXG4gICAgICBjbHVzdGVyczogY2x1c3RlcnMsXG4gICAgICBjbHVzdGVySW5kZXg6IGNsdXN0ZXJzLFxuICAgICAgY2VudHJvaWRzOiBjZW50cm9pZHMsXG4gICAgICBpdGVyYXRpb25zOiBpdGVyYXRpb25zLFxuICAgICAgY29udmVyZ2VkOiBpdGVyYXRpb25zIDw9IE1BWF9JVEVSQVRJT05TLFxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGFzZXQnKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBrbWVhbnM7IiwiaW1wb3J0IGttZWFucyBmcm9tICcuL2ttZWFucy5qcydcclxuXHJcbmxldCBHcm91cGluZ1Rvb2wgPSB7XHJcbiAgcHJvcHM6IFsnY29uZmlnJywgJ2xvY2FsQ29uZmlnJywgJ3V0aWxzJ10sXHJcbiAgZGF0YSAoKSB7ICAgIFxyXG4gICAgdGhpcy4kaTE4bi5sb2NhbGUgPSB0aGlzLmxvY2FsQ29uZmlnLmxvY2FsZVxyXG4gICAgcmV0dXJuIHtcclxuICAgIH1cclxuICB9LFxyXG4gIHdhdGNoOiB7XHJcbiAgICAnbG9jYWxDb25maWcubG9jYWxlJygpIHtcclxuICAgICAgdGhpcy4kaTE4bi5sb2NhbGUgPSB0aGlzLmxvY2FsQ29uZmlnLmxvY2FsZTtcclxuICAgIH0sXHJcbiAgfSxcclxuICAvLyBjb21wdXRlZDoge1xyXG4gICAgXHJcbiAgLy8gfSxcclxuICBtb3VudGVkOiBhc3luYyBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnRlc3QyMDIyMTAzMDE3MjkoKVxyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgdGVzdDIwMjIxMDMwMDAzMzogYXN5bmMgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgLy8gdmFyIHZlY3RvciA9IFtcclxuICAgICAgLy8gICBbMSwgMTAsIDIsIDMwXSxcclxuICAgICAgLy8gICBbJ0EnLCAzMCwgMjAsIDJdLFxyXG4gICAgICAvLyAgIFsnQicsIDMwLCAzMCwgM10sXHJcbiAgICAgIC8vICAgWydDJywgMzAsIDMxLCAzXSxcclxuICAgICAgLy8gICBbJ0EnLCAxMCwgMTAsIDFdLFxyXG4gICAgICAvLyAgIFsnQicsIDIwLCAxLCAzMF0sXHJcbiAgICAgIC8vICAgWydDJywgMSwgMjUsIDMwXVxyXG4gICAgICAvLyBdXHJcblxyXG4gICAgICB2YXIgdmVjdG9yID0gW1xyXG4gICAgICAgIFsxMCwgMiwgMzBdLFxyXG4gICAgICAgIFszMCwgMjAsIDJdLFxyXG4gICAgICAgIFszMCwgMzAsIDNdLFxyXG4gICAgICAgIFszMCwgMzEsIDNdLFxyXG4gICAgICAgIFsxMCwgMTAsIDFdLFxyXG4gICAgICAgIFsyMCwgMSwgMzBdLFxyXG4gICAgICAgIFsxLCAyNSwgMzBdXHJcbiAgICAgIF1cclxuXHJcblxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLnRvVmVjdG9yKHZlY3RvcikpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMuYWRkS21lYW5zKHZlY3RvcikpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMuYWRkR3JvdXBJbkRpZmZlcmVuY2UodmVjdG9yKSlcclxuICAgICAgLy8gY29uc29sZS5sb2coYXdhaXQgdGhpcy5hZGRHcm91cEluU2ltaWxhcml0eSh2ZWN0b3IpKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyh2ZWN0b3IpXHJcbiAgICAgIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMua21lYW5zKHZlY3RvciwgMykpXHJcbiAgICB9LFxyXG4gICAgdGVzdDIwMjIxMDMwMTcyOTogYXN5bmMgZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgdmFyIHZlY3RvciA9IFtcclxuICAgICAgICBbMSwgMiwgMywgMV0sXHJcbiAgICAgICAgWzUsMiwzLDFdLFxyXG4gICAgICAgIFsxLDIsNCwwXSxcclxuICAgICAgICBbNSwzLDQsMF1cclxuICAgICAgXVxyXG5cclxuXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMudG9WZWN0b3IodmVjdG9yKSlcclxuICAgICAgLy8gY29uc29sZS5sb2coYXdhaXQgdGhpcy5hZGRLbWVhbnModmVjdG9yKSlcclxuICAgICAgLy8gY29uc29sZS5sb2codmVjdG9yKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLmttZWFucyh2ZWN0b3IsIDIpKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLmdyb3VwaW5nQnlTaW1pbGFyaXR5KHZlY3RvciwgJ21lbWJlcicsIDIpKVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLmdyb3VwaW5nQnlEaWZmZXJlbmNlKHZlY3RvciwgJ21lbWJlcicsIDIpKVxyXG4gICAgfSxcclxuICAgIHRvVmVjdG9yOiBhc3luYyBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGRhdGEpXHJcblxyXG5cclxuICAgICAgbGV0IHJvd3MgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpXHJcbiAgICAgIGxldCBjb2x1bWVMZW5ndGggPSBkYXRhWzBdLmxlbmd0aFxyXG5cclxuICAgICAgZm9yIChsZXQgYyA9IHRoaXMubG9jYWxDb25maWcuR3JvdXBpbmdUb29sLnNraXBDb2x1bW5zOyBjIDwgY29sdW1lTGVuZ3RoOyBjKyspIHtcclxuICAgICAgICBsZXQgbGlzdCA9IFtdXHJcbiAgICAgICAgbGV0IGlzQ29sdW1uTnVtYmVyID0gdHJ1ZVxyXG5cclxuICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcclxuICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGFbZF1bY11cclxuICAgICAgICAgIGxldCBpc051bWJlciA9ICh0eXBlb2YodmFsdWUpID09PSAnbnVtYmVyJylcclxuICAgICAgICAgIGlmIChpc051bWJlciA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaXNDb2x1bW5OdW1iZXIgPSBmYWxzZVxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxpc3QucHVzaCh2YWx1ZSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGlzQ29sdW1uTnVtYmVyKVxyXG5cclxuICAgICAgICBpZiAoaXNDb2x1bW5OdW1iZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgIGxldCBtYXggPSBNYXRoLm1heCguLi5saXN0KVxyXG4gICAgICAgICAgbGV0IG1pbiA9IE1hdGgubWluKC4uLmxpc3QpXHJcbiAgICAgICAgICBsZXQgcmFuZ2UgPSBtYXggLSBtaW5cclxuICAgICAgICAgIGlmIChyYW5nZSA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGxldCBub3JtYWxpemVkXHJcbiAgICAgICAgICBpZiAobWF4ID09PSAxICYmIG1pbiA9PT0gMCkge1xyXG4gICAgICAgICAgICBub3JtYWxpemVkID0gbGlzdFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBsaXN0Lm1hcCh2YWx1ZSA9PiAoKHZhbHVlIC0gbWluKSAvIHJhbmdlKSlcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKGxldCByID0gMDsgciA8IHJvd3MubGVuZ3RoOyByKyspIHtcclxuICAgICAgICAgICAgaWYgKCFyb3dzW3JdKSB7XHJcbiAgICAgICAgICAgICAgcm93c1tyXSA9IFtdXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJvd3Nbcl0ucHVzaChub3JtYWxpemVkW3JdKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIGxldCBtYXAgPSB7fVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBsZXQgaWQgPSAwXHJcbiAgICAgICAgICBmb3IgKGxldCBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZGF0YVtkXVtjXVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgJydcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codmFsdWUpXHJcbiAgICAgICAgICAgIGlmICghbWFwW3ZhbHVlXSkge1xyXG4gICAgICAgICAgICAgIG1hcFt2YWx1ZV0gPSBpZFxyXG4gICAgICAgICAgICAgIGlkKytcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaXN0LnB1c2godmFsdWUpXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2cobWFwLCBsaXN0KVxyXG5cclxuICAgICAgICAgIGxldCB2ZWN0b3JzID0gW11cclxuICAgICAgICAgIGxldCB2ID0gW11cclxuICAgICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMobWFwKVxyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZbaV0gPSAwXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyh2KVxyXG5cclxuICAgICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgZGF0YS5sZW5ndGg7IGQrKykge1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBkYXRhW2RdW2NdXHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyAnJ1xyXG4gICAgICAgICAgICBsZXQgaSA9IGtleXMuaW5kZXhPZih2YWx1ZSlcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coaSlcclxuICAgICAgICAgICAgbGV0IHYyID0gW10uY29uY2F0KHYpXHJcbiAgICAgICAgICAgIHYyW2ldID0gMVxyXG4gICAgICAgICAgICB2ZWN0b3JzLnB1c2godjIpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyh2ZWN0b3JzKVxyXG5cclxuICAgICAgICAgIHZlY3RvcnMuZm9yRWFjaCgodmVjdG9yLCByKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghcm93c1tyXSkge1xyXG4gICAgICAgICAgICAgIHJvd3Nbcl0gPSBbXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvd3Nbcl0gPSByb3dzW3JdLmNvbmNhdCh2ZWN0b3IpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY29uc29sZS5sb2cocm93cylcclxuXHJcbiAgICAgIHJldHVybiByb3dzXHJcbiAgICB9LFxyXG4gICAgLy8ga21lYW5zOiBhc3luYyBmdW5jdGlvbiAoZGF0YSwgY2x1c3RlciA9IDMpIHtcclxuICAgIC8vICAgbGV0IHZlY3RvciA9IGF3YWl0IHRoaXMudG9WZWN0b3IoZGF0YSlcclxuICAgIC8vICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgIC8vICAgICAvLyBjb25zb2xlLmxvZyhjbHVzdGVyKVxyXG4gICAgLy8gICAgIGttZWFucyh2ZWN0b3IsIGNsdXN0ZXIsIGZ1bmN0aW9uKGVyciwgY2x1c3RlclZlY3RvciwgY2x1c3RlckluZGV4LCBjbHVzdGVyLCBjZW50cm9pZHMpIHtcclxuICAgIC8vICAgICAgIGlmIChlcnIpIHtcclxuICAgIC8vICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKGVycilcclxuICAgIC8vICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpXHJcbiAgICAvLyAgICAgICB9XHJcbiAgICAgIFxyXG4gICAgLy8gICAgICAgLy9kbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XHJcbiAgICAvLyAgICAgICAvLyBjb25zb2xlLmxvZyhyZXMpXHJcbiAgICAvLyAgICAgICByZXNvbHZlKHtcclxuICAgIC8vICAgICAgICAgY2x1c3RlclZlY3RvcixcclxuICAgIC8vICAgICAgICAgY2x1c3RlckluZGV4LFxyXG4gICAgLy8gICAgICAgICBjbHVzdGVyLFxyXG4gICAgLy8gICAgICAgICBjZW50cm9pZHNcclxuICAgIC8vICAgICAgIH0pXHJcbiAgICAvLyAgICAgfSlcclxuICAgIC8vICAgfSlcclxuICAgIC8vICAgLy8gY29uc29sZS5sb2codmVjdG9yKSBcclxuICAgIC8vIH0sXHJcbiAgICBrbWVhbnM6IGFzeW5jIGZ1bmN0aW9uIChkYXRhLCBjbHVzdGVyID0gMykge1xyXG4gICAgICBsZXQgdmVjdG9yID0gYXdhaXQgdGhpcy50b1ZlY3RvcihkYXRhKVxyXG4gICAgICAvLyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGNsdXN0ZXIpXHJcbiAgICAgICAgLy8gcmVzb3ZsZShrbWVhbnModmVjdG9yLCBjbHVzdGVyKSlcclxuICAgICAgLy8gfSlcclxuICAgICAgLy8gY29uc29sZS5sb2codmVjdG9yKSBcclxuICAgICAgcmV0dXJuIGttZWFucyh2ZWN0b3IsIGNsdXN0ZXIpXHJcbiAgICB9LFxyXG4gICAgYWRkS21lYW5zOiBhc3luYyBmdW5jdGlvbiAodmVjdG9yLCBjbHVzdGVyID0gMykge1xyXG4gICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5rbWVhbnModmVjdG9yLCBjbHVzdGVyKVxyXG5cclxuICAgICAgcmV0dXJuIHZlY3Rvci5tYXAoKGl0ZW0sIGkpID0+IHtcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhpdGVtLCBpLCByZXN1bHQuY2x1c3RlckluZGV4KVxyXG4gICAgICAgIGl0ZW0ucHVzaChyZXN1bHQuY2x1c3RlclZlY3RvcltpXSlcclxuICAgICAgICByZXR1cm4gaXRlbVxyXG4gICAgICB9KVxyXG4gICAgfSxcclxuICAgIGdyb3VwaW5nQnlEaWZmZXJlbmNlOiBhc3luYyBmdW5jdGlvbiAodmVjdG9yLCBncm91cFR5cGUgPSAnbWVtYmVyJywgbWVtYmVyID0gMykge1xyXG4gICAgICBtZW1iZXIgPSBOdW1iZXIobWVtYmVyKVxyXG4gICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5rbWVhbnModmVjdG9yLCBtZW1iZXIpXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKHJlc3VsdClcclxuXHJcbiAgICAgIGxldCBncm91cHMgPSBNYXRoLmNlaWwodmVjdG9yLmxlbmd0aCAvIG1lbWJlcilcclxuICAgICAgXHJcbiAgICAgIGlmIChncm91cFR5cGUgPT09ICdncm91cCcpIHtcclxuICAgICAgICBncm91cHMgPSBtZW1iZXJcclxuICAgICAgICBtZW1iZXIgPSBOdW1iZXIoTWF0aC5mbG9vcih2ZWN0b3IubGVuZ3RoIC8gZ3JvdXBzKSlcclxuICAgICAgfVxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhncm91cHMsIG1lbWJlcilcclxuICAgICAgXHJcbiAgICAgIGxldCBncm91cEluZGV4TGlzdCA9IFtdXHJcbiAgICAgIGxldCBtb2QgPSB2ZWN0b3IubGVuZ3RoICUgZ3JvdXBzXHJcbiAgICAgIGxldCBtaW5NZW1iZXJzID0gTWF0aC5mbG9vcih2ZWN0b3IubGVuZ3RoIC8gZ3JvdXBzKVxyXG5cclxuICAgICAgbGV0IGNvdW50ZXIgPSAwXHJcbiAgICAgIC8vIGNvbnNvbGUubG9nKGdyb3VwcylcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHM7IGkrKykge1xyXG4gICAgICAgIGxldCBncm91cCA9IFtdXHJcblxyXG4gICAgICAgIGxldCBjbHVzdGVySSA9IDBcclxuICAgICAgICBsZXQgYmFzZU1lbWJlciA9IG1pbk1lbWJlcnNcclxuICAgICAgICBpZiAoaSA8IG1vZCkge1xyXG4gICAgICAgICAgYmFzZU1lbWJlcisrXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhiYXNlTWVtYmVyKVxyXG4gICAgICAgIC8vIGNvbnRpbnVlXHJcblxyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICBsZXQgdiA9IHJlc3VsdC5jbHVzdGVySW5kZXhbKGNsdXN0ZXJJICUgZ3JvdXBzKV1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gY29uc29sZS5sb2codiwgY291bnRlciwgdmVjdG9yLmxlbmd0aCkgXHJcbiAgICAgICAgICBpZiAodi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgY2x1c3RlckkrK1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGxldCByYW5kb21JZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHYubGVuZ3RoKVxyXG4gICAgICAgICAgbGV0IGl0ZW0gPSB2W3JhbmRvbUlkXVxyXG4gICAgICAgICAgZ3JvdXAucHVzaChOdW1iZXIoaXRlbSkpXHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhpdGVtKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICB2LnNwbGljZShyYW5kb21JZCwgMSlcclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZlY3RvcilcclxuICAgICAgICAgIC8vIGNsdXN0ZXJWZWN0b3JbKGNsdXN0ZXJJICUgbWVtYmVyKV0gPSB2XHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhyZXN1bHQuY2x1c3RlclZlY3RvcilcclxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHYpXHJcblxyXG4gICAgICAgICAgY2x1c3RlckkrK1xyXG4gICAgICAgICAgY291bnRlcisrXHJcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjb3VudGVyLCBncm91cC5sZW5ndGgsIG1lbWJlcilcclxuICAgICAgICAgIGlmIChjb3VudGVyID09PSB2ZWN0b3IubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGdyb3VwLmxlbmd0aCA9PT0gYmFzZU1lbWJlcikge1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb25zb2xlLmxvZyhncm91cClcclxuICAgICAgICBncm91cEluZGV4TGlzdC5wdXNoKGdyb3VwKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjb25zb2xlLmxvZyhncm91cEluZGV4TGlzdClcclxuXHJcbiAgICAgIC8vIGxldCBpbnZlcnRHcm91cCA9IG5ldyBBcnJheShncm91cHMpXHJcbiAgICAgIGxldCBvdXRwdXQgPSBbXS5jb25jYXQodmVjdG9yKVxyXG4gICAgICBncm91cEluZGV4TGlzdC5mb3JFYWNoKChsaXN0LCBncm91cElkKSA9PiB7XHJcbiAgICAgICAgbGlzdC5mb3JFYWNoKGluZGV4ID0+IHtcclxuICAgICAgICAgIGxldCBvID0gW10uY29uY2F0KG91dHB1dFtpbmRleF0pXHJcbiAgICAgICAgICBvLnB1c2goZ3JvdXBJZClcclxuICAgICAgICAgIG91dHB1dFtpbmRleF0gPSBvXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiBvdXRwdXRcclxuICAgIH0sXHJcbiAgICBncm91cGluZ0J5U2ltaWxhcml0eTogYXN5bmMgZnVuY3Rpb24gKHZlY3RvciwgZ3JvdXBUeXBlID0gJ21lbWJlcicsIG1lbWJlciA9IDMpIHtcclxuICAgICAgbWVtYmVyID0gTnVtYmVyKG1lbWJlcilcclxuICAgICAgbGV0IGdyb3VwcyA9IE1hdGguY2VpbCh2ZWN0b3IubGVuZ3RoIC8gbWVtYmVyKVxyXG5cclxuICAgICAgaWYgKGdyb3VwVHlwZSA9PT0gJ2dyb3VwJykge1xyXG4gICAgICAgIGdyb3VwcyA9IG1lbWJlclxyXG4gICAgICAgIG1lbWJlciA9IE1hdGguY2VpbCh2ZWN0b3IubGVuZ3RoIC8gZ3JvdXBzKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhncm91cHMsIG1lbWJlcilcclxuXHJcbiAgICAgIGxldCB7Y2x1c3RlckluZGV4fSA9IGF3YWl0IHRoaXMua21lYW5zKHZlY3RvciwgZ3JvdXBzKVxyXG4gICAgICBjb25zb2xlLmxvZyhjbHVzdGVySW5kZXgpIFxyXG4gICAgICB0aGlzLnNvcnRDbHVzdGVySW5kZXhCeVNpemUoY2x1c3RlckluZGV4KVxyXG4gICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGxldCBpc0ZpbmlzaCA9IHRydWVcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsdXN0ZXJJbmRleC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgbGV0IGxpc3QgPSBjbHVzdGVySW5kZXhbaV1cclxuICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCA8PSBtZW1iZXIgJiYgbGlzdC5sZW5ndGggPj0gbWVtYmVyIC0gMSkge1xyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlzRmluaXNoID0gZmFsc2VcclxuXHJcbiAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPiBtZW1iZXIpIHtcclxuICAgICAgICAgICAgbGV0IHJhbmRvbUlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGlzdC5sZW5ndGgpXHJcbiAgICAgICAgICAgIGNsdXN0ZXJJbmRleFsoY2x1c3RlckluZGV4Lmxlbmd0aCAtIDEpXS5wdXNoKGxpc3RbcmFuZG9tSWRdKVxyXG4gICAgICAgICAgICBsaXN0LnNwbGljZShyYW5kb21JZCwgMSlcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgcmFuZG9tSWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjbHVzdGVySW5kZXhbMF0ubGVuZ3RoKVxyXG4gICAgICAgICAgICBjbHVzdGVySW5kZXhbaV0ucHVzaChjbHVzdGVySW5kZXhbMF1bcmFuZG9tSWRdKVxyXG4gICAgICAgICAgICBjbHVzdGVySW5kZXhbMF0uc3BsaWNlKHJhbmRvbUlkLCAxKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICB0aGlzLnNvcnRDbHVzdGVySW5kZXhCeVNpemUoY2x1c3RlckluZGV4KVxyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBpZiAoaXNGaW5pc2gpIHtcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICB9XHJcblxyXG4gICAgICBPYmplY3Qua2V5cyhjbHVzdGVySW5kZXgpLmZvckVhY2goZ3JvdXBJZCA9PiB7XHJcbiAgICAgICAgY2x1c3RlckluZGV4W2dyb3VwSWRdLmZvckVhY2goaSA9PiB7XHJcbiAgICAgICAgICB2ZWN0b3JbaV0ucHVzaChOdW1iZXIoZ3JvdXBJZCkpXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiB2ZWN0b3JcclxuICAgIH0sXHJcbiAgICBzb3J0Q2x1c3RlckluZGV4QnlTaXplIChjbHVzdGVySW5kZXgpIHtcclxuICAgICAgY2x1c3RlckluZGV4LnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aFxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgR3JvdXBpbmdUb29sIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS02IS4vR3JvdXBpbmdUb29sLmpzP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTYhLi9Hcm91cGluZ1Rvb2wuanM/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0dyb3VwaW5nVG9vbC5odG1sP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTFkMDY2YmMwJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0dyb3VwaW5nVG9vbC5qcz92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vR3JvdXBpbmdUb29sLmpzP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL0dyb3VwaW5nVG9vbC5sZXNzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MWQwNjZiYzAmbGFuZz1sZXNzJnNjb3BlZD10cnVlJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCIxZDA2NmJjMFwiLFxuICBudWxsXG4gIFxuKVxuXG4vKiBjdXN0b20gYmxvY2tzICovXG5pbXBvcnQgYmxvY2swIGZyb20gXCIuL0dyb3VwaW5nVG9vbC55YW1sP3Z1ZSZ0eXBlPWN1c3RvbSZpbmRleD0wJmJsb2NrVHlwZT1pMThuJmlzc3VlclBhdGg9JTJGYXBwJTJGc3JjJTJGY29tcG9uZW50cyUyRlJlcGxhY2VQYW5lbCUyRkdyb3VwaW5nVG9vbCUyRkdyb3VwaW5nVG9vbC52dWUmbGFuZz15YW1sXCJcbmlmICh0eXBlb2YgYmxvY2swID09PSAnZnVuY3Rpb24nKSBibG9jazAoY29tcG9uZW50KVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIi9hcHAvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaS9kaXN0L2luZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnMWQwNjZiYzAnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnMWQwNjZiYzAnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnMWQwNjZiYzAnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0dyb3VwaW5nVG9vbC5odG1sP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTFkMDY2YmMwJnNjb3BlZD10cnVlJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzFkMDY2YmMwJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJzcmMvY29tcG9uZW50cy9SZXBsYWNlUGFuZWwvR3JvdXBpbmdUb29sL0dyb3VwaW5nVG9vbC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN4R0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUpBO0FBQUE7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FDMU5BO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQVJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFjQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQW5GQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBeUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQSw2QkFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFDQTtBQUFBO0FBNUNBO0FBQUE7QUFBQTtBQUFBO0FBK0NBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBLDZCQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBcEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUF5QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FDOVZBOzs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQWlCQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///424\n')}}]);